"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("pages/_app",{

/***/ "./utils/firestore.ts":
/*!****************************!*\
  !*** ./utils/firestore.ts ***!
  \****************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   addProduct: function() { return /* binding */ addProduct; },\n/* harmony export */   clearProductCache: function() { return /* binding */ clearProductCache; },\n/* harmony export */   db: function() { return /* binding */ db; },\n/* harmony export */   deleteProduct: function() { return /* binding */ deleteProduct; },\n/* harmony export */   deleteProductImage: function() { return /* binding */ deleteProductImage; },\n/* harmony export */   getAllCategories: function() { return /* binding */ getAllCategories; },\n/* harmony export */   getAllProducts: function() { return /* binding */ getAllProducts; },\n/* harmony export */   getFeaturedProducts: function() { return /* binding */ getFeaturedProducts; },\n/* harmony export */   getImageById: function() { return /* binding */ getImageById; },\n/* harmony export */   getNewArrivals: function() { return /* binding */ getNewArrivals; },\n/* harmony export */   getNextProductsPage: function() { return /* binding */ getNextProductsPage; },\n/* harmony export */   getProductById: function() { return /* binding */ getProductById; },\n/* harmony export */   getProductsByCategory: function() { return /* binding */ getProductsByCategory; },\n/* harmony export */   storage: function() { return /* binding */ storage; },\n/* harmony export */   updateProduct: function() { return /* binding */ updateProduct; },\n/* harmony export */   uploadProductImage: function() { return /* binding */ uploadProductImage; }\n/* harmony export */ });\n/* harmony import */ var _firebase__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./firebase */ \"./utils/firebase.ts\");\n/* harmony import */ var firebase_firestore__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! firebase/firestore */ \"./node_modules/firebase/firestore/dist/esm/index.esm.js\");\n/* harmony import */ var firebase_storage__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! firebase/storage */ \"./node_modules/firebase/storage/dist/esm/index.esm.js\");\n\n\n\n// Initialize Firestore\nconst db = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.getFirestore)(_firebase__WEBPACK_IMPORTED_MODULE_0__.app);\n// Initialize Storage\nconst storage = (0,firebase_storage__WEBPACK_IMPORTED_MODULE_2__.getStorage)(_firebase__WEBPACK_IMPORTED_MODULE_0__.app);\n// Collection references\nconst productsCollection = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.collection)(db, \"products\");\nconst categoriesCollection = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.collection)(db, \"categories\");\n// Cache for products\nconst productCache = {\n    all: null,\n    byId: {},\n    byCategory: {},\n    lastFetched: 0\n};\n// Cache expiration time (5 minutes)\nconst CACHE_EXPIRATION = 5 * 60 * 1000;\n// Validate product data before saving\nconst validateProduct = (product)=>{\n    if (!product.name || typeof product.name !== \"string\") {\n        return \"Product name is required\";\n    }\n    if (!product.price || isNaN(Number(product.price))) {\n        return \"Valid product price is required\";\n    }\n    if (!product.category || typeof product.category !== \"string\") {\n        return \"Product category is required\";\n    }\n    if (!product.image || typeof product.image !== \"string\") {\n        return \"Product image is required\";\n    }\n    return null; // No errors\n};\n// Clean product data for Firestore\nconst cleanProductData = (product)=>{\n    const cleanedProduct = {};\n    Object.entries(product).forEach((param)=>{\n        let [key, value] = param;\n        if (value !== undefined && value !== null) {\n            // Handle specific field types\n            if (key === \"price\" || key === \"originalPrice\" || key === \"stock\") {\n                cleanedProduct[key] = Number(value);\n            } else if (key === \"sizes\" && typeof value === \"string\") {\n                cleanedProduct[key] = value.split(\",\").map((s)=>s.trim()).filter(Boolean);\n            } else if (key === \"featured\" && typeof value === \"string\") {\n                cleanedProduct[key] = value === \"true\";\n            } else {\n                cleanedProduct[key] = value;\n            }\n        }\n    });\n    // Add timestamps\n    if (!cleanedProduct.createdAt) {\n        cleanedProduct.createdAt = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.serverTimestamp)();\n    }\n    cleanedProduct.updatedAt = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.serverTimestamp)();\n    return cleanedProduct;\n};\n// Check if cache is valid\nconst isCacheValid = ()=>{\n    return productCache.all !== null && Date.now() - productCache.lastFetched < CACHE_EXPIRATION;\n};\n// Get all products with pagination and caching\nconst getAllProducts = async function() {\n    let pageSize = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;\n    try {\n        // If cache is valid and we're not paginating, return cached products\n        if (isCacheValid() && pageSize === 0 && productCache.all) {\n            console.log(\"Returning \".concat(productCache.all.length, \" products from cache\"));\n            return productCache.all;\n        }\n        console.log(\"Cache invalid or empty, fetching products from Firestore...\");\n        let productsQuery = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.query)(productsCollection, (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.orderBy)(\"createdAt\", \"desc\"));\n        // Apply pagination if pageSize is specified\n        if (pageSize > 0) {\n            productsQuery = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.query)(productsQuery, (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.limit)(pageSize));\n        }\n        console.log(\"Executing Firestore query...\");\n        const snapshot = await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.getDocs)(productsQuery);\n        console.log(\"Raw Firestore query returned \".concat(snapshot.docs.length, \" documents\"));\n        const products = snapshot.docs.map((doc)=>{\n            const data = doc.data();\n            // Log each product for debugging\n            console.log(\"Processing product: \".concat(doc.id, \" - \").concat(data.name || \"Unnamed product\"));\n            return {\n                id: doc.id,\n                ...data\n            };\n        });\n        // Update cache if we're getting all products\n        if (pageSize === 0) {\n            productCache.all = products;\n            // Update byId and byCategory caches\n            products.forEach((product)=>{\n                productCache.byId[product.id] = product;\n                if (product.category) {\n                    if (!productCache.byCategory[product.category]) {\n                        productCache.byCategory[product.category] = [];\n                    }\n                    productCache.byCategory[product.category].push(product);\n                }\n            });\n            productCache.lastFetched = Date.now();\n        }\n        console.log(\"Successfully processed and returning \".concat(products.length, \" products from Firestore\"));\n        return products;\n    } catch (error) {\n        console.error(\"Error getting products from Firestore:\", error);\n        throw new Error(\"Failed to fetch products\");\n    }\n};\n// Get next page of products\nconst getNextProductsPage = async function(lastVisible) {\n    let pageSize = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 20;\n    try {\n        const productsQuery = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.query)(productsCollection, (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.orderBy)(\"createdAt\", \"desc\"), (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.startAfter)(lastVisible), (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.limit)(pageSize));\n        const snapshot = await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.getDocs)(productsQuery);\n        const products = snapshot.docs.map((doc)=>({\n                id: doc.id,\n                ...doc.data()\n            }));\n        // Update cache for these products\n        products.forEach((product)=>{\n            productCache.byId[product.id] = product;\n            if (product.category) {\n                if (!productCache.byCategory[product.category]) {\n                    productCache.byCategory[product.category] = [];\n                }\n                // Check if product already exists in category cache\n                const existingIndex = productCache.byCategory[product.category].findIndex((p)=>p.id === product.id);\n                if (existingIndex >= 0) {\n                    productCache.byCategory[product.category][existingIndex] = product;\n                } else {\n                    productCache.byCategory[product.category].push(product);\n                }\n            }\n        });\n        return products;\n    } catch (error) {\n        console.error(\"Error getting next page of products:\", error);\n        throw new Error(\"Failed to fetch more products\");\n    }\n};\n// Get products by category with caching\nconst getProductsByCategory = async (category)=>{\n    try {\n        // Check if we have this category in cache and it's still valid\n        if (isCacheValid() && productCache.byCategory[category] && productCache.byCategory[category].length > 0) {\n            console.log(\"Returning \".concat(category, \" products from cache\"));\n            return productCache.byCategory[category];\n        }\n        console.log(\"Fetching \".concat(category, \" products from Firestore\"));\n        const q = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.query)(productsCollection, (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.where)(\"category\", \"==\", category));\n        const snapshot = await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.getDocs)(q);\n        const products = snapshot.docs.map((doc)=>({\n                id: doc.id,\n                ...doc.data()\n            }));\n        // Update cache\n        productCache.byCategory[category] = products;\n        // Also update byId cache\n        products.forEach((product)=>{\n            productCache.byId[product.id] = product;\n        });\n        return products;\n    } catch (error) {\n        console.error(\"Error getting \".concat(category, \" products:\"), error);\n        throw new Error(\"Failed to fetch \".concat(category, \" products\"));\n    }\n};\n// Get featured products with caching\nconst getFeaturedProducts = async function() {\n    let limitCount = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 8;\n    try {\n        // If we have all products cached, filter them\n        if (isCacheValid() && productCache.all) {\n            const featured = productCache.all.filter((p)=>p.featured).slice(0, limitCount);\n            if (featured.length > 0) {\n                console.log(\"Returning featured products from cache\");\n                return featured;\n            }\n        }\n        console.log(\"Fetching featured products from Firestore\");\n        const q = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.query)(productsCollection, (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.where)(\"featured\", \"==\", true), (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.orderBy)(\"createdAt\", \"desc\"), (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.limit)(limitCount));\n        const snapshot = await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.getDocs)(q);\n        const products = snapshot.docs.map((doc)=>({\n                id: doc.id,\n                ...doc.data()\n            }));\n        // Update byId cache\n        products.forEach((product)=>{\n            productCache.byId[product.id] = product;\n            // Update category cache if needed\n            if (product.category) {\n                if (!productCache.byCategory[product.category]) {\n                    productCache.byCategory[product.category] = [];\n                }\n                // Check if product already exists in category cache\n                const existingIndex = productCache.byCategory[product.category].findIndex((p)=>p.id === product.id);\n                if (existingIndex >= 0) {\n                    productCache.byCategory[product.category][existingIndex] = product;\n                } else {\n                    productCache.byCategory[product.category].push(product);\n                }\n            }\n        });\n        return products;\n    } catch (error) {\n        console.error(\"Error getting featured products:\", error);\n        throw new Error(\"Failed to fetch featured products\");\n    }\n};\n// Get new arrivals with caching\nconst getNewArrivals = async function() {\n    let limitCount = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 8;\n    try {\n        // If we have all products cached, filter them\n        if (isCacheValid() && productCache.all) {\n            const newArrivals = productCache.all.filter((p)=>p.new).slice(0, limitCount);\n            if (newArrivals.length > 0) {\n                console.log(\"Returning new arrivals from cache\");\n                return newArrivals;\n            }\n        }\n        console.log(\"Fetching new arrivals from Firestore\");\n        const q = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.query)(productsCollection, (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.where)(\"new\", \"==\", true), (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.orderBy)(\"createdAt\", \"desc\"), (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.limit)(limitCount));\n        const snapshot = await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.getDocs)(q);\n        const products = snapshot.docs.map((doc)=>({\n                id: doc.id,\n                ...doc.data()\n            }));\n        // Update byId cache\n        products.forEach((product)=>{\n            productCache.byId[product.id] = product;\n            // Update category cache if needed\n            if (product.category) {\n                if (!productCache.byCategory[product.category]) {\n                    productCache.byCategory[product.category] = [];\n                }\n                // Check if product already exists in category cache\n                const existingIndex = productCache.byCategory[product.category].findIndex((p)=>p.id === product.id);\n                if (existingIndex >= 0) {\n                    productCache.byCategory[product.category][existingIndex] = product;\n                } else {\n                    productCache.byCategory[product.category].push(product);\n                }\n            }\n        });\n        return products;\n    } catch (error) {\n        console.error(\"Error getting new arrivals:\", error);\n        throw new Error(\"Failed to fetch new arrivals\");\n    }\n};\n// Get product by ID with caching\nconst getProductById = async (id)=>{\n    try {\n        // Check if product is in cache\n        if (productCache.byId[id]) {\n            console.log(\"Returning product \".concat(id, \" from cache\"));\n            return productCache.byId[id];\n        }\n        console.log(\"Fetching product \".concat(id, \" from Firestore\"));\n        const productDoc = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.doc)(db, \"products\", id);\n        const snapshot = await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.getDoc)(productDoc);\n        if (snapshot.exists()) {\n            const product = {\n                id: snapshot.id,\n                ...snapshot.data()\n            };\n            // Update cache\n            productCache.byId[id] = product;\n            return product;\n        }\n        return null;\n    } catch (error) {\n        console.error(\"Error getting product:\", error);\n        throw new Error(\"Failed to fetch product details\");\n    }\n};\n// Clear cache for a specific product\nconst invalidateProductCache = (productId, categoryId)=>{\n    // Remove from byId cache\n    if (productCache.byId[productId]) {\n        delete productCache.byId[productId];\n    }\n    // Remove from category cache if category is provided\n    if (categoryId && productCache.byCategory[categoryId]) {\n        productCache.byCategory[categoryId] = productCache.byCategory[categoryId].filter((p)=>p.id !== productId);\n    }\n    // Set all cache to null to force refresh on next fetch\n    productCache.all = null;\n};\n// Clear entire cache\nconst clearProductCache = ()=>{\n    productCache.all = null;\n    productCache.byId = {};\n    productCache.byCategory = {};\n    productCache.lastFetched = 0;\n};\n// Ensure we have a valid storage instance\nconst getStorageInstance = ()=>{\n    const storage =  true ? (0,firebase_storage__WEBPACK_IMPORTED_MODULE_2__.getStorage)(_firebase__WEBPACK_IMPORTED_MODULE_0__.app) : 0;\n    if (storage === null) {\n        return (0,firebase_storage__WEBPACK_IMPORTED_MODULE_2__.getStorage)(_firebase__WEBPACK_IMPORTED_MODULE_0__.app);\n    }\n    return storage;\n};\n// Upload image to Firebase Storage\nconst uploadProductImage = async (file)=>{\n    try {\n        // Check file size (limit to 5MB)\n        if (file.size > 5 * 1024 * 1024) {\n            throw new Error(\"Image file is too large. Please select an image smaller than 5MB.\");\n        }\n        // Convert file to base64\n        const base64String = await fileToBase64(file);\n        // Create a unique ID for the image\n        const timestamp = new Date().getTime();\n        const fileName = \"product_\".concat(timestamp, \"_\").concat(file.name.replace(/[^a-zA-Z0-9.]/g, \"_\"));\n        // Store the base64 image in Firestore\n        const imageCollection = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.collection)(db, \"images\");\n        const imageDoc = await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.addDoc)(imageCollection, {\n            name: fileName,\n            type: file.type,\n            base64: base64String,\n            createdAt: (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.serverTimestamp)()\n        });\n        // Return the document ID as the image URL\n        return \"base64://\".concat(imageDoc.id);\n    } catch (error) {\n        console.error(\"Error uploading image:\", error);\n        if (error instanceof Error) {\n            throw error;\n        } else {\n            throw new Error(\"Failed to upload product image. Please try again.\");\n        }\n    }\n};\n// Helper function to convert File to base64\nconst fileToBase64 = (file)=>{\n    return new Promise((resolve, reject)=>{\n        try {\n            const reader = new FileReader();\n            reader.readAsDataURL(file);\n            reader.onload = ()=>{\n                if (typeof reader.result === \"string\") {\n                    resolve(reader.result);\n                } else {\n                    reject(new Error(\"Failed to read image file\"));\n                }\n            };\n            reader.onerror = ()=>{\n                reject(new Error(\"Error reading image file. Please try a different image.\"));\n            };\n        } catch (error) {\n            reject(error instanceof Error ? error : new Error(\"Unknown error processing image\"));\n        }\n    });\n};\n// Get image by ID\nconst getImageById = async (imageId)=>{\n    try {\n        console.log(\"Fetching image with ID: \".concat(imageId));\n        const imageDoc = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.doc)(db, \"images\", imageId);\n        const snapshot = await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.getDoc)(imageDoc);\n        if (snapshot.exists()) {\n            const data = snapshot.data();\n            if (!data || !data.base64) {\n                console.error(\"Image exists but has no base64 data. ID: \".concat(imageId));\n                return \"/images/placeholder.jpg\";\n            }\n            console.log(\"Successfully retrieved base64 image. ID: \".concat(imageId));\n            return data.base64;\n        }\n        console.error(\"Image not found with ID: \".concat(imageId));\n        return \"/images/placeholder.jpg\";\n    } catch (error) {\n        console.error(\"Error getting image:\", error);\n        // Return a placeholder instead of throwing, to prevent UI breaking\n        return \"/images/placeholder.jpg\";\n    }\n};\n// Delete product image from Firestore\nconst deleteProductImage = async (imageUrl)=>{\n    try {\n        // Check if it's a base64 image\n        if (imageUrl.startsWith(\"base64://\")) {\n            const imageId = imageUrl.replace(\"base64://\", \"\");\n            const imageDoc = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.doc)(db, \"images\", imageId);\n            await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.deleteDoc)(imageDoc);\n            console.log(\"Product image deleted successfully from Firestore:\", imageId);\n            return;\n        }\n        // Handle legacy Storage URLs\n        const storage = getStorageInstance();\n        // Extract the file path from the URL\n        const decodedUrl = decodeURIComponent(imageUrl);\n        const startIndex = decodedUrl.indexOf(\"product_images\");\n        if (startIndex === -1) {\n            console.warn(\"Not a Firebase Storage URL or not in product_images folder:\", imageUrl);\n            return;\n        }\n        const endIndex = decodedUrl.indexOf(\"?\", startIndex);\n        const filePath = endIndex !== -1 ? decodedUrl.substring(startIndex, endIndex) : decodedUrl.substring(startIndex);\n        // Create a reference to the file\n        const imageRef = (0,firebase_storage__WEBPACK_IMPORTED_MODULE_2__.ref)(storage, filePath);\n        // Delete the file\n        await (0,firebase_storage__WEBPACK_IMPORTED_MODULE_2__.deleteObject)(imageRef);\n        console.log(\"Product image deleted successfully from Storage:\", filePath);\n    } catch (error) {\n        console.error(\"Error deleting product image:\", error);\n    // Don't throw error here, as we want to continue with product deletion\n    // even if image deletion fails\n    }\n};\n// Add a new product with transaction for category tracking\nconst addProduct = async (product)=>{\n    try {\n        console.log(\"Adding product to Firestore:\", product);\n        // Validate product data\n        const validationError = validateProduct(product);\n        if (validationError) {\n            throw new Error(validationError);\n        }\n        // Clean the product data for Firestore\n        const cleanedProduct = cleanProductData(product);\n        console.log(\"Cleaned product data for Firestore:\", cleanedProduct);\n        // Use transaction to add product and update category data\n        const newProduct = await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.runTransaction)(db, async (transaction)=>{\n            // Add the product document\n            const docRef = await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.addDoc)(productsCollection, cleanedProduct);\n            const newProductWithId = {\n                id: docRef.id,\n                ...cleanedProduct\n            };\n            // Update or create category count\n            const categoryRef = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.doc)(categoriesCollection, cleanedProduct.category);\n            const categoryDoc = await transaction.get(categoryRef);\n            if (categoryDoc.exists()) {\n                // Update existing category\n                transaction.update(categoryRef, {\n                    count: (categoryDoc.data().count || 0) + 1,\n                    updatedAt: (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.serverTimestamp)()\n                });\n            } else {\n                // Create new category\n                transaction.set(categoryRef, {\n                    id: cleanedProduct.category,\n                    name: cleanedProduct.category.charAt(0).toUpperCase() + cleanedProduct.category.slice(1),\n                    count: 1,\n                    createdAt: (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.serverTimestamp)(),\n                    updatedAt: (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.serverTimestamp)()\n                });\n            }\n            return newProductWithId;\n        });\n        // Update cache with the new product\n        if (productCache.all) {\n            productCache.all.unshift(newProduct);\n        }\n        productCache.byId[newProduct.id] = newProduct;\n        if (newProduct.category) {\n            if (!productCache.byCategory[newProduct.category]) {\n                productCache.byCategory[newProduct.category] = [];\n            }\n            productCache.byCategory[newProduct.category].unshift(newProduct);\n        }\n        console.log(\"Product added successfully with ID:\", newProduct.id);\n        return newProduct;\n    } catch (error) {\n        console.error(\"Error adding product to Firestore:\", error);\n        throw error;\n    }\n};\n// Update a product\nconst updateProduct = async (id, product)=>{\n    try {\n        const productDoc = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.doc)(db, \"products\", id);\n        // Get existing product to check if category is changing\n        const existingProductSnap = await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.getDoc)(productDoc);\n        if (!existingProductSnap.exists()) {\n            throw new Error(\"Product not found\");\n        }\n        const existingProduct = existingProductSnap.data();\n        const cleanedUpdates = cleanProductData(product);\n        // Always update the timestamp when modified\n        cleanedUpdates.updatedAt = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.serverTimestamp)();\n        await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.runTransaction)(db, async (transaction)=>{\n            // Update product document\n            transaction.update(productDoc, cleanedUpdates);\n            // If category changed, update both old and new category counts\n            if (product.category && existingProduct.category !== product.category) {\n                // Decrease old category count\n                const oldCategoryRef = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.doc)(categoriesCollection, existingProduct.category);\n                const oldCategoryDoc = await transaction.get(oldCategoryRef);\n                if (oldCategoryDoc.exists()) {\n                    const oldCount = oldCategoryDoc.data().count || 0;\n                    if (oldCount > 1) {\n                        transaction.update(oldCategoryRef, {\n                            count: oldCount - 1,\n                            updatedAt: (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.serverTimestamp)()\n                        });\n                    } else {\n                        // Delete category if it will be empty\n                        transaction.delete(oldCategoryRef);\n                    }\n                }\n                // Increase new category count\n                const newCategoryRef = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.doc)(categoriesCollection, product.category);\n                const newCategoryDoc = await transaction.get(newCategoryRef);\n                if (newCategoryDoc.exists()) {\n                    transaction.update(newCategoryRef, {\n                        count: (newCategoryDoc.data().count || 0) + 1,\n                        updatedAt: (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.serverTimestamp)()\n                    });\n                } else {\n                    transaction.set(newCategoryRef, {\n                        id: product.category,\n                        name: product.category.charAt(0).toUpperCase() + product.category.slice(1),\n                        count: 1,\n                        createdAt: (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.serverTimestamp)(),\n                        updatedAt: (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.serverTimestamp)()\n                    });\n                }\n            }\n        });\n        // Update cache\n        if (productCache.byId[id]) {\n            const updatedProduct = {\n                ...productCache.byId[id],\n                ...product\n            };\n            productCache.byId[id] = updatedProduct;\n            // Update in all products cache if it exists\n            if (productCache.all) {\n                const index = productCache.all.findIndex((p)=>p.id === id);\n                if (index >= 0) {\n                    productCache.all[index] = updatedProduct;\n                }\n            }\n            // Handle category change in cache\n            if (product.category && existingProduct.category !== product.category) {\n                // Remove from old category cache\n                if (productCache.byCategory[existingProduct.category]) {\n                    productCache.byCategory[existingProduct.category] = productCache.byCategory[existingProduct.category].filter((p)=>p.id !== id);\n                }\n                // Add to new category cache\n                if (!productCache.byCategory[product.category]) {\n                    productCache.byCategory[product.category] = [];\n                }\n                productCache.byCategory[product.category].push(updatedProduct);\n            } else if (product.category) {\n                // Update in same category\n                if (productCache.byCategory[product.category]) {\n                    const catIndex = productCache.byCategory[product.category].findIndex((p)=>p.id === id);\n                    if (catIndex >= 0) {\n                        productCache.byCategory[product.category][catIndex] = updatedProduct;\n                    }\n                }\n            }\n        } else {\n            // If not in cache, invalidate all cache to force refresh\n            clearProductCache();\n        }\n    } catch (error) {\n        console.error(\"Error updating product:\", error);\n        throw new Error(\"Failed to update product\");\n    }\n};\n// Delete a product\nconst deleteProduct = async (id)=>{\n    try {\n        const productDoc = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.doc)(db, \"products\", id);\n        // Get product to find its category and image URL\n        const productSnap = await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.getDoc)(productDoc);\n        if (!productSnap.exists()) {\n            throw new Error(\"Product not found\");\n        }\n        const productData = productSnap.data();\n        // Try to delete the product image first\n        if (productData.image) {\n            try {\n                await deleteProductImage(productData.image);\n            } catch (error) {\n                console.error(\"Error deleting product image:\", error);\n            // Continue with product deletion even if image deletion fails\n            }\n        }\n        await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.runTransaction)(db, async (transaction)=>{\n            // Delete product\n            transaction.delete(productDoc);\n            // Update category count\n            if (productData.category) {\n                const categoryRef = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.doc)(categoriesCollection, productData.category);\n                const categoryDoc = await transaction.get(categoryRef);\n                if (categoryDoc.exists()) {\n                    const count = categoryDoc.data().count || 0;\n                    if (count > 1) {\n                        transaction.update(categoryRef, {\n                            count: count - 1,\n                            updatedAt: (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.serverTimestamp)()\n                        });\n                    } else {\n                        // Delete category if it will be empty\n                        transaction.delete(categoryRef);\n                    }\n                }\n            }\n        });\n        // Update cache\n        invalidateProductCache(id, productData.category);\n    } catch (error) {\n        console.error(\"Error deleting product:\", error);\n        throw new Error(\"Failed to delete product\");\n    }\n};\n// Get all categories with product counts\nconst getAllCategories = async ()=>{\n    try {\n        const snapshot = await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.getDocs)(categoriesCollection);\n        return snapshot.docs.map((doc)=>doc.data());\n    } catch (error) {\n        console.error(\"Error getting categories:\", error);\n        throw new Error(\"Failed to fetch categories\");\n    }\n};\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi91dGlscy9maXJlc3RvcmUudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFpQztBQUNxTjtBQUN4SjtBQUc5Rix1QkFBdUI7QUFDaEIsTUFBTWtCLEtBQUtqQixnRUFBWUEsQ0FBQ0QsMENBQUdBLEVBQUU7QUFFcEMscUJBQXFCO0FBQ2QsTUFBTW1CLFVBQVVKLDREQUFVQSxDQUFDZiwwQ0FBR0EsRUFBRTtBQUV2Qyx3QkFBd0I7QUFDeEIsTUFBTW9CLHFCQUFxQmxCLDhEQUFVQSxDQUFDZ0IsSUFBSTtBQUMxQyxNQUFNRyx1QkFBdUJuQiw4REFBVUEsQ0FBQ2dCLElBQUk7QUFFNUMscUJBQXFCO0FBQ3JCLE1BQU1JLGVBS0Y7SUFDRkMsS0FBSztJQUNMQyxNQUFNLENBQUM7SUFDUEMsWUFBWSxDQUFDO0lBQ2JDLGFBQWE7QUFDZjtBQUVBLG9DQUFvQztBQUNwQyxNQUFNQyxtQkFBbUIsSUFBSSxLQUFLO0FBRWxDLHNDQUFzQztBQUN0QyxNQUFNQyxrQkFBa0IsQ0FBQ0M7SUFDdkIsSUFBSSxDQUFDQSxRQUFRQyxJQUFJLElBQUksT0FBT0QsUUFBUUMsSUFBSSxLQUFLLFVBQVU7UUFDckQsT0FBTztJQUNUO0lBRUEsSUFBSSxDQUFDRCxRQUFRRSxLQUFLLElBQUlDLE1BQU1DLE9BQU9KLFFBQVFFLEtBQUssSUFBSTtRQUNsRCxPQUFPO0lBQ1Q7SUFFQSxJQUFJLENBQUNGLFFBQVFLLFFBQVEsSUFBSSxPQUFPTCxRQUFRSyxRQUFRLEtBQUssVUFBVTtRQUM3RCxPQUFPO0lBQ1Q7SUFFQSxJQUFJLENBQUNMLFFBQVFNLEtBQUssSUFBSSxPQUFPTixRQUFRTSxLQUFLLEtBQUssVUFBVTtRQUN2RCxPQUFPO0lBQ1Q7SUFFQSxPQUFPLE1BQU0sWUFBWTtBQUMzQjtBQUVBLG1DQUFtQztBQUNuQyxNQUFNQyxtQkFBbUIsQ0FBQ1A7SUFDeEIsTUFBTVEsaUJBQXNDLENBQUM7SUFFN0NDLE9BQU9DLE9BQU8sQ0FBQ1YsU0FBU1csT0FBTyxDQUFDO1lBQUMsQ0FBQ0MsS0FBS0MsTUFBTTtRQUMzQyxJQUFJQSxVQUFVQyxhQUFhRCxVQUFVLE1BQU07WUFDekMsOEJBQThCO1lBQzlCLElBQUlELFFBQVEsV0FBV0EsUUFBUSxtQkFBbUJBLFFBQVEsU0FBUztnQkFDakVKLGNBQWMsQ0FBQ0ksSUFBSSxHQUFHUixPQUFPUztZQUMvQixPQUFPLElBQUlELFFBQVEsV0FBVyxPQUFPQyxVQUFVLFVBQVU7Z0JBQ3ZETCxjQUFjLENBQUNJLElBQUksR0FBR0MsTUFBTUUsS0FBSyxDQUFDLEtBQUtDLEdBQUcsQ0FBQyxDQUFDQyxJQUFjQSxFQUFFQyxJQUFJLElBQUlDLE1BQU0sQ0FBQ0M7WUFDN0UsT0FBTyxJQUFJUixRQUFRLGNBQWMsT0FBT0MsVUFBVSxVQUFVO2dCQUMxREwsY0FBYyxDQUFDSSxJQUFJLEdBQUdDLFVBQVU7WUFDbEMsT0FBTztnQkFDTEwsY0FBYyxDQUFDSSxJQUFJLEdBQUdDO1lBQ3hCO1FBQ0Y7SUFDRjtJQUVBLGlCQUFpQjtJQUNqQixJQUFJLENBQUNMLGVBQWVhLFNBQVMsRUFBRTtRQUM3QmIsZUFBZWEsU0FBUyxHQUFHdkMsbUVBQWVBO0lBQzVDO0lBQ0EwQixlQUFlYyxTQUFTLEdBQUd4QyxtRUFBZUE7SUFFMUMsT0FBTzBCO0FBQ1Q7QUFFQSwwQkFBMEI7QUFDMUIsTUFBTWUsZUFBZTtJQUNuQixPQUNFOUIsYUFBYUMsR0FBRyxLQUFLLFFBQ3JCOEIsS0FBS0MsR0FBRyxLQUFLaEMsYUFBYUksV0FBVyxHQUFHQztBQUU1QztBQUVBLCtDQUErQztBQUN4QyxNQUFNNEIsaUJBQWlCO1FBQU9DLDRFQUFtQjtJQUN0RCxJQUFJO1FBQ0YscUVBQXFFO1FBQ3JFLElBQUlKLGtCQUFrQkksYUFBYSxLQUFLbEMsYUFBYUMsR0FBRyxFQUFFO1lBQ3hEa0MsUUFBUUMsR0FBRyxDQUFDLGFBQXFDLE9BQXhCcEMsYUFBYUMsR0FBRyxDQUFDb0MsTUFBTSxFQUFDO1lBQ2pELE9BQU9yQyxhQUFhQyxHQUFHO1FBQ3pCO1FBRUFrQyxRQUFRQyxHQUFHLENBQUM7UUFFWixJQUFJRSxnQkFBZ0JwRCx5REFBS0EsQ0FBQ1ksb0JBQW9CUCwyREFBT0EsQ0FBQyxhQUFhO1FBRW5FLDRDQUE0QztRQUM1QyxJQUFJMkMsV0FBVyxHQUFHO1lBQ2hCSSxnQkFBZ0JwRCx5REFBS0EsQ0FBQ29ELGVBQWVoRCx5REFBS0EsQ0FBQzRDO1FBQzdDO1FBRUFDLFFBQVFDLEdBQUcsQ0FBQztRQUNaLE1BQU1HLFdBQVcsTUFBTTFELDJEQUFPQSxDQUFDeUQ7UUFDL0JILFFBQVFDLEdBQUcsQ0FBQyxnQ0FBcUQsT0FBckJHLFNBQVNDLElBQUksQ0FBQ0gsTUFBTSxFQUFDO1FBRWpFLE1BQU1JLFdBQVdGLFNBQVNDLElBQUksQ0FBQ2pCLEdBQUcsQ0FBQ3pDLENBQUFBO1lBQ2pDLE1BQU00RCxPQUFPNUQsSUFBSTRELElBQUk7WUFDckIsaUNBQWlDO1lBQ2pDUCxRQUFRQyxHQUFHLENBQUMsdUJBQW1DTSxPQUFaNUQsSUFBSTZELEVBQUUsRUFBQyxPQUFvQyxPQUEvQkQsS0FBS2xDLElBQUksSUFBSTtZQUM1RCxPQUFPO2dCQUNMbUMsSUFBSTdELElBQUk2RCxFQUFFO2dCQUNWLEdBQUdELElBQUk7WUFDVDtRQUNGO1FBRUEsNkNBQTZDO1FBQzdDLElBQUlSLGFBQWEsR0FBRztZQUNsQmxDLGFBQWFDLEdBQUcsR0FBR3dDO1lBRW5CLG9DQUFvQztZQUNwQ0EsU0FBU3ZCLE9BQU8sQ0FBQ1gsQ0FBQUE7Z0JBQ2ZQLGFBQWFFLElBQUksQ0FBQ0ssUUFBUW9DLEVBQUUsQ0FBQyxHQUFHcEM7Z0JBRWhDLElBQUlBLFFBQVFLLFFBQVEsRUFBRTtvQkFDcEIsSUFBSSxDQUFDWixhQUFhRyxVQUFVLENBQUNJLFFBQVFLLFFBQVEsQ0FBQyxFQUFFO3dCQUM5Q1osYUFBYUcsVUFBVSxDQUFDSSxRQUFRSyxRQUFRLENBQUMsR0FBRyxFQUFFO29CQUNoRDtvQkFDQVosYUFBYUcsVUFBVSxDQUFDSSxRQUFRSyxRQUFRLENBQUMsQ0FBQ2dDLElBQUksQ0FBQ3JDO2dCQUNqRDtZQUNGO1lBRUFQLGFBQWFJLFdBQVcsR0FBRzJCLEtBQUtDLEdBQUc7UUFDckM7UUFFQUcsUUFBUUMsR0FBRyxDQUFDLHdDQUF3RCxPQUFoQkssU0FBU0osTUFBTSxFQUFDO1FBQ3BFLE9BQU9JO0lBQ1QsRUFBRSxPQUFPSSxPQUFPO1FBQ2RWLFFBQVFVLEtBQUssQ0FBQywwQ0FBMENBO1FBQ3hELE1BQU0sSUFBSUMsTUFBTTtJQUNsQjtBQUNGLEVBQUU7QUFFRiw0QkFBNEI7QUFDckIsTUFBTUMsc0JBQXNCLGVBQ2pDQztRQUNBZCw0RUFBbUI7SUFFbkIsSUFBSTtRQUNGLE1BQU1JLGdCQUFnQnBELHlEQUFLQSxDQUN6Qlksb0JBQ0FQLDJEQUFPQSxDQUFDLGFBQWEsU0FDckJDLDhEQUFVQSxDQUFDd0QsY0FDWDFELHlEQUFLQSxDQUFDNEM7UUFHUixNQUFNSyxXQUFXLE1BQU0xRCwyREFBT0EsQ0FBQ3lEO1FBQy9CLE1BQU1HLFdBQVdGLFNBQVNDLElBQUksQ0FBQ2pCLEdBQUcsQ0FBQ3pDLENBQUFBLE1BQVE7Z0JBQ3pDNkQsSUFBSTdELElBQUk2RCxFQUFFO2dCQUNWLEdBQUc3RCxJQUFJNEQsSUFBSSxFQUFFO1lBQ2Y7UUFFQSxrQ0FBa0M7UUFDbENELFNBQVN2QixPQUFPLENBQUNYLENBQUFBO1lBQ2ZQLGFBQWFFLElBQUksQ0FBQ0ssUUFBUW9DLEVBQUUsQ0FBQyxHQUFHcEM7WUFFaEMsSUFBSUEsUUFBUUssUUFBUSxFQUFFO2dCQUNwQixJQUFJLENBQUNaLGFBQWFHLFVBQVUsQ0FBQ0ksUUFBUUssUUFBUSxDQUFDLEVBQUU7b0JBQzlDWixhQUFhRyxVQUFVLENBQUNJLFFBQVFLLFFBQVEsQ0FBQyxHQUFHLEVBQUU7Z0JBQ2hEO2dCQUVBLG9EQUFvRDtnQkFDcEQsTUFBTXFDLGdCQUFnQmpELGFBQWFHLFVBQVUsQ0FBQ0ksUUFBUUssUUFBUSxDQUFDLENBQUNzQyxTQUFTLENBQ3ZFQyxDQUFBQSxJQUFLQSxFQUFFUixFQUFFLEtBQUtwQyxRQUFRb0MsRUFBRTtnQkFHMUIsSUFBSU0saUJBQWlCLEdBQUc7b0JBQ3RCakQsYUFBYUcsVUFBVSxDQUFDSSxRQUFRSyxRQUFRLENBQUMsQ0FBQ3FDLGNBQWMsR0FBRzFDO2dCQUM3RCxPQUFPO29CQUNMUCxhQUFhRyxVQUFVLENBQUNJLFFBQVFLLFFBQVEsQ0FBQyxDQUFDZ0MsSUFBSSxDQUFDckM7Z0JBQ2pEO1lBQ0Y7UUFDRjtRQUVBLE9BQU9rQztJQUNULEVBQUUsT0FBT0ksT0FBTztRQUNkVixRQUFRVSxLQUFLLENBQUMsd0NBQXdDQTtRQUN0RCxNQUFNLElBQUlDLE1BQU07SUFDbEI7QUFDRixFQUFFO0FBRUYsd0NBQXdDO0FBQ2pDLE1BQU1NLHdCQUF3QixPQUFPeEM7SUFDMUMsSUFBSTtRQUNGLCtEQUErRDtRQUMvRCxJQUNFa0Isa0JBQ0E5QixhQUFhRyxVQUFVLENBQUNTLFNBQVMsSUFDakNaLGFBQWFHLFVBQVUsQ0FBQ1MsU0FBUyxDQUFDeUIsTUFBTSxHQUFHLEdBQzNDO1lBQ0FGLFFBQVFDLEdBQUcsQ0FBQyxhQUFzQixPQUFUeEIsVUFBUztZQUNsQyxPQUFPWixhQUFhRyxVQUFVLENBQUNTLFNBQVM7UUFDMUM7UUFFQXVCLFFBQVFDLEdBQUcsQ0FBQyxZQUFxQixPQUFUeEIsVUFBUztRQUNqQyxNQUFNeUMsSUFBSW5FLHlEQUFLQSxDQUFDWSxvQkFBb0JYLHlEQUFLQSxDQUFDLFlBQVksTUFBTXlCO1FBQzVELE1BQU0yQixXQUFXLE1BQU0xRCwyREFBT0EsQ0FBQ3dFO1FBQy9CLE1BQU1aLFdBQVdGLFNBQVNDLElBQUksQ0FBQ2pCLEdBQUcsQ0FBQ3pDLENBQUFBLE1BQVE7Z0JBQ3pDNkQsSUFBSTdELElBQUk2RCxFQUFFO2dCQUNWLEdBQUc3RCxJQUFJNEQsSUFBSSxFQUFFO1lBQ2Y7UUFFQSxlQUFlO1FBQ2YxQyxhQUFhRyxVQUFVLENBQUNTLFNBQVMsR0FBRzZCO1FBRXBDLHlCQUF5QjtRQUN6QkEsU0FBU3ZCLE9BQU8sQ0FBQ1gsQ0FBQUE7WUFDZlAsYUFBYUUsSUFBSSxDQUFDSyxRQUFRb0MsRUFBRSxDQUFDLEdBQUdwQztRQUNsQztRQUVBLE9BQU9rQztJQUNULEVBQUUsT0FBT0ksT0FBTztRQUNkVixRQUFRVSxLQUFLLENBQUMsaUJBQTBCLE9BQVRqQyxVQUFTLGVBQWFpQztRQUNyRCxNQUFNLElBQUlDLE1BQU0sbUJBQTRCLE9BQVRsQyxVQUFTO0lBQzlDO0FBQ0YsRUFBRTtBQUVGLHFDQUFxQztBQUM5QixNQUFNMEMsc0JBQXNCO1FBQU9DLDhFQUFxQjtJQUM3RCxJQUFJO1FBQ0YsOENBQThDO1FBQzlDLElBQUl6QixrQkFBa0I5QixhQUFhQyxHQUFHLEVBQUU7WUFDdEMsTUFBTXVELFdBQVd4RCxhQUFhQyxHQUFHLENBQUN5QixNQUFNLENBQUN5QixDQUFBQSxJQUFLQSxFQUFFSyxRQUFRLEVBQUVDLEtBQUssQ0FBQyxHQUFHRjtZQUNuRSxJQUFJQyxTQUFTbkIsTUFBTSxHQUFHLEdBQUc7Z0JBQ3ZCRixRQUFRQyxHQUFHLENBQUM7Z0JBQ1osT0FBT29CO1lBQ1Q7UUFDRjtRQUVBckIsUUFBUUMsR0FBRyxDQUFDO1FBQ1osTUFBTWlCLElBQUluRSx5REFBS0EsQ0FDYlksb0JBQ0FYLHlEQUFLQSxDQUFDLFlBQVksTUFBTSxPQUN4QkksMkRBQU9BLENBQUMsYUFBYSxTQUNyQkQseURBQUtBLENBQUNpRTtRQUdSLE1BQU1oQixXQUFXLE1BQU0xRCwyREFBT0EsQ0FBQ3dFO1FBQy9CLE1BQU1aLFdBQVdGLFNBQVNDLElBQUksQ0FBQ2pCLEdBQUcsQ0FBQ3pDLENBQUFBLE1BQVE7Z0JBQ3pDNkQsSUFBSTdELElBQUk2RCxFQUFFO2dCQUNWLEdBQUc3RCxJQUFJNEQsSUFBSSxFQUFFO1lBQ2Y7UUFFQSxvQkFBb0I7UUFDcEJELFNBQVN2QixPQUFPLENBQUNYLENBQUFBO1lBQ2ZQLGFBQWFFLElBQUksQ0FBQ0ssUUFBUW9DLEVBQUUsQ0FBQyxHQUFHcEM7WUFFaEMsa0NBQWtDO1lBQ2xDLElBQUlBLFFBQVFLLFFBQVEsRUFBRTtnQkFDcEIsSUFBSSxDQUFDWixhQUFhRyxVQUFVLENBQUNJLFFBQVFLLFFBQVEsQ0FBQyxFQUFFO29CQUM5Q1osYUFBYUcsVUFBVSxDQUFDSSxRQUFRSyxRQUFRLENBQUMsR0FBRyxFQUFFO2dCQUNoRDtnQkFFQSxvREFBb0Q7Z0JBQ3BELE1BQU1xQyxnQkFBZ0JqRCxhQUFhRyxVQUFVLENBQUNJLFFBQVFLLFFBQVEsQ0FBQyxDQUFDc0MsU0FBUyxDQUN2RUMsQ0FBQUEsSUFBS0EsRUFBRVIsRUFBRSxLQUFLcEMsUUFBUW9DLEVBQUU7Z0JBRzFCLElBQUlNLGlCQUFpQixHQUFHO29CQUN0QmpELGFBQWFHLFVBQVUsQ0FBQ0ksUUFBUUssUUFBUSxDQUFDLENBQUNxQyxjQUFjLEdBQUcxQztnQkFDN0QsT0FBTztvQkFDTFAsYUFBYUcsVUFBVSxDQUFDSSxRQUFRSyxRQUFRLENBQUMsQ0FBQ2dDLElBQUksQ0FBQ3JDO2dCQUNqRDtZQUNGO1FBQ0Y7UUFFQSxPQUFPa0M7SUFDVCxFQUFFLE9BQU9JLE9BQU87UUFDZFYsUUFBUVUsS0FBSyxDQUFDLG9DQUFvQ0E7UUFDbEQsTUFBTSxJQUFJQyxNQUFNO0lBQ2xCO0FBQ0YsRUFBRTtBQUVGLGdDQUFnQztBQUN6QixNQUFNWSxpQkFBaUI7UUFBT0gsOEVBQXFCO0lBQ3hELElBQUk7UUFDRiw4Q0FBOEM7UUFDOUMsSUFBSXpCLGtCQUFrQjlCLGFBQWFDLEdBQUcsRUFBRTtZQUN0QyxNQUFNMEQsY0FBYzNELGFBQWFDLEdBQUcsQ0FDakN5QixNQUFNLENBQUN5QixDQUFBQSxJQUFLQSxFQUFFUyxHQUFHLEVBQ2pCSCxLQUFLLENBQUMsR0FBR0Y7WUFFWixJQUFJSSxZQUFZdEIsTUFBTSxHQUFHLEdBQUc7Z0JBQzFCRixRQUFRQyxHQUFHLENBQUM7Z0JBQ1osT0FBT3VCO1lBQ1Q7UUFDRjtRQUVBeEIsUUFBUUMsR0FBRyxDQUFDO1FBQ1osTUFBTWlCLElBQUluRSx5REFBS0EsQ0FDYlksb0JBQ0FYLHlEQUFLQSxDQUFDLE9BQU8sTUFBTSxPQUNuQkksMkRBQU9BLENBQUMsYUFBYSxTQUNyQkQseURBQUtBLENBQUNpRTtRQUdSLE1BQU1oQixXQUFXLE1BQU0xRCwyREFBT0EsQ0FBQ3dFO1FBQy9CLE1BQU1aLFdBQVdGLFNBQVNDLElBQUksQ0FBQ2pCLEdBQUcsQ0FBQ3pDLENBQUFBLE1BQVE7Z0JBQ3pDNkQsSUFBSTdELElBQUk2RCxFQUFFO2dCQUNWLEdBQUc3RCxJQUFJNEQsSUFBSSxFQUFFO1lBQ2Y7UUFFQSxvQkFBb0I7UUFDcEJELFNBQVN2QixPQUFPLENBQUNYLENBQUFBO1lBQ2ZQLGFBQWFFLElBQUksQ0FBQ0ssUUFBUW9DLEVBQUUsQ0FBQyxHQUFHcEM7WUFFaEMsa0NBQWtDO1lBQ2xDLElBQUlBLFFBQVFLLFFBQVEsRUFBRTtnQkFDcEIsSUFBSSxDQUFDWixhQUFhRyxVQUFVLENBQUNJLFFBQVFLLFFBQVEsQ0FBQyxFQUFFO29CQUM5Q1osYUFBYUcsVUFBVSxDQUFDSSxRQUFRSyxRQUFRLENBQUMsR0FBRyxFQUFFO2dCQUNoRDtnQkFFQSxvREFBb0Q7Z0JBQ3BELE1BQU1xQyxnQkFBZ0JqRCxhQUFhRyxVQUFVLENBQUNJLFFBQVFLLFFBQVEsQ0FBQyxDQUFDc0MsU0FBUyxDQUN2RUMsQ0FBQUEsSUFBS0EsRUFBRVIsRUFBRSxLQUFLcEMsUUFBUW9DLEVBQUU7Z0JBRzFCLElBQUlNLGlCQUFpQixHQUFHO29CQUN0QmpELGFBQWFHLFVBQVUsQ0FBQ0ksUUFBUUssUUFBUSxDQUFDLENBQUNxQyxjQUFjLEdBQUcxQztnQkFDN0QsT0FBTztvQkFDTFAsYUFBYUcsVUFBVSxDQUFDSSxRQUFRSyxRQUFRLENBQUMsQ0FBQ2dDLElBQUksQ0FBQ3JDO2dCQUNqRDtZQUNGO1FBQ0Y7UUFFQSxPQUFPa0M7SUFDVCxFQUFFLE9BQU9JLE9BQU87UUFDZFYsUUFBUVUsS0FBSyxDQUFDLCtCQUErQkE7UUFDN0MsTUFBTSxJQUFJQyxNQUFNO0lBQ2xCO0FBQ0YsRUFBRTtBQUVGLGlDQUFpQztBQUMxQixNQUFNZSxpQkFBaUIsT0FBT2xCO0lBQ25DLElBQUk7UUFDRiwrQkFBK0I7UUFDL0IsSUFBSTNDLGFBQWFFLElBQUksQ0FBQ3lDLEdBQUcsRUFBRTtZQUN6QlIsUUFBUUMsR0FBRyxDQUFDLHFCQUF3QixPQUFITyxJQUFHO1lBQ3BDLE9BQU8zQyxhQUFhRSxJQUFJLENBQUN5QyxHQUFHO1FBQzlCO1FBRUFSLFFBQVFDLEdBQUcsQ0FBQyxvQkFBdUIsT0FBSE8sSUFBRztRQUNuQyxNQUFNbUIsYUFBYWhGLHVEQUFHQSxDQUFDYyxJQUFJLFlBQVkrQztRQUN2QyxNQUFNSixXQUFXLE1BQU14RCwwREFBTUEsQ0FBQytFO1FBRTlCLElBQUl2QixTQUFTd0IsTUFBTSxJQUFJO1lBQ3JCLE1BQU14RCxVQUFVO2dCQUNkb0MsSUFBSUosU0FBU0ksRUFBRTtnQkFDZixHQUFHSixTQUFTRyxJQUFJLEVBQUU7WUFDcEI7WUFFQSxlQUFlO1lBQ2YxQyxhQUFhRSxJQUFJLENBQUN5QyxHQUFHLEdBQUdwQztZQUV4QixPQUFPQTtRQUNUO1FBQ0EsT0FBTztJQUNULEVBQUUsT0FBT3NDLE9BQU87UUFDZFYsUUFBUVUsS0FBSyxDQUFDLDBCQUEwQkE7UUFDeEMsTUFBTSxJQUFJQyxNQUFNO0lBQ2xCO0FBQ0YsRUFBRTtBQUVGLHFDQUFxQztBQUNyQyxNQUFNa0IseUJBQXlCLENBQUNDLFdBQW1CQztJQUNqRCx5QkFBeUI7SUFDekIsSUFBSWxFLGFBQWFFLElBQUksQ0FBQytELFVBQVUsRUFBRTtRQUNoQyxPQUFPakUsYUFBYUUsSUFBSSxDQUFDK0QsVUFBVTtJQUNyQztJQUVBLHFEQUFxRDtJQUNyRCxJQUFJQyxjQUFjbEUsYUFBYUcsVUFBVSxDQUFDK0QsV0FBVyxFQUFFO1FBQ3JEbEUsYUFBYUcsVUFBVSxDQUFDK0QsV0FBVyxHQUFHbEUsYUFBYUcsVUFBVSxDQUFDK0QsV0FBVyxDQUFDeEMsTUFBTSxDQUM5RXlCLENBQUFBLElBQUtBLEVBQUVSLEVBQUUsS0FBS3NCO0lBRWxCO0lBRUEsdURBQXVEO0lBQ3ZEakUsYUFBYUMsR0FBRyxHQUFHO0FBQ3JCO0FBRUEscUJBQXFCO0FBQ2QsTUFBTWtFLG9CQUFvQjtJQUMvQm5FLGFBQWFDLEdBQUcsR0FBRztJQUNuQkQsYUFBYUUsSUFBSSxHQUFHLENBQUM7SUFDckJGLGFBQWFHLFVBQVUsR0FBRyxDQUFDO0lBQzNCSCxhQUFhSSxXQUFXLEdBQUc7QUFDN0IsRUFBRTtBQUVGLDBDQUEwQztBQUMxQyxNQUFNZ0UscUJBQXFCO0lBQ3pCLE1BQU12RSxVQUFVLEtBQWtCLEdBQWNKLDREQUFVQSxDQUFDZiwwQ0FBR0EsSUFBSSxDQUFJO0lBQ3RFLElBQUltQixZQUFZLE1BQU07UUFDcEIsT0FBT0osNERBQVVBLENBQUNmLDBDQUFHQTtJQUN2QjtJQUNBLE9BQU9tQjtBQUNUO0FBRUEsbUNBQW1DO0FBQzVCLE1BQU13RSxxQkFBcUIsT0FBT0M7SUFDdkMsSUFBSTtRQUNGLGlDQUFpQztRQUNqQyxJQUFJQSxLQUFLQyxJQUFJLEdBQUcsSUFBSSxPQUFPLE1BQU07WUFDL0IsTUFBTSxJQUFJekIsTUFBTTtRQUNsQjtRQUVBLHlCQUF5QjtRQUN6QixNQUFNMEIsZUFBZSxNQUFNQyxhQUFhSDtRQUV4QyxtQ0FBbUM7UUFDbkMsTUFBTUksWUFBWSxJQUFJM0MsT0FBTzRDLE9BQU87UUFDcEMsTUFBTUMsV0FBVyxXQUF3Qk4sT0FBYkksV0FBVSxLQUE0QyxPQUF6Q0osS0FBSzlELElBQUksQ0FBQ3FFLE9BQU8sQ0FBQyxrQkFBa0I7UUFFN0Usc0NBQXNDO1FBQ3RDLE1BQU1DLGtCQUFrQmxHLDhEQUFVQSxDQUFDZ0IsSUFBSTtRQUN2QyxNQUFNbUYsV0FBVyxNQUFNL0YsMERBQU1BLENBQUM4RixpQkFBaUI7WUFDN0N0RSxNQUFNb0U7WUFDTkksTUFBTVYsS0FBS1UsSUFBSTtZQUNmQyxRQUFRVDtZQUNSNUMsV0FBV3ZDLG1FQUFlQTtRQUM1QjtRQUVBLDBDQUEwQztRQUMxQyxPQUFPLFlBQXdCLE9BQVowRixTQUFTcEMsRUFBRTtJQUNoQyxFQUFFLE9BQU9FLE9BQU87UUFDZFYsUUFBUVUsS0FBSyxDQUFDLDBCQUEwQkE7UUFDeEMsSUFBSUEsaUJBQWlCQyxPQUFPO1lBQzFCLE1BQU1EO1FBQ1IsT0FBTztZQUNMLE1BQU0sSUFBSUMsTUFBTTtRQUNsQjtJQUNGO0FBQ0YsRUFBRTtBQUVGLDRDQUE0QztBQUM1QyxNQUFNMkIsZUFBZSxDQUFDSDtJQUNwQixPQUFPLElBQUlZLFFBQVEsQ0FBQ0MsU0FBU0M7UUFDM0IsSUFBSTtZQUNGLE1BQU1DLFNBQVMsSUFBSUM7WUFDbkJELE9BQU9FLGFBQWEsQ0FBQ2pCO1lBQ3JCZSxPQUFPRyxNQUFNLEdBQUc7Z0JBQ2QsSUFBSSxPQUFPSCxPQUFPSSxNQUFNLEtBQUssVUFBVTtvQkFDckNOLFFBQVFFLE9BQU9JLE1BQU07Z0JBQ3ZCLE9BQU87b0JBQ0xMLE9BQU8sSUFBSXRDLE1BQU07Z0JBQ25CO1lBQ0Y7WUFDQXVDLE9BQU9LLE9BQU8sR0FBRztnQkFDZk4sT0FBTyxJQUFJdEMsTUFBTTtZQUNuQjtRQUNGLEVBQUUsT0FBT0QsT0FBTztZQUNkdUMsT0FBT3ZDLGlCQUFpQkMsUUFBUUQsUUFBUSxJQUFJQyxNQUFNO1FBQ3BEO0lBQ0Y7QUFDRjtBQUVBLGtCQUFrQjtBQUNYLE1BQU02QyxlQUFlLE9BQU9DO0lBQ2pDLElBQUk7UUFDRnpELFFBQVFDLEdBQUcsQ0FBQywyQkFBbUMsT0FBUndEO1FBQ3ZDLE1BQU1iLFdBQVdqRyx1REFBR0EsQ0FBQ2MsSUFBSSxVQUFVZ0c7UUFDbkMsTUFBTXJELFdBQVcsTUFBTXhELDBEQUFNQSxDQUFDZ0c7UUFFOUIsSUFBSXhDLFNBQVN3QixNQUFNLElBQUk7WUFDckIsTUFBTXJCLE9BQU9ILFNBQVNHLElBQUk7WUFFMUIsSUFBSSxDQUFDQSxRQUFRLENBQUNBLEtBQUt1QyxNQUFNLEVBQUU7Z0JBQ3pCOUMsUUFBUVUsS0FBSyxDQUFDLDRDQUFvRCxPQUFSK0M7Z0JBQzFELE9BQU87WUFDVDtZQUVBekQsUUFBUUMsR0FBRyxDQUFDLDRDQUFvRCxPQUFSd0Q7WUFDeEQsT0FBT2xELEtBQUt1QyxNQUFNO1FBQ3BCO1FBRUE5QyxRQUFRVSxLQUFLLENBQUMsNEJBQW9DLE9BQVIrQztRQUMxQyxPQUFPO0lBQ1QsRUFBRSxPQUFPL0MsT0FBTztRQUNkVixRQUFRVSxLQUFLLENBQUMsd0JBQXdCQTtRQUN0QyxtRUFBbUU7UUFDbkUsT0FBTztJQUNUO0FBQ0YsRUFBRTtBQUVGLHNDQUFzQztBQUMvQixNQUFNZ0QscUJBQXFCLE9BQU9DO0lBQ3ZDLElBQUk7UUFDRiwrQkFBK0I7UUFDL0IsSUFBSUEsU0FBU0MsVUFBVSxDQUFDLGNBQWM7WUFDcEMsTUFBTUgsVUFBVUUsU0FBU2pCLE9BQU8sQ0FBQyxhQUFhO1lBQzlDLE1BQU1FLFdBQVdqRyx1REFBR0EsQ0FBQ2MsSUFBSSxVQUFVZ0c7WUFDbkMsTUFBTTNHLDZEQUFTQSxDQUFDOEY7WUFDaEI1QyxRQUFRQyxHQUFHLENBQUMsc0RBQXNEd0Q7WUFDbEU7UUFDRjtRQUVBLDZCQUE2QjtRQUM3QixNQUFNL0YsVUFBVXVFO1FBRWhCLHFDQUFxQztRQUNyQyxNQUFNNEIsYUFBYUMsbUJBQW1CSDtRQUN0QyxNQUFNSSxhQUFhRixXQUFXRyxPQUFPLENBQUM7UUFFdEMsSUFBSUQsZUFBZSxDQUFDLEdBQUc7WUFDckIvRCxRQUFRaUUsSUFBSSxDQUFDLCtEQUErRE47WUFDNUU7UUFDRjtRQUVBLE1BQU1PLFdBQVdMLFdBQVdHLE9BQU8sQ0FBQyxLQUFLRDtRQUN6QyxNQUFNSSxXQUFXRCxhQUFhLENBQUMsSUFDM0JMLFdBQVdPLFNBQVMsQ0FBQ0wsWUFBWUcsWUFDakNMLFdBQVdPLFNBQVMsQ0FBQ0w7UUFFekIsaUNBQWlDO1FBQ2pDLE1BQU1NLFdBQVc5RyxxREFBR0EsQ0FBQ0csU0FBU3lHO1FBRTlCLGtCQUFrQjtRQUNsQixNQUFNM0csOERBQVlBLENBQUM2RztRQUNuQnJFLFFBQVFDLEdBQUcsQ0FBQyxvREFBb0RrRTtJQUNsRSxFQUFFLE9BQU96RCxPQUFPO1FBQ2RWLFFBQVFVLEtBQUssQ0FBQyxpQ0FBaUNBO0lBQy9DLHVFQUF1RTtJQUN2RSwrQkFBK0I7SUFDakM7QUFDRixFQUFFO0FBRUYsMkRBQTJEO0FBQ3BELE1BQU00RCxhQUFhLE9BQU9sRztJQUMvQixJQUFJO1FBQ0Y0QixRQUFRQyxHQUFHLENBQUMsZ0NBQWdDN0I7UUFFNUMsd0JBQXdCO1FBQ3hCLE1BQU1tRyxrQkFBa0JwRyxnQkFBZ0JDO1FBQ3hDLElBQUltRyxpQkFBaUI7WUFDbkIsTUFBTSxJQUFJNUQsTUFBTTREO1FBQ2xCO1FBRUEsdUNBQXVDO1FBQ3ZDLE1BQU0zRixpQkFBaUJELGlCQUFpQlA7UUFDeEM0QixRQUFRQyxHQUFHLENBQUMsdUNBQXVDckI7UUFFbkQsMERBQTBEO1FBQzFELE1BQU00RixhQUFhLE1BQU12SCxrRUFBY0EsQ0FBQ1EsSUFBSSxPQUFPZ0g7WUFDakQsMkJBQTJCO1lBQzNCLE1BQU1DLFNBQVMsTUFBTTdILDBEQUFNQSxDQUFDYyxvQkFBb0JpQjtZQUNoRCxNQUFNK0YsbUJBQW1CO2dCQUN2Qm5FLElBQUlrRSxPQUFPbEUsRUFBRTtnQkFDYixHQUFHNUIsY0FBYztZQUNuQjtZQUVBLGtDQUFrQztZQUNsQyxNQUFNZ0csY0FBY2pJLHVEQUFHQSxDQUFDaUIsc0JBQXNCZ0IsZUFBZUgsUUFBUTtZQUNyRSxNQUFNb0csY0FBYyxNQUFNSixZQUFZSyxHQUFHLENBQUNGO1lBRTFDLElBQUlDLFlBQVlqRCxNQUFNLElBQUk7Z0JBQ3hCLDJCQUEyQjtnQkFDM0I2QyxZQUFZTSxNQUFNLENBQUNILGFBQWE7b0JBQzlCSSxPQUFPLENBQUNILFlBQVl0RSxJQUFJLEdBQUd5RSxLQUFLLElBQUksS0FBSztvQkFDekN0RixXQUFXeEMsbUVBQWVBO2dCQUM1QjtZQUNGLE9BQU87Z0JBQ0wsc0JBQXNCO2dCQUN0QnVILFlBQVlRLEdBQUcsQ0FBQ0wsYUFBYTtvQkFDM0JwRSxJQUFJNUIsZUFBZUgsUUFBUTtvQkFDM0JKLE1BQU1PLGVBQWVILFFBQVEsQ0FBQ3lHLE1BQU0sQ0FBQyxHQUFHQyxXQUFXLEtBQUt2RyxlQUFlSCxRQUFRLENBQUM2QyxLQUFLLENBQUM7b0JBQ3RGMEQsT0FBTztvQkFDUHZGLFdBQVd2QyxtRUFBZUE7b0JBQzFCd0MsV0FBV3hDLG1FQUFlQTtnQkFDNUI7WUFDRjtZQUVBLE9BQU95SDtRQUNUO1FBRUEsb0NBQW9DO1FBQ3BDLElBQUk5RyxhQUFhQyxHQUFHLEVBQUU7WUFDcEJELGFBQWFDLEdBQUcsQ0FBQ3NILE9BQU8sQ0FBQ1o7UUFDM0I7UUFFQTNHLGFBQWFFLElBQUksQ0FBQ3lHLFdBQVdoRSxFQUFFLENBQUMsR0FBR2dFO1FBRW5DLElBQUlBLFdBQVcvRixRQUFRLEVBQUU7WUFDdkIsSUFBSSxDQUFDWixhQUFhRyxVQUFVLENBQUN3RyxXQUFXL0YsUUFBUSxDQUFDLEVBQUU7Z0JBQ2pEWixhQUFhRyxVQUFVLENBQUN3RyxXQUFXL0YsUUFBUSxDQUFDLEdBQUcsRUFBRTtZQUNuRDtZQUNBWixhQUFhRyxVQUFVLENBQUN3RyxXQUFXL0YsUUFBUSxDQUFDLENBQUMyRyxPQUFPLENBQUNaO1FBQ3ZEO1FBRUF4RSxRQUFRQyxHQUFHLENBQUMsdUNBQXVDdUUsV0FBV2hFLEVBQUU7UUFDaEUsT0FBT2dFO0lBQ1QsRUFBRSxPQUFPOUQsT0FBTztRQUNkVixRQUFRVSxLQUFLLENBQUMsc0NBQXNDQTtRQUNwRCxNQUFNQTtJQUNSO0FBQ0YsRUFBRTtBQUVGLG1CQUFtQjtBQUNaLE1BQU0yRSxnQkFBZ0IsT0FBTzdFLElBQVlwQztJQUM5QyxJQUFJO1FBQ0YsTUFBTXVELGFBQWFoRix1REFBR0EsQ0FBQ2MsSUFBSSxZQUFZK0M7UUFFdkMsd0RBQXdEO1FBQ3hELE1BQU04RSxzQkFBc0IsTUFBTTFJLDBEQUFNQSxDQUFDK0U7UUFDekMsSUFBSSxDQUFDMkQsb0JBQW9CMUQsTUFBTSxJQUFJO1lBQ2pDLE1BQU0sSUFBSWpCLE1BQU07UUFDbEI7UUFFQSxNQUFNNEUsa0JBQWtCRCxvQkFBb0IvRSxJQUFJO1FBQ2hELE1BQU1pRixpQkFBaUI3RyxpQkFBaUJQO1FBRXhDLDRDQUE0QztRQUM1Q29ILGVBQWU5RixTQUFTLEdBQUd4QyxtRUFBZUE7UUFFMUMsTUFBTUQsa0VBQWNBLENBQUNRLElBQUksT0FBT2dIO1lBQzlCLDBCQUEwQjtZQUMxQkEsWUFBWU0sTUFBTSxDQUFDcEQsWUFBWTZEO1lBRS9CLCtEQUErRDtZQUMvRCxJQUFJcEgsUUFBUUssUUFBUSxJQUFJOEcsZ0JBQWdCOUcsUUFBUSxLQUFLTCxRQUFRSyxRQUFRLEVBQUU7Z0JBQ3JFLDhCQUE4QjtnQkFDOUIsTUFBTWdILGlCQUFpQjlJLHVEQUFHQSxDQUFDaUIsc0JBQXNCMkgsZ0JBQWdCOUcsUUFBUTtnQkFDekUsTUFBTWlILGlCQUFpQixNQUFNakIsWUFBWUssR0FBRyxDQUFDVztnQkFFN0MsSUFBSUMsZUFBZTlELE1BQU0sSUFBSTtvQkFDM0IsTUFBTStELFdBQVdELGVBQWVuRixJQUFJLEdBQUd5RSxLQUFLLElBQUk7b0JBQ2hELElBQUlXLFdBQVcsR0FBRzt3QkFDaEJsQixZQUFZTSxNQUFNLENBQUNVLGdCQUFnQjs0QkFDakNULE9BQU9XLFdBQVc7NEJBQ2xCakcsV0FBV3hDLG1FQUFlQTt3QkFDNUI7b0JBQ0YsT0FBTzt3QkFDTCxzQ0FBc0M7d0JBQ3RDdUgsWUFBWW1CLE1BQU0sQ0FBQ0g7b0JBQ3JCO2dCQUNGO2dCQUVBLDhCQUE4QjtnQkFDOUIsTUFBTUksaUJBQWlCbEosdURBQUdBLENBQUNpQixzQkFBc0JRLFFBQVFLLFFBQVE7Z0JBQ2pFLE1BQU1xSCxpQkFBaUIsTUFBTXJCLFlBQVlLLEdBQUcsQ0FBQ2U7Z0JBRTdDLElBQUlDLGVBQWVsRSxNQUFNLElBQUk7b0JBQzNCNkMsWUFBWU0sTUFBTSxDQUFDYyxnQkFBZ0I7d0JBQ2pDYixPQUFPLENBQUNjLGVBQWV2RixJQUFJLEdBQUd5RSxLQUFLLElBQUksS0FBSzt3QkFDNUN0RixXQUFXeEMsbUVBQWVBO29CQUM1QjtnQkFDRixPQUFPO29CQUNMdUgsWUFBWVEsR0FBRyxDQUFDWSxnQkFBZ0I7d0JBQzlCckYsSUFBSXBDLFFBQVFLLFFBQVE7d0JBQ3BCSixNQUFNRCxRQUFRSyxRQUFRLENBQUN5RyxNQUFNLENBQUMsR0FBR0MsV0FBVyxLQUFLL0csUUFBUUssUUFBUSxDQUFDNkMsS0FBSyxDQUFDO3dCQUN4RTBELE9BQU87d0JBQ1B2RixXQUFXdkMsbUVBQWVBO3dCQUMxQndDLFdBQVd4QyxtRUFBZUE7b0JBQzVCO2dCQUNGO1lBQ0Y7UUFDRjtRQUVBLGVBQWU7UUFDZixJQUFJVyxhQUFhRSxJQUFJLENBQUN5QyxHQUFHLEVBQUU7WUFDekIsTUFBTXVGLGlCQUFpQjtnQkFBRSxHQUFHbEksYUFBYUUsSUFBSSxDQUFDeUMsR0FBRztnQkFBRSxHQUFHcEMsT0FBTztZQUFDO1lBQzlEUCxhQUFhRSxJQUFJLENBQUN5QyxHQUFHLEdBQUd1RjtZQUV4Qiw0Q0FBNEM7WUFDNUMsSUFBSWxJLGFBQWFDLEdBQUcsRUFBRTtnQkFDcEIsTUFBTWtJLFFBQVFuSSxhQUFhQyxHQUFHLENBQUNpRCxTQUFTLENBQUNDLENBQUFBLElBQUtBLEVBQUVSLEVBQUUsS0FBS0E7Z0JBQ3ZELElBQUl3RixTQUFTLEdBQUc7b0JBQ2RuSSxhQUFhQyxHQUFHLENBQUNrSSxNQUFNLEdBQUdEO2dCQUM1QjtZQUNGO1lBRUEsa0NBQWtDO1lBQ2xDLElBQUkzSCxRQUFRSyxRQUFRLElBQUk4RyxnQkFBZ0I5RyxRQUFRLEtBQUtMLFFBQVFLLFFBQVEsRUFBRTtnQkFDckUsaUNBQWlDO2dCQUNqQyxJQUFJWixhQUFhRyxVQUFVLENBQUN1SCxnQkFBZ0I5RyxRQUFRLENBQUMsRUFBRTtvQkFDckRaLGFBQWFHLFVBQVUsQ0FBQ3VILGdCQUFnQjlHLFFBQVEsQ0FBQyxHQUFHWixhQUFhRyxVQUFVLENBQUN1SCxnQkFBZ0I5RyxRQUFRLENBQUMsQ0FBQ2MsTUFBTSxDQUMxR3lCLENBQUFBLElBQUtBLEVBQUVSLEVBQUUsS0FBS0E7Z0JBRWxCO2dCQUVBLDRCQUE0QjtnQkFDNUIsSUFBSSxDQUFDM0MsYUFBYUcsVUFBVSxDQUFDSSxRQUFRSyxRQUFRLENBQUMsRUFBRTtvQkFDOUNaLGFBQWFHLFVBQVUsQ0FBQ0ksUUFBUUssUUFBUSxDQUFDLEdBQUcsRUFBRTtnQkFDaEQ7Z0JBQ0FaLGFBQWFHLFVBQVUsQ0FBQ0ksUUFBUUssUUFBUSxDQUFDLENBQUNnQyxJQUFJLENBQUNzRjtZQUNqRCxPQUFPLElBQUkzSCxRQUFRSyxRQUFRLEVBQUU7Z0JBQzNCLDBCQUEwQjtnQkFDMUIsSUFBSVosYUFBYUcsVUFBVSxDQUFDSSxRQUFRSyxRQUFRLENBQUMsRUFBRTtvQkFDN0MsTUFBTXdILFdBQVdwSSxhQUFhRyxVQUFVLENBQUNJLFFBQVFLLFFBQVEsQ0FBQyxDQUFDc0MsU0FBUyxDQUFDQyxDQUFBQSxJQUFLQSxFQUFFUixFQUFFLEtBQUtBO29CQUNuRixJQUFJeUYsWUFBWSxHQUFHO3dCQUNqQnBJLGFBQWFHLFVBQVUsQ0FBQ0ksUUFBUUssUUFBUSxDQUFDLENBQUN3SCxTQUFTLEdBQUdGO29CQUN4RDtnQkFDRjtZQUNGO1FBQ0YsT0FBTztZQUNMLHlEQUF5RDtZQUN6RC9EO1FBQ0Y7SUFFRixFQUFFLE9BQU90QixPQUFPO1FBQ2RWLFFBQVFVLEtBQUssQ0FBQywyQkFBMkJBO1FBQ3pDLE1BQU0sSUFBSUMsTUFBTTtJQUNsQjtBQUNGLEVBQUU7QUFFRixtQkFBbUI7QUFDWixNQUFNdUYsZ0JBQWdCLE9BQU8xRjtJQUNsQyxJQUFJO1FBQ0YsTUFBTW1CLGFBQWFoRix1REFBR0EsQ0FBQ2MsSUFBSSxZQUFZK0M7UUFFdkMsaURBQWlEO1FBQ2pELE1BQU0yRixjQUFjLE1BQU12SiwwREFBTUEsQ0FBQytFO1FBQ2pDLElBQUksQ0FBQ3dFLFlBQVl2RSxNQUFNLElBQUk7WUFDekIsTUFBTSxJQUFJakIsTUFBTTtRQUNsQjtRQUVBLE1BQU15RixjQUFjRCxZQUFZNUYsSUFBSTtRQUVwQyx3Q0FBd0M7UUFDeEMsSUFBSTZGLFlBQVkxSCxLQUFLLEVBQUU7WUFDckIsSUFBSTtnQkFDRixNQUFNZ0YsbUJBQW1CMEMsWUFBWTFILEtBQUs7WUFDNUMsRUFBRSxPQUFPZ0MsT0FBTztnQkFDZFYsUUFBUVUsS0FBSyxDQUFDLGlDQUFpQ0E7WUFDL0MsOERBQThEO1lBQ2hFO1FBQ0Y7UUFFQSxNQUFNekQsa0VBQWNBLENBQUNRLElBQUksT0FBT2dIO1lBQzlCLGlCQUFpQjtZQUNqQkEsWUFBWW1CLE1BQU0sQ0FBQ2pFO1lBRW5CLHdCQUF3QjtZQUN4QixJQUFJeUUsWUFBWTNILFFBQVEsRUFBRTtnQkFDeEIsTUFBTW1HLGNBQWNqSSx1REFBR0EsQ0FBQ2lCLHNCQUFzQndJLFlBQVkzSCxRQUFRO2dCQUNsRSxNQUFNb0csY0FBYyxNQUFNSixZQUFZSyxHQUFHLENBQUNGO2dCQUUxQyxJQUFJQyxZQUFZakQsTUFBTSxJQUFJO29CQUN4QixNQUFNb0QsUUFBUUgsWUFBWXRFLElBQUksR0FBR3lFLEtBQUssSUFBSTtvQkFDMUMsSUFBSUEsUUFBUSxHQUFHO3dCQUNiUCxZQUFZTSxNQUFNLENBQUNILGFBQWE7NEJBQzlCSSxPQUFPQSxRQUFROzRCQUNmdEYsV0FBV3hDLG1FQUFlQTt3QkFDNUI7b0JBQ0YsT0FBTzt3QkFDTCxzQ0FBc0M7d0JBQ3RDdUgsWUFBWW1CLE1BQU0sQ0FBQ2hCO29CQUNyQjtnQkFDRjtZQUNGO1FBQ0Y7UUFFQSxlQUFlO1FBQ2YvQyx1QkFBdUJyQixJQUFJNEYsWUFBWTNILFFBQVE7SUFFakQsRUFBRSxPQUFPaUMsT0FBTztRQUNkVixRQUFRVSxLQUFLLENBQUMsMkJBQTJCQTtRQUN6QyxNQUFNLElBQUlDLE1BQU07SUFDbEI7QUFDRixFQUFFO0FBRUYseUNBQXlDO0FBQ2xDLE1BQU0wRixtQkFBbUI7SUFDOUIsSUFBSTtRQUNGLE1BQU1qRyxXQUFXLE1BQU0xRCwyREFBT0EsQ0FBQ2tCO1FBQy9CLE9BQU93QyxTQUFTQyxJQUFJLENBQUNqQixHQUFHLENBQUN6QyxDQUFBQSxNQUFPQSxJQUFJNEQsSUFBSTtJQUMxQyxFQUFFLE9BQU9HLE9BQU87UUFDZFYsUUFBUVUsS0FBSyxDQUFDLDZCQUE2QkE7UUFDM0MsTUFBTSxJQUFJQyxNQUFNO0lBQ2xCO0FBQ0YsRUFBRSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi91dGlscy9maXJlc3RvcmUudHM/YWEwMCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBhcHAgfSBmcm9tICcuL2ZpcmViYXNlJztcbmltcG9ydCB7IGdldEZpcmVzdG9yZSwgY29sbGVjdGlvbiwgZ2V0RG9jcywgZG9jLCBnZXREb2MsIGFkZERvYywgdXBkYXRlRG9jLCBkZWxldGVEb2MsIHF1ZXJ5LCB3aGVyZSwgcnVuVHJhbnNhY3Rpb24sIHNlcnZlclRpbWVzdGFtcCwgRG9jdW1lbnRSZWZlcmVuY2UsIGxpbWl0LCBvcmRlckJ5LCBzdGFydEFmdGVyLCBRdWVyeURvY3VtZW50U25hcHNob3QsIFF1ZXJ5U25hcHNob3QgfSBmcm9tICdmaXJlYmFzZS9maXJlc3RvcmUnO1xuaW1wb3J0IHsgZ2V0U3RvcmFnZSwgcmVmLCB1cGxvYWRCeXRlcywgZ2V0RG93bmxvYWRVUkwsIGRlbGV0ZU9iamVjdCB9IGZyb20gJ2ZpcmViYXNlL3N0b3JhZ2UnO1xuaW1wb3J0IHsgUHJvZHVjdCB9IGZyb20gJy4uL2RhdGEvcHJvZHVjdHMnO1xuXG4vLyBJbml0aWFsaXplIEZpcmVzdG9yZVxuZXhwb3J0IGNvbnN0IGRiID0gZ2V0RmlyZXN0b3JlKGFwcCk7XG5cbi8vIEluaXRpYWxpemUgU3RvcmFnZVxuZXhwb3J0IGNvbnN0IHN0b3JhZ2UgPSBnZXRTdG9yYWdlKGFwcCk7XG5cbi8vIENvbGxlY3Rpb24gcmVmZXJlbmNlc1xuY29uc3QgcHJvZHVjdHNDb2xsZWN0aW9uID0gY29sbGVjdGlvbihkYiwgJ3Byb2R1Y3RzJyk7XG5jb25zdCBjYXRlZ29yaWVzQ29sbGVjdGlvbiA9IGNvbGxlY3Rpb24oZGIsICdjYXRlZ29yaWVzJyk7XG5cbi8vIENhY2hlIGZvciBwcm9kdWN0c1xuY29uc3QgcHJvZHVjdENhY2hlOiB7XG4gIGFsbDogUHJvZHVjdFtdIHwgbnVsbDtcbiAgYnlJZDogUmVjb3JkPHN0cmluZywgUHJvZHVjdD47XG4gIGJ5Q2F0ZWdvcnk6IFJlY29yZDxzdHJpbmcsIFByb2R1Y3RbXT47XG4gIGxhc3RGZXRjaGVkOiBudW1iZXI7XG59ID0ge1xuICBhbGw6IG51bGwsXG4gIGJ5SWQ6IHt9LFxuICBieUNhdGVnb3J5OiB7fSxcbiAgbGFzdEZldGNoZWQ6IDBcbn07XG5cbi8vIENhY2hlIGV4cGlyYXRpb24gdGltZSAoNSBtaW51dGVzKVxuY29uc3QgQ0FDSEVfRVhQSVJBVElPTiA9IDUgKiA2MCAqIDEwMDA7XG5cbi8vIFZhbGlkYXRlIHByb2R1Y3QgZGF0YSBiZWZvcmUgc2F2aW5nXG5jb25zdCB2YWxpZGF0ZVByb2R1Y3QgPSAocHJvZHVjdDogUGFydGlhbDxQcm9kdWN0Pik6IHN0cmluZyB8IG51bGwgPT4ge1xuICBpZiAoIXByb2R1Y3QubmFtZSB8fCB0eXBlb2YgcHJvZHVjdC5uYW1lICE9PSAnc3RyaW5nJykge1xuICAgIHJldHVybiAnUHJvZHVjdCBuYW1lIGlzIHJlcXVpcmVkJztcbiAgfVxuICBcbiAgaWYgKCFwcm9kdWN0LnByaWNlIHx8IGlzTmFOKE51bWJlcihwcm9kdWN0LnByaWNlKSkpIHtcbiAgICByZXR1cm4gJ1ZhbGlkIHByb2R1Y3QgcHJpY2UgaXMgcmVxdWlyZWQnO1xuICB9XG4gIFxuICBpZiAoIXByb2R1Y3QuY2F0ZWdvcnkgfHwgdHlwZW9mIHByb2R1Y3QuY2F0ZWdvcnkgIT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuICdQcm9kdWN0IGNhdGVnb3J5IGlzIHJlcXVpcmVkJztcbiAgfVxuICBcbiAgaWYgKCFwcm9kdWN0LmltYWdlIHx8IHR5cGVvZiBwcm9kdWN0LmltYWdlICE9PSAnc3RyaW5nJykge1xuICAgIHJldHVybiAnUHJvZHVjdCBpbWFnZSBpcyByZXF1aXJlZCc7XG4gIH1cbiAgXG4gIHJldHVybiBudWxsOyAvLyBObyBlcnJvcnNcbn07XG5cbi8vIENsZWFuIHByb2R1Y3QgZGF0YSBmb3IgRmlyZXN0b3JlXG5jb25zdCBjbGVhblByb2R1Y3REYXRhID0gKHByb2R1Y3Q6IFJlY29yZDxzdHJpbmcsIGFueT4pOiBSZWNvcmQ8c3RyaW5nLCBhbnk+ID0+IHtcbiAgY29uc3QgY2xlYW5lZFByb2R1Y3Q6IFJlY29yZDxzdHJpbmcsIGFueT4gPSB7fTtcbiAgXG4gIE9iamVjdC5lbnRyaWVzKHByb2R1Y3QpLmZvckVhY2goKFtrZXksIHZhbHVlXSkgPT4ge1xuICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkICYmIHZhbHVlICE9PSBudWxsKSB7XG4gICAgICAvLyBIYW5kbGUgc3BlY2lmaWMgZmllbGQgdHlwZXNcbiAgICAgIGlmIChrZXkgPT09ICdwcmljZScgfHwga2V5ID09PSAnb3JpZ2luYWxQcmljZScgfHwga2V5ID09PSAnc3RvY2snKSB7XG4gICAgICAgIGNsZWFuZWRQcm9kdWN0W2tleV0gPSBOdW1iZXIodmFsdWUpO1xuICAgICAgfSBlbHNlIGlmIChrZXkgPT09ICdzaXplcycgJiYgdHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgICBjbGVhbmVkUHJvZHVjdFtrZXldID0gdmFsdWUuc3BsaXQoJywnKS5tYXAoKHM6IHN0cmluZykgPT4gcy50cmltKCkpLmZpbHRlcihCb29sZWFuKTtcbiAgICAgIH0gZWxzZSBpZiAoa2V5ID09PSAnZmVhdHVyZWQnICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgY2xlYW5lZFByb2R1Y3Rba2V5XSA9IHZhbHVlID09PSAndHJ1ZSc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjbGVhbmVkUHJvZHVjdFtrZXldID0gdmFsdWU7XG4gICAgICB9XG4gICAgfVxuICB9KTtcbiAgXG4gIC8vIEFkZCB0aW1lc3RhbXBzXG4gIGlmICghY2xlYW5lZFByb2R1Y3QuY3JlYXRlZEF0KSB7XG4gICAgY2xlYW5lZFByb2R1Y3QuY3JlYXRlZEF0ID0gc2VydmVyVGltZXN0YW1wKCk7XG4gIH1cbiAgY2xlYW5lZFByb2R1Y3QudXBkYXRlZEF0ID0gc2VydmVyVGltZXN0YW1wKCk7XG4gIFxuICByZXR1cm4gY2xlYW5lZFByb2R1Y3Q7XG59O1xuXG4vLyBDaGVjayBpZiBjYWNoZSBpcyB2YWxpZFxuY29uc3QgaXNDYWNoZVZhbGlkID0gKCk6IGJvb2xlYW4gPT4ge1xuICByZXR1cm4gKFxuICAgIHByb2R1Y3RDYWNoZS5hbGwgIT09IG51bGwgJiZcbiAgICBEYXRlLm5vdygpIC0gcHJvZHVjdENhY2hlLmxhc3RGZXRjaGVkIDwgQ0FDSEVfRVhQSVJBVElPTlxuICApO1xufTtcblxuLy8gR2V0IGFsbCBwcm9kdWN0cyB3aXRoIHBhZ2luYXRpb24gYW5kIGNhY2hpbmdcbmV4cG9ydCBjb25zdCBnZXRBbGxQcm9kdWN0cyA9IGFzeW5jIChwYWdlU2l6ZTogbnVtYmVyID0gMCk6IFByb21pc2U8UHJvZHVjdFtdPiA9PiB7XG4gIHRyeSB7XG4gICAgLy8gSWYgY2FjaGUgaXMgdmFsaWQgYW5kIHdlJ3JlIG5vdCBwYWdpbmF0aW5nLCByZXR1cm4gY2FjaGVkIHByb2R1Y3RzXG4gICAgaWYgKGlzQ2FjaGVWYWxpZCgpICYmIHBhZ2VTaXplID09PSAwICYmIHByb2R1Y3RDYWNoZS5hbGwpIHtcbiAgICAgIGNvbnNvbGUubG9nKGBSZXR1cm5pbmcgJHtwcm9kdWN0Q2FjaGUuYWxsLmxlbmd0aH0gcHJvZHVjdHMgZnJvbSBjYWNoZWApO1xuICAgICAgcmV0dXJuIHByb2R1Y3RDYWNoZS5hbGw7XG4gICAgfVxuICAgIFxuICAgIGNvbnNvbGUubG9nKCdDYWNoZSBpbnZhbGlkIG9yIGVtcHR5LCBmZXRjaGluZyBwcm9kdWN0cyBmcm9tIEZpcmVzdG9yZS4uLicpO1xuICAgIFxuICAgIGxldCBwcm9kdWN0c1F1ZXJ5ID0gcXVlcnkocHJvZHVjdHNDb2xsZWN0aW9uLCBvcmRlckJ5KCdjcmVhdGVkQXQnLCAnZGVzYycpKTtcbiAgICBcbiAgICAvLyBBcHBseSBwYWdpbmF0aW9uIGlmIHBhZ2VTaXplIGlzIHNwZWNpZmllZFxuICAgIGlmIChwYWdlU2l6ZSA+IDApIHtcbiAgICAgIHByb2R1Y3RzUXVlcnkgPSBxdWVyeShwcm9kdWN0c1F1ZXJ5LCBsaW1pdChwYWdlU2l6ZSkpO1xuICAgIH1cbiAgICBcbiAgICBjb25zb2xlLmxvZygnRXhlY3V0aW5nIEZpcmVzdG9yZSBxdWVyeS4uLicpO1xuICAgIGNvbnN0IHNuYXBzaG90ID0gYXdhaXQgZ2V0RG9jcyhwcm9kdWN0c1F1ZXJ5KTtcbiAgICBjb25zb2xlLmxvZyhgUmF3IEZpcmVzdG9yZSBxdWVyeSByZXR1cm5lZCAke3NuYXBzaG90LmRvY3MubGVuZ3RofSBkb2N1bWVudHNgKTtcbiAgICBcbiAgICBjb25zdCBwcm9kdWN0cyA9IHNuYXBzaG90LmRvY3MubWFwKGRvYyA9PiB7XG4gICAgICBjb25zdCBkYXRhID0gZG9jLmRhdGEoKTtcbiAgICAgIC8vIExvZyBlYWNoIHByb2R1Y3QgZm9yIGRlYnVnZ2luZ1xuICAgICAgY29uc29sZS5sb2coYFByb2Nlc3NpbmcgcHJvZHVjdDogJHtkb2MuaWR9IC0gJHtkYXRhLm5hbWUgfHwgJ1VubmFtZWQgcHJvZHVjdCd9YCk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBpZDogZG9jLmlkLFxuICAgICAgICAuLi5kYXRhXG4gICAgICB9IGFzIFByb2R1Y3Q7XG4gICAgfSk7XG4gICAgXG4gICAgLy8gVXBkYXRlIGNhY2hlIGlmIHdlJ3JlIGdldHRpbmcgYWxsIHByb2R1Y3RzXG4gICAgaWYgKHBhZ2VTaXplID09PSAwKSB7XG4gICAgICBwcm9kdWN0Q2FjaGUuYWxsID0gcHJvZHVjdHM7XG4gICAgICBcbiAgICAgIC8vIFVwZGF0ZSBieUlkIGFuZCBieUNhdGVnb3J5IGNhY2hlc1xuICAgICAgcHJvZHVjdHMuZm9yRWFjaChwcm9kdWN0ID0+IHtcbiAgICAgICAgcHJvZHVjdENhY2hlLmJ5SWRbcHJvZHVjdC5pZF0gPSBwcm9kdWN0O1xuICAgICAgICBcbiAgICAgICAgaWYgKHByb2R1Y3QuY2F0ZWdvcnkpIHtcbiAgICAgICAgICBpZiAoIXByb2R1Y3RDYWNoZS5ieUNhdGVnb3J5W3Byb2R1Y3QuY2F0ZWdvcnldKSB7XG4gICAgICAgICAgICBwcm9kdWN0Q2FjaGUuYnlDYXRlZ29yeVtwcm9kdWN0LmNhdGVnb3J5XSA9IFtdO1xuICAgICAgICAgIH1cbiAgICAgICAgICBwcm9kdWN0Q2FjaGUuYnlDYXRlZ29yeVtwcm9kdWN0LmNhdGVnb3J5XS5wdXNoKHByb2R1Y3QpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIFxuICAgICAgcHJvZHVjdENhY2hlLmxhc3RGZXRjaGVkID0gRGF0ZS5ub3coKTtcbiAgICB9XG4gICAgXG4gICAgY29uc29sZS5sb2coYFN1Y2Nlc3NmdWxseSBwcm9jZXNzZWQgYW5kIHJldHVybmluZyAke3Byb2R1Y3RzLmxlbmd0aH0gcHJvZHVjdHMgZnJvbSBGaXJlc3RvcmVgKTtcbiAgICByZXR1cm4gcHJvZHVjdHM7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcignRXJyb3IgZ2V0dGluZyBwcm9kdWN0cyBmcm9tIEZpcmVzdG9yZTonLCBlcnJvcik7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdGYWlsZWQgdG8gZmV0Y2ggcHJvZHVjdHMnKTtcbiAgfVxufTtcblxuLy8gR2V0IG5leHQgcGFnZSBvZiBwcm9kdWN0c1xuZXhwb3J0IGNvbnN0IGdldE5leHRQcm9kdWN0c1BhZ2UgPSBhc3luYyAoXG4gIGxhc3RWaXNpYmxlOiBRdWVyeURvY3VtZW50U25hcHNob3QsXG4gIHBhZ2VTaXplOiBudW1iZXIgPSAyMFxuKTogUHJvbWlzZTxQcm9kdWN0W10+ID0+IHtcbiAgdHJ5IHtcbiAgICBjb25zdCBwcm9kdWN0c1F1ZXJ5ID0gcXVlcnkoXG4gICAgICBwcm9kdWN0c0NvbGxlY3Rpb24sXG4gICAgICBvcmRlckJ5KCdjcmVhdGVkQXQnLCAnZGVzYycpLFxuICAgICAgc3RhcnRBZnRlcihsYXN0VmlzaWJsZSksXG4gICAgICBsaW1pdChwYWdlU2l6ZSlcbiAgICApO1xuICAgIFxuICAgIGNvbnN0IHNuYXBzaG90ID0gYXdhaXQgZ2V0RG9jcyhwcm9kdWN0c1F1ZXJ5KTtcbiAgICBjb25zdCBwcm9kdWN0cyA9IHNuYXBzaG90LmRvY3MubWFwKGRvYyA9PiAoe1xuICAgICAgaWQ6IGRvYy5pZCxcbiAgICAgIC4uLmRvYy5kYXRhKClcbiAgICB9IGFzIFByb2R1Y3QpKTtcbiAgICBcbiAgICAvLyBVcGRhdGUgY2FjaGUgZm9yIHRoZXNlIHByb2R1Y3RzXG4gICAgcHJvZHVjdHMuZm9yRWFjaChwcm9kdWN0ID0+IHtcbiAgICAgIHByb2R1Y3RDYWNoZS5ieUlkW3Byb2R1Y3QuaWRdID0gcHJvZHVjdDtcbiAgICAgIFxuICAgICAgaWYgKHByb2R1Y3QuY2F0ZWdvcnkpIHtcbiAgICAgICAgaWYgKCFwcm9kdWN0Q2FjaGUuYnlDYXRlZ29yeVtwcm9kdWN0LmNhdGVnb3J5XSkge1xuICAgICAgICAgIHByb2R1Y3RDYWNoZS5ieUNhdGVnb3J5W3Byb2R1Y3QuY2F0ZWdvcnldID0gW107XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIC8vIENoZWNrIGlmIHByb2R1Y3QgYWxyZWFkeSBleGlzdHMgaW4gY2F0ZWdvcnkgY2FjaGVcbiAgICAgICAgY29uc3QgZXhpc3RpbmdJbmRleCA9IHByb2R1Y3RDYWNoZS5ieUNhdGVnb3J5W3Byb2R1Y3QuY2F0ZWdvcnldLmZpbmRJbmRleChcbiAgICAgICAgICBwID0+IHAuaWQgPT09IHByb2R1Y3QuaWRcbiAgICAgICAgKTtcbiAgICAgICAgXG4gICAgICAgIGlmIChleGlzdGluZ0luZGV4ID49IDApIHtcbiAgICAgICAgICBwcm9kdWN0Q2FjaGUuYnlDYXRlZ29yeVtwcm9kdWN0LmNhdGVnb3J5XVtleGlzdGluZ0luZGV4XSA9IHByb2R1Y3Q7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcHJvZHVjdENhY2hlLmJ5Q2F0ZWdvcnlbcHJvZHVjdC5jYXRlZ29yeV0ucHVzaChwcm9kdWN0KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICAgIFxuICAgIHJldHVybiBwcm9kdWN0cztcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKCdFcnJvciBnZXR0aW5nIG5leHQgcGFnZSBvZiBwcm9kdWN0czonLCBlcnJvcik7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdGYWlsZWQgdG8gZmV0Y2ggbW9yZSBwcm9kdWN0cycpO1xuICB9XG59O1xuXG4vLyBHZXQgcHJvZHVjdHMgYnkgY2F0ZWdvcnkgd2l0aCBjYWNoaW5nXG5leHBvcnQgY29uc3QgZ2V0UHJvZHVjdHNCeUNhdGVnb3J5ID0gYXN5bmMgKGNhdGVnb3J5OiBzdHJpbmcpOiBQcm9taXNlPFByb2R1Y3RbXT4gPT4ge1xuICB0cnkge1xuICAgIC8vIENoZWNrIGlmIHdlIGhhdmUgdGhpcyBjYXRlZ29yeSBpbiBjYWNoZSBhbmQgaXQncyBzdGlsbCB2YWxpZFxuICAgIGlmIChcbiAgICAgIGlzQ2FjaGVWYWxpZCgpICYmXG4gICAgICBwcm9kdWN0Q2FjaGUuYnlDYXRlZ29yeVtjYXRlZ29yeV0gJiZcbiAgICAgIHByb2R1Y3RDYWNoZS5ieUNhdGVnb3J5W2NhdGVnb3J5XS5sZW5ndGggPiAwXG4gICAgKSB7XG4gICAgICBjb25zb2xlLmxvZyhgUmV0dXJuaW5nICR7Y2F0ZWdvcnl9IHByb2R1Y3RzIGZyb20gY2FjaGVgKTtcbiAgICAgIHJldHVybiBwcm9kdWN0Q2FjaGUuYnlDYXRlZ29yeVtjYXRlZ29yeV07XG4gICAgfVxuICAgIFxuICAgIGNvbnNvbGUubG9nKGBGZXRjaGluZyAke2NhdGVnb3J5fSBwcm9kdWN0cyBmcm9tIEZpcmVzdG9yZWApO1xuICAgIGNvbnN0IHEgPSBxdWVyeShwcm9kdWN0c0NvbGxlY3Rpb24sIHdoZXJlKCdjYXRlZ29yeScsICc9PScsIGNhdGVnb3J5KSk7XG4gICAgY29uc3Qgc25hcHNob3QgPSBhd2FpdCBnZXREb2NzKHEpO1xuICAgIGNvbnN0IHByb2R1Y3RzID0gc25hcHNob3QuZG9jcy5tYXAoZG9jID0+ICh7XG4gICAgICBpZDogZG9jLmlkLFxuICAgICAgLi4uZG9jLmRhdGEoKVxuICAgIH0gYXMgUHJvZHVjdCkpO1xuICAgIFxuICAgIC8vIFVwZGF0ZSBjYWNoZVxuICAgIHByb2R1Y3RDYWNoZS5ieUNhdGVnb3J5W2NhdGVnb3J5XSA9IHByb2R1Y3RzO1xuICAgIFxuICAgIC8vIEFsc28gdXBkYXRlIGJ5SWQgY2FjaGVcbiAgICBwcm9kdWN0cy5mb3JFYWNoKHByb2R1Y3QgPT4ge1xuICAgICAgcHJvZHVjdENhY2hlLmJ5SWRbcHJvZHVjdC5pZF0gPSBwcm9kdWN0O1xuICAgIH0pO1xuICAgIFxuICAgIHJldHVybiBwcm9kdWN0cztcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKGBFcnJvciBnZXR0aW5nICR7Y2F0ZWdvcnl9IHByb2R1Y3RzOmAsIGVycm9yKTtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byBmZXRjaCAke2NhdGVnb3J5fSBwcm9kdWN0c2ApO1xuICB9XG59O1xuXG4vLyBHZXQgZmVhdHVyZWQgcHJvZHVjdHMgd2l0aCBjYWNoaW5nXG5leHBvcnQgY29uc3QgZ2V0RmVhdHVyZWRQcm9kdWN0cyA9IGFzeW5jIChsaW1pdENvdW50OiBudW1iZXIgPSA4KTogUHJvbWlzZTxQcm9kdWN0W10+ID0+IHtcbiAgdHJ5IHtcbiAgICAvLyBJZiB3ZSBoYXZlIGFsbCBwcm9kdWN0cyBjYWNoZWQsIGZpbHRlciB0aGVtXG4gICAgaWYgKGlzQ2FjaGVWYWxpZCgpICYmIHByb2R1Y3RDYWNoZS5hbGwpIHtcbiAgICAgIGNvbnN0IGZlYXR1cmVkID0gcHJvZHVjdENhY2hlLmFsbC5maWx0ZXIocCA9PiBwLmZlYXR1cmVkKS5zbGljZSgwLCBsaW1pdENvdW50KTtcbiAgICAgIGlmIChmZWF0dXJlZC5sZW5ndGggPiAwKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKCdSZXR1cm5pbmcgZmVhdHVyZWQgcHJvZHVjdHMgZnJvbSBjYWNoZScpO1xuICAgICAgICByZXR1cm4gZmVhdHVyZWQ7XG4gICAgICB9XG4gICAgfVxuICAgIFxuICAgIGNvbnNvbGUubG9nKCdGZXRjaGluZyBmZWF0dXJlZCBwcm9kdWN0cyBmcm9tIEZpcmVzdG9yZScpO1xuICAgIGNvbnN0IHEgPSBxdWVyeShcbiAgICAgIHByb2R1Y3RzQ29sbGVjdGlvbixcbiAgICAgIHdoZXJlKCdmZWF0dXJlZCcsICc9PScsIHRydWUpLFxuICAgICAgb3JkZXJCeSgnY3JlYXRlZEF0JywgJ2Rlc2MnKSxcbiAgICAgIGxpbWl0KGxpbWl0Q291bnQpXG4gICAgKTtcbiAgICBcbiAgICBjb25zdCBzbmFwc2hvdCA9IGF3YWl0IGdldERvY3MocSk7XG4gICAgY29uc3QgcHJvZHVjdHMgPSBzbmFwc2hvdC5kb2NzLm1hcChkb2MgPT4gKHtcbiAgICAgIGlkOiBkb2MuaWQsXG4gICAgICAuLi5kb2MuZGF0YSgpXG4gICAgfSBhcyBQcm9kdWN0KSk7XG4gICAgXG4gICAgLy8gVXBkYXRlIGJ5SWQgY2FjaGVcbiAgICBwcm9kdWN0cy5mb3JFYWNoKHByb2R1Y3QgPT4ge1xuICAgICAgcHJvZHVjdENhY2hlLmJ5SWRbcHJvZHVjdC5pZF0gPSBwcm9kdWN0O1xuICAgICAgXG4gICAgICAvLyBVcGRhdGUgY2F0ZWdvcnkgY2FjaGUgaWYgbmVlZGVkXG4gICAgICBpZiAocHJvZHVjdC5jYXRlZ29yeSkge1xuICAgICAgICBpZiAoIXByb2R1Y3RDYWNoZS5ieUNhdGVnb3J5W3Byb2R1Y3QuY2F0ZWdvcnldKSB7XG4gICAgICAgICAgcHJvZHVjdENhY2hlLmJ5Q2F0ZWdvcnlbcHJvZHVjdC5jYXRlZ29yeV0gPSBbXTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgLy8gQ2hlY2sgaWYgcHJvZHVjdCBhbHJlYWR5IGV4aXN0cyBpbiBjYXRlZ29yeSBjYWNoZVxuICAgICAgICBjb25zdCBleGlzdGluZ0luZGV4ID0gcHJvZHVjdENhY2hlLmJ5Q2F0ZWdvcnlbcHJvZHVjdC5jYXRlZ29yeV0uZmluZEluZGV4KFxuICAgICAgICAgIHAgPT4gcC5pZCA9PT0gcHJvZHVjdC5pZFxuICAgICAgICApO1xuICAgICAgICBcbiAgICAgICAgaWYgKGV4aXN0aW5nSW5kZXggPj0gMCkge1xuICAgICAgICAgIHByb2R1Y3RDYWNoZS5ieUNhdGVnb3J5W3Byb2R1Y3QuY2F0ZWdvcnldW2V4aXN0aW5nSW5kZXhdID0gcHJvZHVjdDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwcm9kdWN0Q2FjaGUuYnlDYXRlZ29yeVtwcm9kdWN0LmNhdGVnb3J5XS5wdXNoKHByb2R1Y3QpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gICAgXG4gICAgcmV0dXJuIHByb2R1Y3RzO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGdldHRpbmcgZmVhdHVyZWQgcHJvZHVjdHM6JywgZXJyb3IpO1xuICAgIHRocm93IG5ldyBFcnJvcignRmFpbGVkIHRvIGZldGNoIGZlYXR1cmVkIHByb2R1Y3RzJyk7XG4gIH1cbn07XG5cbi8vIEdldCBuZXcgYXJyaXZhbHMgd2l0aCBjYWNoaW5nXG5leHBvcnQgY29uc3QgZ2V0TmV3QXJyaXZhbHMgPSBhc3luYyAobGltaXRDb3VudDogbnVtYmVyID0gOCk6IFByb21pc2U8UHJvZHVjdFtdPiA9PiB7XG4gIHRyeSB7XG4gICAgLy8gSWYgd2UgaGF2ZSBhbGwgcHJvZHVjdHMgY2FjaGVkLCBmaWx0ZXIgdGhlbVxuICAgIGlmIChpc0NhY2hlVmFsaWQoKSAmJiBwcm9kdWN0Q2FjaGUuYWxsKSB7XG4gICAgICBjb25zdCBuZXdBcnJpdmFscyA9IHByb2R1Y3RDYWNoZS5hbGxcbiAgICAgICAgLmZpbHRlcihwID0+IHAubmV3KVxuICAgICAgICAuc2xpY2UoMCwgbGltaXRDb3VudCk7XG4gICAgICAgIFxuICAgICAgaWYgKG5ld0Fycml2YWxzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgY29uc29sZS5sb2coJ1JldHVybmluZyBuZXcgYXJyaXZhbHMgZnJvbSBjYWNoZScpO1xuICAgICAgICByZXR1cm4gbmV3QXJyaXZhbHM7XG4gICAgICB9XG4gICAgfVxuICAgIFxuICAgIGNvbnNvbGUubG9nKCdGZXRjaGluZyBuZXcgYXJyaXZhbHMgZnJvbSBGaXJlc3RvcmUnKTtcbiAgICBjb25zdCBxID0gcXVlcnkoXG4gICAgICBwcm9kdWN0c0NvbGxlY3Rpb24sXG4gICAgICB3aGVyZSgnbmV3JywgJz09JywgdHJ1ZSksXG4gICAgICBvcmRlckJ5KCdjcmVhdGVkQXQnLCAnZGVzYycpLFxuICAgICAgbGltaXQobGltaXRDb3VudClcbiAgICApO1xuICAgIFxuICAgIGNvbnN0IHNuYXBzaG90ID0gYXdhaXQgZ2V0RG9jcyhxKTtcbiAgICBjb25zdCBwcm9kdWN0cyA9IHNuYXBzaG90LmRvY3MubWFwKGRvYyA9PiAoe1xuICAgICAgaWQ6IGRvYy5pZCxcbiAgICAgIC4uLmRvYy5kYXRhKClcbiAgICB9IGFzIFByb2R1Y3QpKTtcbiAgICBcbiAgICAvLyBVcGRhdGUgYnlJZCBjYWNoZVxuICAgIHByb2R1Y3RzLmZvckVhY2gocHJvZHVjdCA9PiB7XG4gICAgICBwcm9kdWN0Q2FjaGUuYnlJZFtwcm9kdWN0LmlkXSA9IHByb2R1Y3Q7XG4gICAgICBcbiAgICAgIC8vIFVwZGF0ZSBjYXRlZ29yeSBjYWNoZSBpZiBuZWVkZWRcbiAgICAgIGlmIChwcm9kdWN0LmNhdGVnb3J5KSB7XG4gICAgICAgIGlmICghcHJvZHVjdENhY2hlLmJ5Q2F0ZWdvcnlbcHJvZHVjdC5jYXRlZ29yeV0pIHtcbiAgICAgICAgICBwcm9kdWN0Q2FjaGUuYnlDYXRlZ29yeVtwcm9kdWN0LmNhdGVnb3J5XSA9IFtdO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICAvLyBDaGVjayBpZiBwcm9kdWN0IGFscmVhZHkgZXhpc3RzIGluIGNhdGVnb3J5IGNhY2hlXG4gICAgICAgIGNvbnN0IGV4aXN0aW5nSW5kZXggPSBwcm9kdWN0Q2FjaGUuYnlDYXRlZ29yeVtwcm9kdWN0LmNhdGVnb3J5XS5maW5kSW5kZXgoXG4gICAgICAgICAgcCA9PiBwLmlkID09PSBwcm9kdWN0LmlkXG4gICAgICAgICk7XG4gICAgICAgIFxuICAgICAgICBpZiAoZXhpc3RpbmdJbmRleCA+PSAwKSB7XG4gICAgICAgICAgcHJvZHVjdENhY2hlLmJ5Q2F0ZWdvcnlbcHJvZHVjdC5jYXRlZ29yeV1bZXhpc3RpbmdJbmRleF0gPSBwcm9kdWN0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHByb2R1Y3RDYWNoZS5ieUNhdGVnb3J5W3Byb2R1Y3QuY2F0ZWdvcnldLnB1c2gocHJvZHVjdCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgICBcbiAgICByZXR1cm4gcHJvZHVjdHM7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcignRXJyb3IgZ2V0dGluZyBuZXcgYXJyaXZhbHM6JywgZXJyb3IpO1xuICAgIHRocm93IG5ldyBFcnJvcignRmFpbGVkIHRvIGZldGNoIG5ldyBhcnJpdmFscycpO1xuICB9XG59O1xuXG4vLyBHZXQgcHJvZHVjdCBieSBJRCB3aXRoIGNhY2hpbmdcbmV4cG9ydCBjb25zdCBnZXRQcm9kdWN0QnlJZCA9IGFzeW5jIChpZDogc3RyaW5nKTogUHJvbWlzZTxQcm9kdWN0IHwgbnVsbD4gPT4ge1xuICB0cnkge1xuICAgIC8vIENoZWNrIGlmIHByb2R1Y3QgaXMgaW4gY2FjaGVcbiAgICBpZiAocHJvZHVjdENhY2hlLmJ5SWRbaWRdKSB7XG4gICAgICBjb25zb2xlLmxvZyhgUmV0dXJuaW5nIHByb2R1Y3QgJHtpZH0gZnJvbSBjYWNoZWApO1xuICAgICAgcmV0dXJuIHByb2R1Y3RDYWNoZS5ieUlkW2lkXTtcbiAgICB9XG4gICAgXG4gICAgY29uc29sZS5sb2coYEZldGNoaW5nIHByb2R1Y3QgJHtpZH0gZnJvbSBGaXJlc3RvcmVgKTtcbiAgICBjb25zdCBwcm9kdWN0RG9jID0gZG9jKGRiLCAncHJvZHVjdHMnLCBpZCk7XG4gICAgY29uc3Qgc25hcHNob3QgPSBhd2FpdCBnZXREb2MocHJvZHVjdERvYyk7XG4gICAgXG4gICAgaWYgKHNuYXBzaG90LmV4aXN0cygpKSB7XG4gICAgICBjb25zdCBwcm9kdWN0ID0ge1xuICAgICAgICBpZDogc25hcHNob3QuaWQsXG4gICAgICAgIC4uLnNuYXBzaG90LmRhdGEoKVxuICAgICAgfSBhcyBQcm9kdWN0O1xuICAgICAgXG4gICAgICAvLyBVcGRhdGUgY2FjaGVcbiAgICAgIHByb2R1Y3RDYWNoZS5ieUlkW2lkXSA9IHByb2R1Y3Q7XG4gICAgICBcbiAgICAgIHJldHVybiBwcm9kdWN0O1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKCdFcnJvciBnZXR0aW5nIHByb2R1Y3Q6JywgZXJyb3IpO1xuICAgIHRocm93IG5ldyBFcnJvcignRmFpbGVkIHRvIGZldGNoIHByb2R1Y3QgZGV0YWlscycpO1xuICB9XG59O1xuXG4vLyBDbGVhciBjYWNoZSBmb3IgYSBzcGVjaWZpYyBwcm9kdWN0XG5jb25zdCBpbnZhbGlkYXRlUHJvZHVjdENhY2hlID0gKHByb2R1Y3RJZDogc3RyaW5nLCBjYXRlZ29yeUlkPzogc3RyaW5nKSA9PiB7XG4gIC8vIFJlbW92ZSBmcm9tIGJ5SWQgY2FjaGVcbiAgaWYgKHByb2R1Y3RDYWNoZS5ieUlkW3Byb2R1Y3RJZF0pIHtcbiAgICBkZWxldGUgcHJvZHVjdENhY2hlLmJ5SWRbcHJvZHVjdElkXTtcbiAgfVxuICBcbiAgLy8gUmVtb3ZlIGZyb20gY2F0ZWdvcnkgY2FjaGUgaWYgY2F0ZWdvcnkgaXMgcHJvdmlkZWRcbiAgaWYgKGNhdGVnb3J5SWQgJiYgcHJvZHVjdENhY2hlLmJ5Q2F0ZWdvcnlbY2F0ZWdvcnlJZF0pIHtcbiAgICBwcm9kdWN0Q2FjaGUuYnlDYXRlZ29yeVtjYXRlZ29yeUlkXSA9IHByb2R1Y3RDYWNoZS5ieUNhdGVnb3J5W2NhdGVnb3J5SWRdLmZpbHRlcihcbiAgICAgIHAgPT4gcC5pZCAhPT0gcHJvZHVjdElkXG4gICAgKTtcbiAgfVxuICBcbiAgLy8gU2V0IGFsbCBjYWNoZSB0byBudWxsIHRvIGZvcmNlIHJlZnJlc2ggb24gbmV4dCBmZXRjaFxuICBwcm9kdWN0Q2FjaGUuYWxsID0gbnVsbDtcbn07XG5cbi8vIENsZWFyIGVudGlyZSBjYWNoZVxuZXhwb3J0IGNvbnN0IGNsZWFyUHJvZHVjdENhY2hlID0gKCkgPT4ge1xuICBwcm9kdWN0Q2FjaGUuYWxsID0gbnVsbDtcbiAgcHJvZHVjdENhY2hlLmJ5SWQgPSB7fTtcbiAgcHJvZHVjdENhY2hlLmJ5Q2F0ZWdvcnkgPSB7fTtcbiAgcHJvZHVjdENhY2hlLmxhc3RGZXRjaGVkID0gMDtcbn07XG5cbi8vIEVuc3VyZSB3ZSBoYXZlIGEgdmFsaWQgc3RvcmFnZSBpbnN0YW5jZVxuY29uc3QgZ2V0U3RvcmFnZUluc3RhbmNlID0gKCkgPT4ge1xuICBjb25zdCBzdG9yYWdlID0gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgPyBnZXRTdG9yYWdlKGFwcCkgOiBudWxsO1xuICBpZiAoc3RvcmFnZSA9PT0gbnVsbCkge1xuICAgIHJldHVybiBnZXRTdG9yYWdlKGFwcCk7XG4gIH1cbiAgcmV0dXJuIHN0b3JhZ2U7XG59O1xuXG4vLyBVcGxvYWQgaW1hZ2UgdG8gRmlyZWJhc2UgU3RvcmFnZVxuZXhwb3J0IGNvbnN0IHVwbG9hZFByb2R1Y3RJbWFnZSA9IGFzeW5jIChmaWxlOiBGaWxlKTogUHJvbWlzZTxzdHJpbmc+ID0+IHtcbiAgdHJ5IHtcbiAgICAvLyBDaGVjayBmaWxlIHNpemUgKGxpbWl0IHRvIDVNQilcbiAgICBpZiAoZmlsZS5zaXplID4gNSAqIDEwMjQgKiAxMDI0KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ltYWdlIGZpbGUgaXMgdG9vIGxhcmdlLiBQbGVhc2Ugc2VsZWN0IGFuIGltYWdlIHNtYWxsZXIgdGhhbiA1TUIuJyk7XG4gICAgfVxuICAgIFxuICAgIC8vIENvbnZlcnQgZmlsZSB0byBiYXNlNjRcbiAgICBjb25zdCBiYXNlNjRTdHJpbmcgPSBhd2FpdCBmaWxlVG9CYXNlNjQoZmlsZSk7XG4gICAgXG4gICAgLy8gQ3JlYXRlIGEgdW5pcXVlIElEIGZvciB0aGUgaW1hZ2VcbiAgICBjb25zdCB0aW1lc3RhbXAgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcbiAgICBjb25zdCBmaWxlTmFtZSA9IGBwcm9kdWN0XyR7dGltZXN0YW1wfV8ke2ZpbGUubmFtZS5yZXBsYWNlKC9bXmEtekEtWjAtOS5dL2csICdfJyl9YDtcbiAgICBcbiAgICAvLyBTdG9yZSB0aGUgYmFzZTY0IGltYWdlIGluIEZpcmVzdG9yZVxuICAgIGNvbnN0IGltYWdlQ29sbGVjdGlvbiA9IGNvbGxlY3Rpb24oZGIsICdpbWFnZXMnKTtcbiAgICBjb25zdCBpbWFnZURvYyA9IGF3YWl0IGFkZERvYyhpbWFnZUNvbGxlY3Rpb24sIHtcbiAgICAgIG5hbWU6IGZpbGVOYW1lLFxuICAgICAgdHlwZTogZmlsZS50eXBlLFxuICAgICAgYmFzZTY0OiBiYXNlNjRTdHJpbmcsXG4gICAgICBjcmVhdGVkQXQ6IHNlcnZlclRpbWVzdGFtcCgpXG4gICAgfSk7XG4gICAgXG4gICAgLy8gUmV0dXJuIHRoZSBkb2N1bWVudCBJRCBhcyB0aGUgaW1hZ2UgVVJMXG4gICAgcmV0dXJuIGBiYXNlNjQ6Ly8ke2ltYWdlRG9jLmlkfWA7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcignRXJyb3IgdXBsb2FkaW5nIGltYWdlOicsIGVycm9yKTtcbiAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignRmFpbGVkIHRvIHVwbG9hZCBwcm9kdWN0IGltYWdlLiBQbGVhc2UgdHJ5IGFnYWluLicpO1xuICAgIH1cbiAgfVxufTtcblxuLy8gSGVscGVyIGZ1bmN0aW9uIHRvIGNvbnZlcnQgRmlsZSB0byBiYXNlNjRcbmNvbnN0IGZpbGVUb0Jhc2U2NCA9IChmaWxlOiBGaWxlKTogUHJvbWlzZTxzdHJpbmc+ID0+IHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgcmVhZGVyID0gbmV3IEZpbGVSZWFkZXIoKTtcbiAgICAgIHJlYWRlci5yZWFkQXNEYXRhVVJMKGZpbGUpO1xuICAgICAgcmVhZGVyLm9ubG9hZCA9ICgpID0+IHtcbiAgICAgICAgaWYgKHR5cGVvZiByZWFkZXIucmVzdWx0ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgIHJlc29sdmUocmVhZGVyLnJlc3VsdCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVqZWN0KG5ldyBFcnJvcignRmFpbGVkIHRvIHJlYWQgaW1hZ2UgZmlsZScpKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIHJlYWRlci5vbmVycm9yID0gKCkgPT4ge1xuICAgICAgICByZWplY3QobmV3IEVycm9yKCdFcnJvciByZWFkaW5nIGltYWdlIGZpbGUuIFBsZWFzZSB0cnkgYSBkaWZmZXJlbnQgaW1hZ2UuJykpO1xuICAgICAgfTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgcmVqZWN0KGVycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvciA6IG5ldyBFcnJvcignVW5rbm93biBlcnJvciBwcm9jZXNzaW5nIGltYWdlJykpO1xuICAgIH1cbiAgfSk7XG59O1xuXG4vLyBHZXQgaW1hZ2UgYnkgSURcbmV4cG9ydCBjb25zdCBnZXRJbWFnZUJ5SWQgPSBhc3luYyAoaW1hZ2VJZDogc3RyaW5nKTogUHJvbWlzZTxzdHJpbmc+ID0+IHtcbiAgdHJ5IHtcbiAgICBjb25zb2xlLmxvZyhgRmV0Y2hpbmcgaW1hZ2Ugd2l0aCBJRDogJHtpbWFnZUlkfWApO1xuICAgIGNvbnN0IGltYWdlRG9jID0gZG9jKGRiLCAnaW1hZ2VzJywgaW1hZ2VJZCk7XG4gICAgY29uc3Qgc25hcHNob3QgPSBhd2FpdCBnZXREb2MoaW1hZ2VEb2MpO1xuICAgIFxuICAgIGlmIChzbmFwc2hvdC5leGlzdHMoKSkge1xuICAgICAgY29uc3QgZGF0YSA9IHNuYXBzaG90LmRhdGEoKTtcbiAgICAgIFxuICAgICAgaWYgKCFkYXRhIHx8ICFkYXRhLmJhc2U2NCkge1xuICAgICAgICBjb25zb2xlLmVycm9yKGBJbWFnZSBleGlzdHMgYnV0IGhhcyBubyBiYXNlNjQgZGF0YS4gSUQ6ICR7aW1hZ2VJZH1gKTtcbiAgICAgICAgcmV0dXJuICcvaW1hZ2VzL3BsYWNlaG9sZGVyLmpwZyc7XG4gICAgICB9XG4gICAgICBcbiAgICAgIGNvbnNvbGUubG9nKGBTdWNjZXNzZnVsbHkgcmV0cmlldmVkIGJhc2U2NCBpbWFnZS4gSUQ6ICR7aW1hZ2VJZH1gKTtcbiAgICAgIHJldHVybiBkYXRhLmJhc2U2NDtcbiAgICB9XG4gICAgXG4gICAgY29uc29sZS5lcnJvcihgSW1hZ2Ugbm90IGZvdW5kIHdpdGggSUQ6ICR7aW1hZ2VJZH1gKTtcbiAgICByZXR1cm4gJy9pbWFnZXMvcGxhY2Vob2xkZXIuanBnJztcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKCdFcnJvciBnZXR0aW5nIGltYWdlOicsIGVycm9yKTtcbiAgICAvLyBSZXR1cm4gYSBwbGFjZWhvbGRlciBpbnN0ZWFkIG9mIHRocm93aW5nLCB0byBwcmV2ZW50IFVJIGJyZWFraW5nXG4gICAgcmV0dXJuICcvaW1hZ2VzL3BsYWNlaG9sZGVyLmpwZyc7XG4gIH1cbn07XG5cbi8vIERlbGV0ZSBwcm9kdWN0IGltYWdlIGZyb20gRmlyZXN0b3JlXG5leHBvcnQgY29uc3QgZGVsZXRlUHJvZHVjdEltYWdlID0gYXN5bmMgKGltYWdlVXJsOiBzdHJpbmcpOiBQcm9taXNlPHZvaWQ+ID0+IHtcbiAgdHJ5IHtcbiAgICAvLyBDaGVjayBpZiBpdCdzIGEgYmFzZTY0IGltYWdlXG4gICAgaWYgKGltYWdlVXJsLnN0YXJ0c1dpdGgoJ2Jhc2U2NDovLycpKSB7XG4gICAgICBjb25zdCBpbWFnZUlkID0gaW1hZ2VVcmwucmVwbGFjZSgnYmFzZTY0Oi8vJywgJycpO1xuICAgICAgY29uc3QgaW1hZ2VEb2MgPSBkb2MoZGIsICdpbWFnZXMnLCBpbWFnZUlkKTtcbiAgICAgIGF3YWl0IGRlbGV0ZURvYyhpbWFnZURvYyk7XG4gICAgICBjb25zb2xlLmxvZygnUHJvZHVjdCBpbWFnZSBkZWxldGVkIHN1Y2Nlc3NmdWxseSBmcm9tIEZpcmVzdG9yZTonLCBpbWFnZUlkKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgXG4gICAgLy8gSGFuZGxlIGxlZ2FjeSBTdG9yYWdlIFVSTHNcbiAgICBjb25zdCBzdG9yYWdlID0gZ2V0U3RvcmFnZUluc3RhbmNlKCk7XG4gICAgXG4gICAgLy8gRXh0cmFjdCB0aGUgZmlsZSBwYXRoIGZyb20gdGhlIFVSTFxuICAgIGNvbnN0IGRlY29kZWRVcmwgPSBkZWNvZGVVUklDb21wb25lbnQoaW1hZ2VVcmwpO1xuICAgIGNvbnN0IHN0YXJ0SW5kZXggPSBkZWNvZGVkVXJsLmluZGV4T2YoJ3Byb2R1Y3RfaW1hZ2VzJyk7XG4gICAgXG4gICAgaWYgKHN0YXJ0SW5kZXggPT09IC0xKSB7XG4gICAgICBjb25zb2xlLndhcm4oJ05vdCBhIEZpcmViYXNlIFN0b3JhZ2UgVVJMIG9yIG5vdCBpbiBwcm9kdWN0X2ltYWdlcyBmb2xkZXI6JywgaW1hZ2VVcmwpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBcbiAgICBjb25zdCBlbmRJbmRleCA9IGRlY29kZWRVcmwuaW5kZXhPZignPycsIHN0YXJ0SW5kZXgpO1xuICAgIGNvbnN0IGZpbGVQYXRoID0gZW5kSW5kZXggIT09IC0xIFxuICAgICAgPyBkZWNvZGVkVXJsLnN1YnN0cmluZyhzdGFydEluZGV4LCBlbmRJbmRleCkgXG4gICAgICA6IGRlY29kZWRVcmwuc3Vic3RyaW5nKHN0YXJ0SW5kZXgpO1xuICAgIFxuICAgIC8vIENyZWF0ZSBhIHJlZmVyZW5jZSB0byB0aGUgZmlsZVxuICAgIGNvbnN0IGltYWdlUmVmID0gcmVmKHN0b3JhZ2UsIGZpbGVQYXRoKTtcbiAgICBcbiAgICAvLyBEZWxldGUgdGhlIGZpbGVcbiAgICBhd2FpdCBkZWxldGVPYmplY3QoaW1hZ2VSZWYpO1xuICAgIGNvbnNvbGUubG9nKCdQcm9kdWN0IGltYWdlIGRlbGV0ZWQgc3VjY2Vzc2Z1bGx5IGZyb20gU3RvcmFnZTonLCBmaWxlUGF0aCk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcignRXJyb3IgZGVsZXRpbmcgcHJvZHVjdCBpbWFnZTonLCBlcnJvcik7XG4gICAgLy8gRG9uJ3QgdGhyb3cgZXJyb3IgaGVyZSwgYXMgd2Ugd2FudCB0byBjb250aW51ZSB3aXRoIHByb2R1Y3QgZGVsZXRpb25cbiAgICAvLyBldmVuIGlmIGltYWdlIGRlbGV0aW9uIGZhaWxzXG4gIH1cbn07XG5cbi8vIEFkZCBhIG5ldyBwcm9kdWN0IHdpdGggdHJhbnNhY3Rpb24gZm9yIGNhdGVnb3J5IHRyYWNraW5nXG5leHBvcnQgY29uc3QgYWRkUHJvZHVjdCA9IGFzeW5jIChwcm9kdWN0OiBPbWl0PFByb2R1Y3QsICdpZCc+KTogUHJvbWlzZTxQcm9kdWN0PiA9PiB7XG4gIHRyeSB7XG4gICAgY29uc29sZS5sb2coJ0FkZGluZyBwcm9kdWN0IHRvIEZpcmVzdG9yZTonLCBwcm9kdWN0KTtcbiAgICBcbiAgICAvLyBWYWxpZGF0ZSBwcm9kdWN0IGRhdGFcbiAgICBjb25zdCB2YWxpZGF0aW9uRXJyb3IgPSB2YWxpZGF0ZVByb2R1Y3QocHJvZHVjdCk7XG4gICAgaWYgKHZhbGlkYXRpb25FcnJvcikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKHZhbGlkYXRpb25FcnJvcik7XG4gICAgfVxuICAgIFxuICAgIC8vIENsZWFuIHRoZSBwcm9kdWN0IGRhdGEgZm9yIEZpcmVzdG9yZVxuICAgIGNvbnN0IGNsZWFuZWRQcm9kdWN0ID0gY2xlYW5Qcm9kdWN0RGF0YShwcm9kdWN0KTtcbiAgICBjb25zb2xlLmxvZygnQ2xlYW5lZCBwcm9kdWN0IGRhdGEgZm9yIEZpcmVzdG9yZTonLCBjbGVhbmVkUHJvZHVjdCk7XG4gICAgXG4gICAgLy8gVXNlIHRyYW5zYWN0aW9uIHRvIGFkZCBwcm9kdWN0IGFuZCB1cGRhdGUgY2F0ZWdvcnkgZGF0YVxuICAgIGNvbnN0IG5ld1Byb2R1Y3QgPSBhd2FpdCBydW5UcmFuc2FjdGlvbihkYiwgYXN5bmMgKHRyYW5zYWN0aW9uKSA9PiB7XG4gICAgICAvLyBBZGQgdGhlIHByb2R1Y3QgZG9jdW1lbnRcbiAgICAgIGNvbnN0IGRvY1JlZiA9IGF3YWl0IGFkZERvYyhwcm9kdWN0c0NvbGxlY3Rpb24sIGNsZWFuZWRQcm9kdWN0KTtcbiAgICAgIGNvbnN0IG5ld1Byb2R1Y3RXaXRoSWQgPSB7IFxuICAgICAgICBpZDogZG9jUmVmLmlkLCBcbiAgICAgICAgLi4uY2xlYW5lZFByb2R1Y3QgXG4gICAgICB9IGFzIHVua25vd24gYXMgUHJvZHVjdDtcbiAgICAgIFxuICAgICAgLy8gVXBkYXRlIG9yIGNyZWF0ZSBjYXRlZ29yeSBjb3VudFxuICAgICAgY29uc3QgY2F0ZWdvcnlSZWYgPSBkb2MoY2F0ZWdvcmllc0NvbGxlY3Rpb24sIGNsZWFuZWRQcm9kdWN0LmNhdGVnb3J5KTtcbiAgICAgIGNvbnN0IGNhdGVnb3J5RG9jID0gYXdhaXQgdHJhbnNhY3Rpb24uZ2V0KGNhdGVnb3J5UmVmKTtcbiAgICAgIFxuICAgICAgaWYgKGNhdGVnb3J5RG9jLmV4aXN0cygpKSB7XG4gICAgICAgIC8vIFVwZGF0ZSBleGlzdGluZyBjYXRlZ29yeVxuICAgICAgICB0cmFuc2FjdGlvbi51cGRhdGUoY2F0ZWdvcnlSZWYsIHtcbiAgICAgICAgICBjb3VudDogKGNhdGVnb3J5RG9jLmRhdGEoKS5jb3VudCB8fCAwKSArIDEsXG4gICAgICAgICAgdXBkYXRlZEF0OiBzZXJ2ZXJUaW1lc3RhbXAoKVxuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIENyZWF0ZSBuZXcgY2F0ZWdvcnlcbiAgICAgICAgdHJhbnNhY3Rpb24uc2V0KGNhdGVnb3J5UmVmLCB7XG4gICAgICAgICAgaWQ6IGNsZWFuZWRQcm9kdWN0LmNhdGVnb3J5LFxuICAgICAgICAgIG5hbWU6IGNsZWFuZWRQcm9kdWN0LmNhdGVnb3J5LmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgY2xlYW5lZFByb2R1Y3QuY2F0ZWdvcnkuc2xpY2UoMSksXG4gICAgICAgICAgY291bnQ6IDEsXG4gICAgICAgICAgY3JlYXRlZEF0OiBzZXJ2ZXJUaW1lc3RhbXAoKSxcbiAgICAgICAgICB1cGRhdGVkQXQ6IHNlcnZlclRpbWVzdGFtcCgpXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgXG4gICAgICByZXR1cm4gbmV3UHJvZHVjdFdpdGhJZDtcbiAgICB9KTtcbiAgICBcbiAgICAvLyBVcGRhdGUgY2FjaGUgd2l0aCB0aGUgbmV3IHByb2R1Y3RcbiAgICBpZiAocHJvZHVjdENhY2hlLmFsbCkge1xuICAgICAgcHJvZHVjdENhY2hlLmFsbC51bnNoaWZ0KG5ld1Byb2R1Y3QgYXMgUHJvZHVjdCk7XG4gICAgfVxuICAgIFxuICAgIHByb2R1Y3RDYWNoZS5ieUlkW25ld1Byb2R1Y3QuaWRdID0gbmV3UHJvZHVjdCBhcyBQcm9kdWN0O1xuICAgIFxuICAgIGlmIChuZXdQcm9kdWN0LmNhdGVnb3J5KSB7XG4gICAgICBpZiAoIXByb2R1Y3RDYWNoZS5ieUNhdGVnb3J5W25ld1Byb2R1Y3QuY2F0ZWdvcnldKSB7XG4gICAgICAgIHByb2R1Y3RDYWNoZS5ieUNhdGVnb3J5W25ld1Byb2R1Y3QuY2F0ZWdvcnldID0gW107XG4gICAgICB9XG4gICAgICBwcm9kdWN0Q2FjaGUuYnlDYXRlZ29yeVtuZXdQcm9kdWN0LmNhdGVnb3J5XS51bnNoaWZ0KG5ld1Byb2R1Y3QgYXMgUHJvZHVjdCk7XG4gICAgfVxuICAgIFxuICAgIGNvbnNvbGUubG9nKCdQcm9kdWN0IGFkZGVkIHN1Y2Nlc3NmdWxseSB3aXRoIElEOicsIG5ld1Byb2R1Y3QuaWQpO1xuICAgIHJldHVybiBuZXdQcm9kdWN0IGFzIFByb2R1Y3Q7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcignRXJyb3IgYWRkaW5nIHByb2R1Y3QgdG8gRmlyZXN0b3JlOicsIGVycm9yKTtcbiAgICB0aHJvdyBlcnJvcjtcbiAgfVxufTtcblxuLy8gVXBkYXRlIGEgcHJvZHVjdFxuZXhwb3J0IGNvbnN0IHVwZGF0ZVByb2R1Y3QgPSBhc3luYyAoaWQ6IHN0cmluZywgcHJvZHVjdDogUGFydGlhbDxQcm9kdWN0Pik6IFByb21pc2U8dm9pZD4gPT4ge1xuICB0cnkge1xuICAgIGNvbnN0IHByb2R1Y3REb2MgPSBkb2MoZGIsICdwcm9kdWN0cycsIGlkKTtcbiAgICBcbiAgICAvLyBHZXQgZXhpc3RpbmcgcHJvZHVjdCB0byBjaGVjayBpZiBjYXRlZ29yeSBpcyBjaGFuZ2luZ1xuICAgIGNvbnN0IGV4aXN0aW5nUHJvZHVjdFNuYXAgPSBhd2FpdCBnZXREb2MocHJvZHVjdERvYyk7XG4gICAgaWYgKCFleGlzdGluZ1Byb2R1Y3RTbmFwLmV4aXN0cygpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Byb2R1Y3Qgbm90IGZvdW5kJyk7XG4gICAgfVxuICAgIFxuICAgIGNvbnN0IGV4aXN0aW5nUHJvZHVjdCA9IGV4aXN0aW5nUHJvZHVjdFNuYXAuZGF0YSgpO1xuICAgIGNvbnN0IGNsZWFuZWRVcGRhdGVzID0gY2xlYW5Qcm9kdWN0RGF0YShwcm9kdWN0KTtcbiAgICBcbiAgICAvLyBBbHdheXMgdXBkYXRlIHRoZSB0aW1lc3RhbXAgd2hlbiBtb2RpZmllZFxuICAgIGNsZWFuZWRVcGRhdGVzLnVwZGF0ZWRBdCA9IHNlcnZlclRpbWVzdGFtcCgpO1xuICAgIFxuICAgIGF3YWl0IHJ1blRyYW5zYWN0aW9uKGRiLCBhc3luYyAodHJhbnNhY3Rpb24pID0+IHtcbiAgICAgIC8vIFVwZGF0ZSBwcm9kdWN0IGRvY3VtZW50XG4gICAgICB0cmFuc2FjdGlvbi51cGRhdGUocHJvZHVjdERvYywgY2xlYW5lZFVwZGF0ZXMpO1xuICAgICAgXG4gICAgICAvLyBJZiBjYXRlZ29yeSBjaGFuZ2VkLCB1cGRhdGUgYm90aCBvbGQgYW5kIG5ldyBjYXRlZ29yeSBjb3VudHNcbiAgICAgIGlmIChwcm9kdWN0LmNhdGVnb3J5ICYmIGV4aXN0aW5nUHJvZHVjdC5jYXRlZ29yeSAhPT0gcHJvZHVjdC5jYXRlZ29yeSkge1xuICAgICAgICAvLyBEZWNyZWFzZSBvbGQgY2F0ZWdvcnkgY291bnRcbiAgICAgICAgY29uc3Qgb2xkQ2F0ZWdvcnlSZWYgPSBkb2MoY2F0ZWdvcmllc0NvbGxlY3Rpb24sIGV4aXN0aW5nUHJvZHVjdC5jYXRlZ29yeSk7XG4gICAgICAgIGNvbnN0IG9sZENhdGVnb3J5RG9jID0gYXdhaXQgdHJhbnNhY3Rpb24uZ2V0KG9sZENhdGVnb3J5UmVmKTtcbiAgICAgICAgXG4gICAgICAgIGlmIChvbGRDYXRlZ29yeURvYy5leGlzdHMoKSkge1xuICAgICAgICAgIGNvbnN0IG9sZENvdW50ID0gb2xkQ2F0ZWdvcnlEb2MuZGF0YSgpLmNvdW50IHx8IDA7XG4gICAgICAgICAgaWYgKG9sZENvdW50ID4gMSkge1xuICAgICAgICAgICAgdHJhbnNhY3Rpb24udXBkYXRlKG9sZENhdGVnb3J5UmVmLCB7IFxuICAgICAgICAgICAgICBjb3VudDogb2xkQ291bnQgLSAxLFxuICAgICAgICAgICAgICB1cGRhdGVkQXQ6IHNlcnZlclRpbWVzdGFtcCgpXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gRGVsZXRlIGNhdGVnb3J5IGlmIGl0IHdpbGwgYmUgZW1wdHlcbiAgICAgICAgICAgIHRyYW5zYWN0aW9uLmRlbGV0ZShvbGRDYXRlZ29yeVJlZik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICAvLyBJbmNyZWFzZSBuZXcgY2F0ZWdvcnkgY291bnRcbiAgICAgICAgY29uc3QgbmV3Q2F0ZWdvcnlSZWYgPSBkb2MoY2F0ZWdvcmllc0NvbGxlY3Rpb24sIHByb2R1Y3QuY2F0ZWdvcnkpO1xuICAgICAgICBjb25zdCBuZXdDYXRlZ29yeURvYyA9IGF3YWl0IHRyYW5zYWN0aW9uLmdldChuZXdDYXRlZ29yeVJlZik7XG4gICAgICAgIFxuICAgICAgICBpZiAobmV3Q2F0ZWdvcnlEb2MuZXhpc3RzKCkpIHtcbiAgICAgICAgICB0cmFuc2FjdGlvbi51cGRhdGUobmV3Q2F0ZWdvcnlSZWYsIHsgXG4gICAgICAgICAgICBjb3VudDogKG5ld0NhdGVnb3J5RG9jLmRhdGEoKS5jb3VudCB8fCAwKSArIDEsXG4gICAgICAgICAgICB1cGRhdGVkQXQ6IHNlcnZlclRpbWVzdGFtcCgpXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdHJhbnNhY3Rpb24uc2V0KG5ld0NhdGVnb3J5UmVmLCB7XG4gICAgICAgICAgICBpZDogcHJvZHVjdC5jYXRlZ29yeSxcbiAgICAgICAgICAgIG5hbWU6IHByb2R1Y3QuY2F0ZWdvcnkuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBwcm9kdWN0LmNhdGVnb3J5LnNsaWNlKDEpLFxuICAgICAgICAgICAgY291bnQ6IDEsXG4gICAgICAgICAgICBjcmVhdGVkQXQ6IHNlcnZlclRpbWVzdGFtcCgpLFxuICAgICAgICAgICAgdXBkYXRlZEF0OiBzZXJ2ZXJUaW1lc3RhbXAoKVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gICAgXG4gICAgLy8gVXBkYXRlIGNhY2hlXG4gICAgaWYgKHByb2R1Y3RDYWNoZS5ieUlkW2lkXSkge1xuICAgICAgY29uc3QgdXBkYXRlZFByb2R1Y3QgPSB7IC4uLnByb2R1Y3RDYWNoZS5ieUlkW2lkXSwgLi4ucHJvZHVjdCB9O1xuICAgICAgcHJvZHVjdENhY2hlLmJ5SWRbaWRdID0gdXBkYXRlZFByb2R1Y3Q7XG4gICAgICBcbiAgICAgIC8vIFVwZGF0ZSBpbiBhbGwgcHJvZHVjdHMgY2FjaGUgaWYgaXQgZXhpc3RzXG4gICAgICBpZiAocHJvZHVjdENhY2hlLmFsbCkge1xuICAgICAgICBjb25zdCBpbmRleCA9IHByb2R1Y3RDYWNoZS5hbGwuZmluZEluZGV4KHAgPT4gcC5pZCA9PT0gaWQpO1xuICAgICAgICBpZiAoaW5kZXggPj0gMCkge1xuICAgICAgICAgIHByb2R1Y3RDYWNoZS5hbGxbaW5kZXhdID0gdXBkYXRlZFByb2R1Y3Q7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIFxuICAgICAgLy8gSGFuZGxlIGNhdGVnb3J5IGNoYW5nZSBpbiBjYWNoZVxuICAgICAgaWYgKHByb2R1Y3QuY2F0ZWdvcnkgJiYgZXhpc3RpbmdQcm9kdWN0LmNhdGVnb3J5ICE9PSBwcm9kdWN0LmNhdGVnb3J5KSB7XG4gICAgICAgIC8vIFJlbW92ZSBmcm9tIG9sZCBjYXRlZ29yeSBjYWNoZVxuICAgICAgICBpZiAocHJvZHVjdENhY2hlLmJ5Q2F0ZWdvcnlbZXhpc3RpbmdQcm9kdWN0LmNhdGVnb3J5XSkge1xuICAgICAgICAgIHByb2R1Y3RDYWNoZS5ieUNhdGVnb3J5W2V4aXN0aW5nUHJvZHVjdC5jYXRlZ29yeV0gPSBwcm9kdWN0Q2FjaGUuYnlDYXRlZ29yeVtleGlzdGluZ1Byb2R1Y3QuY2F0ZWdvcnldLmZpbHRlcihcbiAgICAgICAgICAgIHAgPT4gcC5pZCAhPT0gaWRcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICAvLyBBZGQgdG8gbmV3IGNhdGVnb3J5IGNhY2hlXG4gICAgICAgIGlmICghcHJvZHVjdENhY2hlLmJ5Q2F0ZWdvcnlbcHJvZHVjdC5jYXRlZ29yeV0pIHtcbiAgICAgICAgICBwcm9kdWN0Q2FjaGUuYnlDYXRlZ29yeVtwcm9kdWN0LmNhdGVnb3J5XSA9IFtdO1xuICAgICAgICB9XG4gICAgICAgIHByb2R1Y3RDYWNoZS5ieUNhdGVnb3J5W3Byb2R1Y3QuY2F0ZWdvcnldLnB1c2godXBkYXRlZFByb2R1Y3QpO1xuICAgICAgfSBlbHNlIGlmIChwcm9kdWN0LmNhdGVnb3J5KSB7XG4gICAgICAgIC8vIFVwZGF0ZSBpbiBzYW1lIGNhdGVnb3J5XG4gICAgICAgIGlmIChwcm9kdWN0Q2FjaGUuYnlDYXRlZ29yeVtwcm9kdWN0LmNhdGVnb3J5XSkge1xuICAgICAgICAgIGNvbnN0IGNhdEluZGV4ID0gcHJvZHVjdENhY2hlLmJ5Q2F0ZWdvcnlbcHJvZHVjdC5jYXRlZ29yeV0uZmluZEluZGV4KHAgPT4gcC5pZCA9PT0gaWQpO1xuICAgICAgICAgIGlmIChjYXRJbmRleCA+PSAwKSB7XG4gICAgICAgICAgICBwcm9kdWN0Q2FjaGUuYnlDYXRlZ29yeVtwcm9kdWN0LmNhdGVnb3J5XVtjYXRJbmRleF0gPSB1cGRhdGVkUHJvZHVjdDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gSWYgbm90IGluIGNhY2hlLCBpbnZhbGlkYXRlIGFsbCBjYWNoZSB0byBmb3JjZSByZWZyZXNoXG4gICAgICBjbGVhclByb2R1Y3RDYWNoZSgpO1xuICAgIH1cbiAgICBcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKCdFcnJvciB1cGRhdGluZyBwcm9kdWN0OicsIGVycm9yKTtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZhaWxlZCB0byB1cGRhdGUgcHJvZHVjdCcpO1xuICB9XG59O1xuXG4vLyBEZWxldGUgYSBwcm9kdWN0XG5leHBvcnQgY29uc3QgZGVsZXRlUHJvZHVjdCA9IGFzeW5jIChpZDogc3RyaW5nKTogUHJvbWlzZTx2b2lkPiA9PiB7XG4gIHRyeSB7XG4gICAgY29uc3QgcHJvZHVjdERvYyA9IGRvYyhkYiwgJ3Byb2R1Y3RzJywgaWQpO1xuICAgIFxuICAgIC8vIEdldCBwcm9kdWN0IHRvIGZpbmQgaXRzIGNhdGVnb3J5IGFuZCBpbWFnZSBVUkxcbiAgICBjb25zdCBwcm9kdWN0U25hcCA9IGF3YWl0IGdldERvYyhwcm9kdWN0RG9jKTtcbiAgICBpZiAoIXByb2R1Y3RTbmFwLmV4aXN0cygpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Byb2R1Y3Qgbm90IGZvdW5kJyk7XG4gICAgfVxuICAgIFxuICAgIGNvbnN0IHByb2R1Y3REYXRhID0gcHJvZHVjdFNuYXAuZGF0YSgpIGFzIFByb2R1Y3Q7XG4gICAgXG4gICAgLy8gVHJ5IHRvIGRlbGV0ZSB0aGUgcHJvZHVjdCBpbWFnZSBmaXJzdFxuICAgIGlmIChwcm9kdWN0RGF0YS5pbWFnZSkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgYXdhaXQgZGVsZXRlUHJvZHVjdEltYWdlKHByb2R1Y3REYXRhLmltYWdlKTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGRlbGV0aW5nIHByb2R1Y3QgaW1hZ2U6JywgZXJyb3IpO1xuICAgICAgICAvLyBDb250aW51ZSB3aXRoIHByb2R1Y3QgZGVsZXRpb24gZXZlbiBpZiBpbWFnZSBkZWxldGlvbiBmYWlsc1xuICAgICAgfVxuICAgIH1cbiAgICBcbiAgICBhd2FpdCBydW5UcmFuc2FjdGlvbihkYiwgYXN5bmMgKHRyYW5zYWN0aW9uKSA9PiB7XG4gICAgICAvLyBEZWxldGUgcHJvZHVjdFxuICAgICAgdHJhbnNhY3Rpb24uZGVsZXRlKHByb2R1Y3REb2MpO1xuICAgICAgXG4gICAgICAvLyBVcGRhdGUgY2F0ZWdvcnkgY291bnRcbiAgICAgIGlmIChwcm9kdWN0RGF0YS5jYXRlZ29yeSkge1xuICAgICAgICBjb25zdCBjYXRlZ29yeVJlZiA9IGRvYyhjYXRlZ29yaWVzQ29sbGVjdGlvbiwgcHJvZHVjdERhdGEuY2F0ZWdvcnkpO1xuICAgICAgICBjb25zdCBjYXRlZ29yeURvYyA9IGF3YWl0IHRyYW5zYWN0aW9uLmdldChjYXRlZ29yeVJlZik7XG4gICAgICAgIFxuICAgICAgICBpZiAoY2F0ZWdvcnlEb2MuZXhpc3RzKCkpIHtcbiAgICAgICAgICBjb25zdCBjb3VudCA9IGNhdGVnb3J5RG9jLmRhdGEoKS5jb3VudCB8fCAwO1xuICAgICAgICAgIGlmIChjb3VudCA+IDEpIHtcbiAgICAgICAgICAgIHRyYW5zYWN0aW9uLnVwZGF0ZShjYXRlZ29yeVJlZiwgeyBcbiAgICAgICAgICAgICAgY291bnQ6IGNvdW50IC0gMSxcbiAgICAgICAgICAgICAgdXBkYXRlZEF0OiBzZXJ2ZXJUaW1lc3RhbXAoKVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIERlbGV0ZSBjYXRlZ29yeSBpZiBpdCB3aWxsIGJlIGVtcHR5XG4gICAgICAgICAgICB0cmFuc2FjdGlvbi5kZWxldGUoY2F0ZWdvcnlSZWYpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICAgIFxuICAgIC8vIFVwZGF0ZSBjYWNoZVxuICAgIGludmFsaWRhdGVQcm9kdWN0Q2FjaGUoaWQsIHByb2R1Y3REYXRhLmNhdGVnb3J5KTtcbiAgICBcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKCdFcnJvciBkZWxldGluZyBwcm9kdWN0OicsIGVycm9yKTtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZhaWxlZCB0byBkZWxldGUgcHJvZHVjdCcpO1xuICB9XG59O1xuXG4vLyBHZXQgYWxsIGNhdGVnb3JpZXMgd2l0aCBwcm9kdWN0IGNvdW50c1xuZXhwb3J0IGNvbnN0IGdldEFsbENhdGVnb3JpZXMgPSBhc3luYyAoKSA9PiB7XG4gIHRyeSB7XG4gICAgY29uc3Qgc25hcHNob3QgPSBhd2FpdCBnZXREb2NzKGNhdGVnb3JpZXNDb2xsZWN0aW9uKTtcbiAgICByZXR1cm4gc25hcHNob3QuZG9jcy5tYXAoZG9jID0+IGRvYy5kYXRhKCkpO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGdldHRpbmcgY2F0ZWdvcmllczonLCBlcnJvcik7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdGYWlsZWQgdG8gZmV0Y2ggY2F0ZWdvcmllcycpO1xuICB9XG59OyAiXSwibmFtZXMiOlsiYXBwIiwiZ2V0RmlyZXN0b3JlIiwiY29sbGVjdGlvbiIsImdldERvY3MiLCJkb2MiLCJnZXREb2MiLCJhZGREb2MiLCJkZWxldGVEb2MiLCJxdWVyeSIsIndoZXJlIiwicnVuVHJhbnNhY3Rpb24iLCJzZXJ2ZXJUaW1lc3RhbXAiLCJsaW1pdCIsIm9yZGVyQnkiLCJzdGFydEFmdGVyIiwiZ2V0U3RvcmFnZSIsInJlZiIsImRlbGV0ZU9iamVjdCIsImRiIiwic3RvcmFnZSIsInByb2R1Y3RzQ29sbGVjdGlvbiIsImNhdGVnb3JpZXNDb2xsZWN0aW9uIiwicHJvZHVjdENhY2hlIiwiYWxsIiwiYnlJZCIsImJ5Q2F0ZWdvcnkiLCJsYXN0RmV0Y2hlZCIsIkNBQ0hFX0VYUElSQVRJT04iLCJ2YWxpZGF0ZVByb2R1Y3QiLCJwcm9kdWN0IiwibmFtZSIsInByaWNlIiwiaXNOYU4iLCJOdW1iZXIiLCJjYXRlZ29yeSIsImltYWdlIiwiY2xlYW5Qcm9kdWN0RGF0YSIsImNsZWFuZWRQcm9kdWN0IiwiT2JqZWN0IiwiZW50cmllcyIsImZvckVhY2giLCJrZXkiLCJ2YWx1ZSIsInVuZGVmaW5lZCIsInNwbGl0IiwibWFwIiwicyIsInRyaW0iLCJmaWx0ZXIiLCJCb29sZWFuIiwiY3JlYXRlZEF0IiwidXBkYXRlZEF0IiwiaXNDYWNoZVZhbGlkIiwiRGF0ZSIsIm5vdyIsImdldEFsbFByb2R1Y3RzIiwicGFnZVNpemUiLCJjb25zb2xlIiwibG9nIiwibGVuZ3RoIiwicHJvZHVjdHNRdWVyeSIsInNuYXBzaG90IiwiZG9jcyIsInByb2R1Y3RzIiwiZGF0YSIsImlkIiwicHVzaCIsImVycm9yIiwiRXJyb3IiLCJnZXROZXh0UHJvZHVjdHNQYWdlIiwibGFzdFZpc2libGUiLCJleGlzdGluZ0luZGV4IiwiZmluZEluZGV4IiwicCIsImdldFByb2R1Y3RzQnlDYXRlZ29yeSIsInEiLCJnZXRGZWF0dXJlZFByb2R1Y3RzIiwibGltaXRDb3VudCIsImZlYXR1cmVkIiwic2xpY2UiLCJnZXROZXdBcnJpdmFscyIsIm5ld0Fycml2YWxzIiwibmV3IiwiZ2V0UHJvZHVjdEJ5SWQiLCJwcm9kdWN0RG9jIiwiZXhpc3RzIiwiaW52YWxpZGF0ZVByb2R1Y3RDYWNoZSIsInByb2R1Y3RJZCIsImNhdGVnb3J5SWQiLCJjbGVhclByb2R1Y3RDYWNoZSIsImdldFN0b3JhZ2VJbnN0YW5jZSIsInVwbG9hZFByb2R1Y3RJbWFnZSIsImZpbGUiLCJzaXplIiwiYmFzZTY0U3RyaW5nIiwiZmlsZVRvQmFzZTY0IiwidGltZXN0YW1wIiwiZ2V0VGltZSIsImZpbGVOYW1lIiwicmVwbGFjZSIsImltYWdlQ29sbGVjdGlvbiIsImltYWdlRG9jIiwidHlwZSIsImJhc2U2NCIsIlByb21pc2UiLCJyZXNvbHZlIiwicmVqZWN0IiwicmVhZGVyIiwiRmlsZVJlYWRlciIsInJlYWRBc0RhdGFVUkwiLCJvbmxvYWQiLCJyZXN1bHQiLCJvbmVycm9yIiwiZ2V0SW1hZ2VCeUlkIiwiaW1hZ2VJZCIsImRlbGV0ZVByb2R1Y3RJbWFnZSIsImltYWdlVXJsIiwic3RhcnRzV2l0aCIsImRlY29kZWRVcmwiLCJkZWNvZGVVUklDb21wb25lbnQiLCJzdGFydEluZGV4IiwiaW5kZXhPZiIsIndhcm4iLCJlbmRJbmRleCIsImZpbGVQYXRoIiwic3Vic3RyaW5nIiwiaW1hZ2VSZWYiLCJhZGRQcm9kdWN0IiwidmFsaWRhdGlvbkVycm9yIiwibmV3UHJvZHVjdCIsInRyYW5zYWN0aW9uIiwiZG9jUmVmIiwibmV3UHJvZHVjdFdpdGhJZCIsImNhdGVnb3J5UmVmIiwiY2F0ZWdvcnlEb2MiLCJnZXQiLCJ1cGRhdGUiLCJjb3VudCIsInNldCIsImNoYXJBdCIsInRvVXBwZXJDYXNlIiwidW5zaGlmdCIsInVwZGF0ZVByb2R1Y3QiLCJleGlzdGluZ1Byb2R1Y3RTbmFwIiwiZXhpc3RpbmdQcm9kdWN0IiwiY2xlYW5lZFVwZGF0ZXMiLCJvbGRDYXRlZ29yeVJlZiIsIm9sZENhdGVnb3J5RG9jIiwib2xkQ291bnQiLCJkZWxldGUiLCJuZXdDYXRlZ29yeVJlZiIsIm5ld0NhdGVnb3J5RG9jIiwidXBkYXRlZFByb2R1Y3QiLCJpbmRleCIsImNhdEluZGV4IiwiZGVsZXRlUHJvZHVjdCIsInByb2R1Y3RTbmFwIiwicHJvZHVjdERhdGEiLCJnZXRBbGxDYXRlZ29yaWVzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./utils/firestore.ts\n"));

/***/ })

});