"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("pages/_app",{

/***/ "./context/ProductContext.tsx":
/*!************************************!*\
  !*** ./context/ProductContext.tsx ***!
  \************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ProductProvider: function() { return /* binding */ ProductProvider; },\n/* harmony export */   useProducts: function() { return /* binding */ useProducts; }\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"./node_modules/react/jsx-dev-runtime.js\");\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _utils_firestore__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/firestore */ \"./utils/firestore.ts\");\n\nvar _s = $RefreshSig$(), _s1 = $RefreshSig$();\n\n\nconst ProductContext = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.createContext)(undefined);\nconst useProducts = ()=>{\n    _s();\n    const context = (0,react__WEBPACK_IMPORTED_MODULE_1__.useContext)(ProductContext);\n    if (!context) {\n        throw new Error(\"useProducts must be used within a ProductProvider\");\n    }\n    return context;\n};\n_s(useProducts, \"b9L3QQ+jgeyIrH0NfHrJ8nn7VMU=\");\nconst ProductProvider = (param)=>{\n    let { children } = param;\n    _s1();\n    const [products, setProducts] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)([]);\n    const [categories, setCategories] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)([]);\n    const [productsByCategory, setProductsByCategory] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)({});\n    const [loading, setLoading] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(true);\n    const [error, setError] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n    // Organize products by category\n    const organizeProductsByCategory = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)((allProducts)=>{\n        const byCategory = {};\n        allProducts.forEach((product)=>{\n            if (!product.category) return;\n            if (!byCategory[product.category]) {\n                byCategory[product.category] = [];\n            }\n            byCategory[product.category].push(product);\n        });\n        setProductsByCategory(byCategory);\n    }, []);\n    // Fetch all products from Firestore\n    const fetchProducts = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)(async ()=>{\n        try {\n            setLoading(true);\n            setError(null);\n            // Get data from Firestore\n            const fetchedProducts = await _utils_firestore__WEBPACK_IMPORTED_MODULE_2__.getAllProducts();\n            // Get categories from Firestore\n            // This is handled automatically by the Firestore API\n            setProducts(fetchedProducts);\n            organizeProductsByCategory(fetchedProducts);\n        } catch (err) {\n            console.error(\"Error fetching products:\", err);\n            setError(err.message || \"Failed to load products. Please try again later.\");\n        } finally{\n            setLoading(false);\n        }\n    }, [\n        organizeProductsByCategory\n    ]);\n    // Load products on mount\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        fetchProducts();\n    }, [\n        fetchProducts\n    ]);\n    // Get products in a specific category\n    const getProductsInCategory = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)((category)=>{\n        return productsByCategory[category] || [];\n    }, [\n        productsByCategory\n    ]);\n    // Add a new product\n    const addNewProduct = async (product)=>{\n        try {\n            setError(null);\n            // Ensure product has required fields\n            if (!product.category) {\n                throw new Error(\"Product category is required\");\n            }\n            // Add product to Firestore\n            const newProduct = await _utils_firestore__WEBPACK_IMPORTED_MODULE_2__.addProduct(product);\n            // Update local state\n            setProducts((prevProducts)=>[\n                    ...prevProducts,\n                    newProduct\n                ]);\n            // Update category cache\n            setProductsByCategory((prev)=>{\n                const updated = {\n                    ...prev\n                };\n                const category = product.category;\n                if (!updated[category]) {\n                    updated[category] = [];\n                }\n                updated[category] = [\n                    ...updated[category],\n                    newProduct\n                ];\n                return updated;\n            });\n            return newProduct;\n        } catch (err) {\n            console.error(\"Error adding product:\", err);\n            setError(err.message || \"Failed to add product\");\n            throw err;\n        }\n    };\n    // Update an existing product\n    const updateExistingProduct = async (id, updates)=>{\n        try {\n            setError(null);\n            // Find the existing product to check for category changes\n            const existingProduct = products.find((p)=>p.id === id);\n            if (!existingProduct) {\n                throw new Error(\"Product not found\");\n            }\n            // Update in Firestore\n            await _utils_firestore__WEBPACK_IMPORTED_MODULE_2__.updateProduct(id, updates);\n            // Get the updated product\n            const updatedProduct = {\n                ...existingProduct,\n                ...updates\n            };\n            // Update local state\n            setProducts((prevProducts)=>prevProducts.map((p)=>p.id === id ? updatedProduct : p));\n            // Handle category change if needed\n            if (updates.category && existingProduct.category !== updates.category) {\n                // Refetch products to ensure they're up to date\n                await fetchProducts();\n            } else {\n                // Just update the product in its existing category\n                setProductsByCategory((prev)=>{\n                    const category = existingProduct.category;\n                    if (category && prev[category]) {\n                        return {\n                            ...prev,\n                            [category]: prev[category].map((p)=>p.id === id ? updatedProduct : p)\n                        };\n                    }\n                    return prev;\n                });\n            }\n        } catch (err) {\n            console.error(\"Error updating product:\", err);\n            setError(err.message || \"Failed to update product\");\n            throw err;\n        }\n    };\n    // Remove a product\n    const removeProduct = async (id)=>{\n        try {\n            setError(null);\n            // Find the product to get its category\n            const productToRemove = products.find((p)=>p.id === id);\n            if (!productToRemove) {\n                throw new Error(\"Product not found\");\n            }\n            // Delete from Firestore\n            await _utils_firestore__WEBPACK_IMPORTED_MODULE_2__.deleteProduct(id);\n            // Update local state\n            setProducts((prevProducts)=>prevProducts.filter((p)=>p.id !== id));\n            // Update category cache\n            if (productToRemove.category) {\n                setProductsByCategory((prev)=>{\n                    const updated = {\n                        ...prev\n                    };\n                    if (updated[productToRemove.category]) {\n                        updated[productToRemove.category] = updated[productToRemove.category].filter((p)=>p.id !== id);\n                        // Remove category array if empty\n                        if (updated[productToRemove.category].length === 0) {\n                            delete updated[productToRemove.category];\n                        }\n                    }\n                    return updated;\n                });\n            }\n        } catch (err) {\n            console.error(\"Error removing product:\", err);\n            setError(err.message || \"Failed to delete product\");\n            throw err;\n        }\n    };\n    // Upload an image to Firebase Storage\n    const uploadImage = async (file)=>{\n        try {\n            setError(null);\n            return await _utils_firestore__WEBPACK_IMPORTED_MODULE_2__.uploadProductImage(file);\n        } catch (err) {\n            console.error(\"Error uploading image:\", err);\n            setError(err.message || \"Failed to upload image\");\n            throw err;\n        }\n    };\n    // Manual refresh function\n    const refreshProducts = async ()=>{\n        await fetchProducts();\n    };\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(ProductContext.Provider, {\n        value: {\n            products,\n            categories,\n            productsByCategory,\n            loading,\n            error,\n            addNewProduct,\n            updateExistingProduct,\n            removeProduct,\n            uploadImage,\n            refreshProducts,\n            getProductsInCategory\n        },\n        children: children\n    }, void 0, false, {\n        fileName: \"C:\\\\Projects\\\\Freelansing websites\\\\rangya-master\\\\context\\\\ProductContext.tsx\",\n        lineNumber: 230,\n        columnNumber: 5\n    }, undefined);\n};\n_s1(ProductProvider, \"dNCeWSqA52/VNPCqWEXHWbkh33o=\");\n_c = ProductProvider;\nvar _c;\n$RefreshReg$(_c, \"ProductProvider\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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Z0JBQWdCekIsUUFBUSxDQUFDO3dCQUMxQztvQkFDRjtvQkFDQSxPQUFPYztnQkFDVDtZQUNGO1FBQ0YsRUFBRSxPQUFPVCxLQUFVO1lBQ2pCQyxRQUFRYixLQUFLLENBQUMsMkJBQTJCWTtZQUN6Q1gsU0FBU1csSUFBSUUsT0FBTyxJQUFJO1lBQ3hCLE1BQU1GO1FBQ1I7SUFDRjtJQUVBLHNDQUFzQztJQUN0QyxNQUFNd0IsY0FBYyxPQUFPQztRQUN6QixJQUFJO1lBQ0ZwQyxTQUFTO1lBQ1QsT0FBTyxNQUFNakIsZ0VBQStCLENBQUNxRDtRQUMvQyxFQUFFLE9BQU96QixLQUFVO1lBQ2pCQyxRQUFRYixLQUFLLENBQUMsMEJBQTBCWTtZQUN4Q1gsU0FBU1csSUFBSUUsT0FBTyxJQUFJO1lBQ3hCLE1BQU1GO1FBQ1I7SUFDRjtJQUVBLDBCQUEwQjtJQUMxQixNQUFNMkIsa0JBQWtCO1FBQ3RCLE1BQU05QjtJQUNSO0lBRUEscUJBQ0UsOERBQUN4QixlQUFldUQsUUFBUTtRQUN0QkMsT0FBTztZQUNMakQ7WUFDQUU7WUFDQUU7WUFDQUU7WUFDQUU7WUFDQWdCO1lBQ0FNO1lBQ0FTO1lBQ0FLO1lBQ0FHO1lBQ0F4QjtRQUNGO2tCQUVDeEI7Ozs7OztBQUdQLEVBQUU7SUExTldEO0tBQUFBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL2NvbnRleHQvUHJvZHVjdENvbnRleHQudHN4PzU4ZTYiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IFJlYWN0LCB7IGNyZWF0ZUNvbnRleHQsIHVzZUNvbnRleHQsIHVzZVN0YXRlLCB1c2VFZmZlY3QsIHVzZUNhbGxiYWNrIH0gZnJvbSAncmVhY3QnO1xyXG5pbXBvcnQgeyBQcm9kdWN0IH0gZnJvbSAnLi4vZGF0YS9wcm9kdWN0cyc7XHJcbmltcG9ydCB7IENhdGVnb3J5IH0gZnJvbSAnLi4vdXRpbHMvbG9jYWxTdG9yYWdlJztcclxuaW1wb3J0ICogYXMgZmlyZXN0b3JlQVBJIGZyb20gJy4uL3V0aWxzL2ZpcmVzdG9yZSc7XHJcblxyXG5pbnRlcmZhY2UgUHJvZHVjdENvbnRleHRUeXBlIHtcclxuICBwcm9kdWN0czogUHJvZHVjdFtdO1xyXG4gIGNhdGVnb3JpZXM6IENhdGVnb3J5W107XHJcbiAgcHJvZHVjdHNCeUNhdGVnb3J5OiBSZWNvcmQ8c3RyaW5nLCBQcm9kdWN0W10+O1xyXG4gIGxvYWRpbmc6IGJvb2xlYW47XHJcbiAgZXJyb3I6IHN0cmluZyB8IG51bGw7XHJcbiAgYWRkTmV3UHJvZHVjdDogKHByb2R1Y3Q6IE9taXQ8UHJvZHVjdCwgJ2lkJz4pID0+IFByb21pc2U8UHJvZHVjdD47XHJcbiAgdXBkYXRlRXhpc3RpbmdQcm9kdWN0OiAoaWQ6IHN0cmluZywgcHJvZHVjdDogUGFydGlhbDxQcm9kdWN0PikgPT4gUHJvbWlzZTx2b2lkPjtcclxuICByZW1vdmVQcm9kdWN0OiAoaWQ6IHN0cmluZykgPT4gUHJvbWlzZTx2b2lkPjtcclxuICB1cGxvYWRJbWFnZTogKGZpbGU6IEZpbGUpID0+IFByb21pc2U8c3RyaW5nPjtcclxuICByZWZyZXNoUHJvZHVjdHM6ICgpID0+IFByb21pc2U8dm9pZD47XHJcbiAgZ2V0UHJvZHVjdHNJbkNhdGVnb3J5OiAoY2F0ZWdvcnk6IHN0cmluZykgPT4gUHJvZHVjdFtdO1xyXG59XHJcblxyXG5jb25zdCBQcm9kdWN0Q29udGV4dCA9IGNyZWF0ZUNvbnRleHQ8UHJvZHVjdENvbnRleHRUeXBlIHwgdW5kZWZpbmVkPih1bmRlZmluZWQpO1xyXG5cclxuZXhwb3J0IGNvbnN0IHVzZVByb2R1Y3RzID0gKCkgPT4ge1xyXG4gIGNvbnN0IGNvbnRleHQgPSB1c2VDb250ZXh0KFByb2R1Y3RDb250ZXh0KTtcclxuICBpZiAoIWNvbnRleHQpIHtcclxuICAgIHRocm93IG5ldyBFcnJvcigndXNlUHJvZHVjdHMgbXVzdCBiZSB1c2VkIHdpdGhpbiBhIFByb2R1Y3RQcm92aWRlcicpO1xyXG4gIH1cclxuICByZXR1cm4gY29udGV4dDtcclxufTtcclxuXHJcbmV4cG9ydCBjb25zdCBQcm9kdWN0UHJvdmlkZXI6IFJlYWN0LkZDPHsgY2hpbGRyZW46IFJlYWN0LlJlYWN0Tm9kZSB9PiA9ICh7IGNoaWxkcmVuIH0pID0+IHtcclxuICBjb25zdCBbcHJvZHVjdHMsIHNldFByb2R1Y3RzXSA9IHVzZVN0YXRlPFByb2R1Y3RbXT4oW10pO1xyXG4gIGNvbnN0IFtjYXRlZ29yaWVzLCBzZXRDYXRlZ29yaWVzXSA9IHVzZVN0YXRlPENhdGVnb3J5W10+KFtdKTtcclxuICBjb25zdCBbcHJvZHVjdHNCeUNhdGVnb3J5LCBzZXRQcm9kdWN0c0J5Q2F0ZWdvcnldID0gdXNlU3RhdGU8UmVjb3JkPHN0cmluZywgUHJvZHVjdFtdPj4oe30pO1xyXG4gIGNvbnN0IFtsb2FkaW5nLCBzZXRMb2FkaW5nXSA9IHVzZVN0YXRlPGJvb2xlYW4+KHRydWUpO1xyXG4gIGNvbnN0IFtlcnJvciwgc2V0RXJyb3JdID0gdXNlU3RhdGU8c3RyaW5nIHwgbnVsbD4obnVsbCk7XHJcblxyXG4gIC8vIE9yZ2FuaXplIHByb2R1Y3RzIGJ5IGNhdGVnb3J5XHJcbiAgY29uc3Qgb3JnYW5pemVQcm9kdWN0c0J5Q2F0ZWdvcnkgPSB1c2VDYWxsYmFjaygoYWxsUHJvZHVjdHM6IFByb2R1Y3RbXSkgPT4ge1xyXG4gICAgY29uc3QgYnlDYXRlZ29yeTogUmVjb3JkPHN0cmluZywgUHJvZHVjdFtdPiA9IHt9O1xyXG4gICAgXHJcbiAgICBhbGxQcm9kdWN0cy5mb3JFYWNoKHByb2R1Y3QgPT4ge1xyXG4gICAgICBpZiAoIXByb2R1Y3QuY2F0ZWdvcnkpIHJldHVybjtcclxuICAgICAgXHJcbiAgICAgIGlmICghYnlDYXRlZ29yeVtwcm9kdWN0LmNhdGVnb3J5XSkge1xyXG4gICAgICAgIGJ5Q2F0ZWdvcnlbcHJvZHVjdC5jYXRlZ29yeV0gPSBbXTtcclxuICAgICAgfVxyXG4gICAgICBcclxuICAgICAgYnlDYXRlZ29yeVtwcm9kdWN0LmNhdGVnb3J5XS5wdXNoKHByb2R1Y3QpO1xyXG4gICAgfSk7XHJcbiAgICBcclxuICAgIHNldFByb2R1Y3RzQnlDYXRlZ29yeShieUNhdGVnb3J5KTtcclxuICB9LCBbXSk7XHJcblxyXG4gIC8vIEZldGNoIGFsbCBwcm9kdWN0cyBmcm9tIEZpcmVzdG9yZVxyXG4gIGNvbnN0IGZldGNoUHJvZHVjdHMgPSB1c2VDYWxsYmFjayhhc3luYyAoKSA9PiB7XHJcbiAgICB0cnkge1xyXG4gICAgICBzZXRMb2FkaW5nKHRydWUpO1xyXG4gICAgICBzZXRFcnJvcihudWxsKTtcclxuICAgICAgXHJcbiAgICAgIC8vIEdldCBkYXRhIGZyb20gRmlyZXN0b3JlXHJcbiAgICAgIGNvbnN0IGZldGNoZWRQcm9kdWN0cyA9IGF3YWl0IGZpcmVzdG9yZUFQSS5nZXRBbGxQcm9kdWN0cygpO1xyXG4gICAgICBcclxuICAgICAgLy8gR2V0IGNhdGVnb3JpZXMgZnJvbSBGaXJlc3RvcmVcclxuICAgICAgLy8gVGhpcyBpcyBoYW5kbGVkIGF1dG9tYXRpY2FsbHkgYnkgdGhlIEZpcmVzdG9yZSBBUElcclxuICAgICAgXHJcbiAgICAgIHNldFByb2R1Y3RzKGZldGNoZWRQcm9kdWN0cyk7XHJcbiAgICAgIG9yZ2FuaXplUHJvZHVjdHNCeUNhdGVnb3J5KGZldGNoZWRQcm9kdWN0cyk7XHJcbiAgICAgIFxyXG4gICAgfSBjYXRjaCAoZXJyOiBhbnkpIHtcclxuICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgZmV0Y2hpbmcgcHJvZHVjdHM6JywgZXJyKTtcclxuICAgICAgc2V0RXJyb3IoZXJyLm1lc3NhZ2UgfHwgJ0ZhaWxlZCB0byBsb2FkIHByb2R1Y3RzLiBQbGVhc2UgdHJ5IGFnYWluIGxhdGVyLicpO1xyXG4gICAgfSBmaW5hbGx5IHtcclxuICAgICAgc2V0TG9hZGluZyhmYWxzZSk7XHJcbiAgICB9XHJcbiAgfSwgW29yZ2FuaXplUHJvZHVjdHNCeUNhdGVnb3J5XSk7XHJcblxyXG4gIC8vIExvYWQgcHJvZHVjdHMgb24gbW91bnRcclxuICB1c2VFZmZlY3QoKCkgPT4ge1xyXG4gICAgZmV0Y2hQcm9kdWN0cygpO1xyXG4gIH0sIFtmZXRjaFByb2R1Y3RzXSk7XHJcblxyXG4gIC8vIEdldCBwcm9kdWN0cyBpbiBhIHNwZWNpZmljIGNhdGVnb3J5XHJcbiAgY29uc3QgZ2V0UHJvZHVjdHNJbkNhdGVnb3J5ID0gdXNlQ2FsbGJhY2soKGNhdGVnb3J5OiBzdHJpbmcpOiBQcm9kdWN0W10gPT4ge1xyXG4gICAgcmV0dXJuIHByb2R1Y3RzQnlDYXRlZ29yeVtjYXRlZ29yeV0gfHwgW107XHJcbiAgfSwgW3Byb2R1Y3RzQnlDYXRlZ29yeV0pO1xyXG5cclxuICAvLyBBZGQgYSBuZXcgcHJvZHVjdFxyXG4gIGNvbnN0IGFkZE5ld1Byb2R1Y3QgPSBhc3luYyAocHJvZHVjdDogT21pdDxQcm9kdWN0LCAnaWQnPik6IFByb21pc2U8UHJvZHVjdD4gPT4ge1xyXG4gICAgdHJ5IHtcclxuICAgICAgc2V0RXJyb3IobnVsbCk7XHJcbiAgICAgIFxyXG4gICAgICAvLyBFbnN1cmUgcHJvZHVjdCBoYXMgcmVxdWlyZWQgZmllbGRzXHJcbiAgICAgIGlmICghcHJvZHVjdC5jYXRlZ29yeSkge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignUHJvZHVjdCBjYXRlZ29yeSBpcyByZXF1aXJlZCcpO1xyXG4gICAgICB9XHJcbiAgICAgIFxyXG4gICAgICAvLyBBZGQgcHJvZHVjdCB0byBGaXJlc3RvcmVcclxuICAgICAgY29uc3QgbmV3UHJvZHVjdCA9IGF3YWl0IGZpcmVzdG9yZUFQSS5hZGRQcm9kdWN0KHByb2R1Y3QpO1xyXG4gICAgICBcclxuICAgICAgLy8gVXBkYXRlIGxvY2FsIHN0YXRlXHJcbiAgICAgIHNldFByb2R1Y3RzKHByZXZQcm9kdWN0cyA9PiBbLi4ucHJldlByb2R1Y3RzLCBuZXdQcm9kdWN0XSk7XHJcbiAgICAgIFxyXG4gICAgICAvLyBVcGRhdGUgY2F0ZWdvcnkgY2FjaGVcclxuICAgICAgc2V0UHJvZHVjdHNCeUNhdGVnb3J5KHByZXYgPT4ge1xyXG4gICAgICAgIGNvbnN0IHVwZGF0ZWQgPSB7IC4uLnByZXYgfTtcclxuICAgICAgICBjb25zdCBjYXRlZ29yeSA9IHByb2R1Y3QuY2F0ZWdvcnkgYXMgc3RyaW5nO1xyXG4gICAgICAgIFxyXG4gICAgICAgIGlmICghdXBkYXRlZFtjYXRlZ29yeV0pIHtcclxuICAgICAgICAgIHVwZGF0ZWRbY2F0ZWdvcnldID0gW107XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHVwZGF0ZWRbY2F0ZWdvcnldID0gWy4uLnVwZGF0ZWRbY2F0ZWdvcnldLCBuZXdQcm9kdWN0XTtcclxuICAgICAgICByZXR1cm4gdXBkYXRlZDtcclxuICAgICAgfSk7XHJcbiAgICAgIFxyXG4gICAgICByZXR1cm4gbmV3UHJvZHVjdDtcclxuICAgIH0gY2F0Y2ggKGVycjogYW55KSB7XHJcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGFkZGluZyBwcm9kdWN0OicsIGVycik7XHJcbiAgICAgIHNldEVycm9yKGVyci5tZXNzYWdlIHx8ICdGYWlsZWQgdG8gYWRkIHByb2R1Y3QnKTtcclxuICAgICAgdGhyb3cgZXJyO1xyXG4gICAgfVxyXG4gIH07XHJcblxyXG4gIC8vIFVwZGF0ZSBhbiBleGlzdGluZyBwcm9kdWN0XHJcbiAgY29uc3QgdXBkYXRlRXhpc3RpbmdQcm9kdWN0ID0gYXN5bmMgKGlkOiBzdHJpbmcsIHVwZGF0ZXM6IFBhcnRpYWw8UHJvZHVjdD4pOiBQcm9taXNlPHZvaWQ+ID0+IHtcclxuICAgIHRyeSB7XHJcbiAgICAgIHNldEVycm9yKG51bGwpO1xyXG4gICAgICBcclxuICAgICAgLy8gRmluZCB0aGUgZXhpc3RpbmcgcHJvZHVjdCB0byBjaGVjayBmb3IgY2F0ZWdvcnkgY2hhbmdlc1xyXG4gICAgICBjb25zdCBleGlzdGluZ1Byb2R1Y3QgPSBwcm9kdWN0cy5maW5kKHAgPT4gcC5pZCA9PT0gaWQpO1xyXG4gICAgICBpZiAoIWV4aXN0aW5nUHJvZHVjdCkge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignUHJvZHVjdCBub3QgZm91bmQnKTtcclxuICAgICAgfVxyXG4gICAgICBcclxuICAgICAgLy8gVXBkYXRlIGluIEZpcmVzdG9yZVxyXG4gICAgICBhd2FpdCBmaXJlc3RvcmVBUEkudXBkYXRlUHJvZHVjdChpZCwgdXBkYXRlcyk7XHJcbiAgICAgIFxyXG4gICAgICAvLyBHZXQgdGhlIHVwZGF0ZWQgcHJvZHVjdFxyXG4gICAgICBjb25zdCB1cGRhdGVkUHJvZHVjdCA9IHsgLi4uZXhpc3RpbmdQcm9kdWN0LCAuLi51cGRhdGVzIH07XHJcbiAgICAgIFxyXG4gICAgICAvLyBVcGRhdGUgbG9jYWwgc3RhdGVcclxuICAgICAgc2V0UHJvZHVjdHMocHJldlByb2R1Y3RzID0+IFxyXG4gICAgICAgIHByZXZQcm9kdWN0cy5tYXAocCA9PiBwLmlkID09PSBpZCA/IHVwZGF0ZWRQcm9kdWN0IDogcClcclxuICAgICAgKTtcclxuICAgICAgXHJcbiAgICAgIC8vIEhhbmRsZSBjYXRlZ29yeSBjaGFuZ2UgaWYgbmVlZGVkXHJcbiAgICAgIGlmICh1cGRhdGVzLmNhdGVnb3J5ICYmIGV4aXN0aW5nUHJvZHVjdC5jYXRlZ29yeSAhPT0gdXBkYXRlcy5jYXRlZ29yeSkge1xyXG4gICAgICAgIC8vIFJlZmV0Y2ggcHJvZHVjdHMgdG8gZW5zdXJlIHRoZXkncmUgdXAgdG8gZGF0ZVxyXG4gICAgICAgIGF3YWl0IGZldGNoUHJvZHVjdHMoKTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICAvLyBKdXN0IHVwZGF0ZSB0aGUgcHJvZHVjdCBpbiBpdHMgZXhpc3RpbmcgY2F0ZWdvcnlcclxuICAgICAgICBzZXRQcm9kdWN0c0J5Q2F0ZWdvcnkocHJldiA9PiB7XHJcbiAgICAgICAgICBjb25zdCBjYXRlZ29yeSA9IGV4aXN0aW5nUHJvZHVjdC5jYXRlZ29yeTtcclxuICAgICAgICAgIGlmIChjYXRlZ29yeSAmJiBwcmV2W2NhdGVnb3J5XSkge1xyXG4gICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgIC4uLnByZXYsXHJcbiAgICAgICAgICAgICAgW2NhdGVnb3J5XTogcHJldltjYXRlZ29yeV0ubWFwKHAgPT4gXHJcbiAgICAgICAgICAgICAgICBwLmlkID09PSBpZCA/IHVwZGF0ZWRQcm9kdWN0IDogcFxyXG4gICAgICAgICAgICAgIClcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIHJldHVybiBwcmV2O1xyXG4gICAgICAgIH0pO1xyXG4gICAgICB9XHJcbiAgICB9IGNhdGNoIChlcnI6IGFueSkge1xyXG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciB1cGRhdGluZyBwcm9kdWN0OicsIGVycik7XHJcbiAgICAgIHNldEVycm9yKGVyci5tZXNzYWdlIHx8ICdGYWlsZWQgdG8gdXBkYXRlIHByb2R1Y3QnKTtcclxuICAgICAgdGhyb3cgZXJyO1xyXG4gICAgfVxyXG4gIH07XHJcblxyXG4gIC8vIFJlbW92ZSBhIHByb2R1Y3RcclxuICBjb25zdCByZW1vdmVQcm9kdWN0ID0gYXN5bmMgKGlkOiBzdHJpbmcpOiBQcm9taXNlPHZvaWQ+ID0+IHtcclxuICAgIHRyeSB7XHJcbiAgICAgIHNldEVycm9yKG51bGwpO1xyXG4gICAgICBcclxuICAgICAgLy8gRmluZCB0aGUgcHJvZHVjdCB0byBnZXQgaXRzIGNhdGVnb3J5XHJcbiAgICAgIGNvbnN0IHByb2R1Y3RUb1JlbW92ZSA9IHByb2R1Y3RzLmZpbmQocCA9PiBwLmlkID09PSBpZCk7XHJcbiAgICAgIGlmICghcHJvZHVjdFRvUmVtb3ZlKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdQcm9kdWN0IG5vdCBmb3VuZCcpO1xyXG4gICAgICB9XHJcbiAgICAgIFxyXG4gICAgICAvLyBEZWxldGUgZnJvbSBGaXJlc3RvcmVcclxuICAgICAgYXdhaXQgZmlyZXN0b3JlQVBJLmRlbGV0ZVByb2R1Y3QoaWQpO1xyXG4gICAgICBcclxuICAgICAgLy8gVXBkYXRlIGxvY2FsIHN0YXRlXHJcbiAgICAgIHNldFByb2R1Y3RzKHByZXZQcm9kdWN0cyA9PiBwcmV2UHJvZHVjdHMuZmlsdGVyKHAgPT4gcC5pZCAhPT0gaWQpKTtcclxuICAgICAgXHJcbiAgICAgIC8vIFVwZGF0ZSBjYXRlZ29yeSBjYWNoZVxyXG4gICAgICBpZiAocHJvZHVjdFRvUmVtb3ZlLmNhdGVnb3J5KSB7XHJcbiAgICAgICAgc2V0UHJvZHVjdHNCeUNhdGVnb3J5KHByZXYgPT4ge1xyXG4gICAgICAgICAgY29uc3QgdXBkYXRlZCA9IHsgLi4ucHJldiB9O1xyXG4gICAgICAgICAgaWYgKHVwZGF0ZWRbcHJvZHVjdFRvUmVtb3ZlLmNhdGVnb3J5XSkge1xyXG4gICAgICAgICAgICB1cGRhdGVkW3Byb2R1Y3RUb1JlbW92ZS5jYXRlZ29yeV0gPSB1cGRhdGVkW3Byb2R1Y3RUb1JlbW92ZS5jYXRlZ29yeV0uZmlsdGVyKFxyXG4gICAgICAgICAgICAgIHAgPT4gcC5pZCAhPT0gaWRcclxuICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIC8vIFJlbW92ZSBjYXRlZ29yeSBhcnJheSBpZiBlbXB0eVxyXG4gICAgICAgICAgICBpZiAodXBkYXRlZFtwcm9kdWN0VG9SZW1vdmUuY2F0ZWdvcnldLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgICAgICAgIGRlbGV0ZSB1cGRhdGVkW3Byb2R1Y3RUb1JlbW92ZS5jYXRlZ29yeV07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuICAgICAgICAgIHJldHVybiB1cGRhdGVkO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICB9XHJcbiAgICB9IGNhdGNoIChlcnI6IGFueSkge1xyXG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciByZW1vdmluZyBwcm9kdWN0OicsIGVycik7XHJcbiAgICAgIHNldEVycm9yKGVyci5tZXNzYWdlIHx8ICdGYWlsZWQgdG8gZGVsZXRlIHByb2R1Y3QnKTtcclxuICAgICAgdGhyb3cgZXJyO1xyXG4gICAgfVxyXG4gIH07XHJcblxyXG4gIC8vIFVwbG9hZCBhbiBpbWFnZSB0byBGaXJlYmFzZSBTdG9yYWdlXHJcbiAgY29uc3QgdXBsb2FkSW1hZ2UgPSBhc3luYyAoZmlsZTogRmlsZSk6IFByb21pc2U8c3RyaW5nPiA9PiB7XHJcbiAgICB0cnkge1xyXG4gICAgICBzZXRFcnJvcihudWxsKTtcclxuICAgICAgcmV0dXJuIGF3YWl0IGZpcmVzdG9yZUFQSS51cGxvYWRQcm9kdWN0SW1hZ2UoZmlsZSk7XHJcbiAgICB9IGNhdGNoIChlcnI6IGFueSkge1xyXG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciB1cGxvYWRpbmcgaW1hZ2U6JywgZXJyKTtcclxuICAgICAgc2V0RXJyb3IoZXJyLm1lc3NhZ2UgfHwgJ0ZhaWxlZCB0byB1cGxvYWQgaW1hZ2UnKTtcclxuICAgICAgdGhyb3cgZXJyO1xyXG4gICAgfVxyXG4gIH07XHJcblxyXG4gIC8vIE1hbnVhbCByZWZyZXNoIGZ1bmN0aW9uXHJcbiAgY29uc3QgcmVmcmVzaFByb2R1Y3RzID0gYXN5bmMgKCk6IFByb21pc2U8dm9pZD4gPT4ge1xyXG4gICAgYXdhaXQgZmV0Y2hQcm9kdWN0cygpO1xyXG4gIH07XHJcblxyXG4gIHJldHVybiAoXHJcbiAgICA8UHJvZHVjdENvbnRleHQuUHJvdmlkZXJcclxuICAgICAgdmFsdWU9e3tcclxuICAgICAgICBwcm9kdWN0cyxcclxuICAgICAgICBjYXRlZ29yaWVzLFxyXG4gICAgICAgIHByb2R1Y3RzQnlDYXRlZ29yeSxcclxuICAgICAgICBsb2FkaW5nLFxyXG4gICAgICAgIGVycm9yLFxyXG4gICAgICAgIGFkZE5ld1Byb2R1Y3QsXHJcbiAgICAgICAgdXBkYXRlRXhpc3RpbmdQcm9kdWN0LFxyXG4gICAgICAgIHJlbW92ZVByb2R1Y3QsXHJcbiAgICAgICAgdXBsb2FkSW1hZ2UsXHJcbiAgICAgICAgcmVmcmVzaFByb2R1Y3RzLFxyXG4gICAgICAgIGdldFByb2R1Y3RzSW5DYXRlZ29yeVxyXG4gICAgICB9fVxyXG4gICAgPlxyXG4gICAgICB7Y2hpbGRyZW59XHJcbiAgICA8L1Byb2R1Y3RDb250ZXh0LlByb3ZpZGVyPlxyXG4gICk7XHJcbn07ICJdLCJuYW1lcyI6WyJSZWFjdCIsImNyZWF0ZUNvbnRleHQiLCJ1c2VDb250ZXh0IiwidXNlU3RhdGUiLCJ1c2VFZmZlY3QiLCJ1c2VDYWxsYmFjayIsImZpcmVzdG9yZUFQSSIsIlByb2R1Y3RDb250ZXh0IiwidW5kZWZpbmVkIiwidXNlUHJvZHVjdHMiLCJjb250ZXh0IiwiRXJyb3IiLCJQcm9kdWN0UHJvdmlkZXIiLCJjaGlsZHJlbiIsInByb2R1Y3RzIiwic2V0UHJvZHVjdHMiLCJjYXRlZ29yaWVzIiwic2V0Q2F0ZWdvcmllcyIsInByb2R1Y3RzQnlDYXRlZ29yeSIsInNldFByb2R1Y3RzQnlDYXRlZ29yeSIsImxvYWRpbmciLCJzZXRMb2FkaW5nIiwiZXJyb3IiLCJzZXRFcnJvciIsIm9yZ2FuaXplUHJvZHVjdHNCeUNhdGVnb3J5IiwiYWxsUHJvZHVjdHMiLCJieUNhdGVnb3J5IiwiZm9yRWFjaCIsInByb2R1Y3QiLCJjYXRlZ29yeSIsInB1c2giLCJmZXRjaFByb2R1Y3RzIiwiZmV0Y2hlZFByb2R1Y3RzIiwiZ2V0QWxsUHJvZHVjdHMiLCJlcnIiLCJjb25zb2xlIiwibWVzc2FnZSIsImdldFByb2R1Y3RzSW5DYXRlZ29yeSIsImFkZE5ld1Byb2R1Y3QiLCJuZXdQcm9kdWN0IiwiYWRkUHJvZHVjdCIsInByZXZQcm9kdWN0cyIsInByZXYiLCJ1cGRhdGVkIiwidXBkYXRlRXhpc3RpbmdQcm9kdWN0IiwiaWQiLCJ1cGRhdGVzIiwiZXhpc3RpbmdQcm9kdWN0IiwiZmluZCIsInAiLCJ1cGRhdGVQcm9kdWN0IiwidXBkYXRlZFByb2R1Y3QiLCJtYXAiLCJyZW1vdmVQcm9kdWN0IiwicHJvZHVjdFRvUmVtb3ZlIiwiZGVsZXRlUHJvZHVjdCIsImZpbHRlciIsImxlbmd0aCIsInVwbG9hZEltYWdlIiwiZmlsZSIsInVwbG9hZFByb2R1Y3RJbWFnZSIsInJlZnJlc2hQcm9kdWN0cyIsIlByb3ZpZGVyIiwidmFsdWUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./context/ProductContext.tsx\n"));

/***/ }),

/***/ "./utils/firestore.ts":
/*!****************************!*\
  !*** ./utils/firestore.ts ***!
  \****************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   addProduct: function() { return /* binding */ addProduct; },\n/* harmony export */   db: function() { return /* binding */ db; },\n/* harmony export */   deleteProduct: function() { return /* binding */ deleteProduct; },\n/* harmony export */   getAllCategories: function() { return /* binding */ getAllCategories; },\n/* harmony export */   getAllProducts: function() { return /* binding */ getAllProducts; },\n/* harmony export */   getProductById: function() { return /* binding */ getProductById; },\n/* harmony export */   getProductsByCategory: function() { return /* binding */ getProductsByCategory; },\n/* harmony export */   storage: function() { return /* binding */ storage; },\n/* harmony export */   updateProduct: function() { return /* binding */ updateProduct; },\n/* harmony export */   uploadProductImage: function() { return /* binding */ uploadProductImage; }\n/* harmony export */ });\n/* harmony import */ var _firebase__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./firebase */ \"./utils/firebase.ts\");\n/* harmony import */ var firebase_firestore__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! firebase/firestore */ \"./node_modules/firebase/firestore/dist/esm/index.esm.js\");\n/* harmony import */ var firebase_storage__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! firebase/storage */ \"./node_modules/firebase/storage/dist/esm/index.esm.js\");\n\n\n\n// Initialize Firestore\nconst db = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.getFirestore)(_firebase__WEBPACK_IMPORTED_MODULE_0__.app);\n// Initialize Storage\nconst storage = (0,firebase_storage__WEBPACK_IMPORTED_MODULE_2__.getStorage)(_firebase__WEBPACK_IMPORTED_MODULE_0__.app);\n// Collection references\nconst productsCollection = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.collection)(db, \"products\");\nconst categoriesCollection = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.collection)(db, \"categories\");\n// Validate product data before saving\nconst validateProduct = (product)=>{\n    if (!product.name || typeof product.name !== \"string\") {\n        return \"Product name is required\";\n    }\n    if (!product.price || isNaN(Number(product.price))) {\n        return \"Valid product price is required\";\n    }\n    if (!product.category || typeof product.category !== \"string\") {\n        return \"Product category is required\";\n    }\n    if (!product.image || typeof product.image !== \"string\") {\n        return \"Product image is required\";\n    }\n    return null; // No errors\n};\n// Clean product data for Firestore\nconst cleanProductData = (product)=>{\n    const cleanedProduct = {};\n    Object.entries(product).forEach((param)=>{\n        let [key, value] = param;\n        if (value !== undefined && value !== null) {\n            // Handle specific field types\n            if (key === \"price\" || key === \"originalPrice\" || key === \"stock\") {\n                cleanedProduct[key] = Number(value);\n            } else if (key === \"sizes\" && typeof value === \"string\") {\n                cleanedProduct[key] = value.split(\",\").map((s)=>s.trim()).filter(Boolean);\n            } else if (key === \"featured\" && typeof value === \"string\") {\n                cleanedProduct[key] = value === \"true\";\n            } else {\n                cleanedProduct[key] = value;\n            }\n        }\n    });\n    // Add creation timestamp\n    cleanedProduct.createdAt = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.serverTimestamp)();\n    cleanedProduct.updatedAt = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.serverTimestamp)();\n    return cleanedProduct;\n};\n// Get all products\nconst getAllProducts = async ()=>{\n    try {\n        console.log(\"Fetching all products from Firestore\");\n        const snapshot = await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.getDocs)(productsCollection);\n        const products = snapshot.docs.map((doc)=>({\n                id: doc.id,\n                ...doc.data()\n            }));\n        console.log(\"Retrieved \".concat(products.length, \" products from Firestore\"));\n        return products;\n    } catch (error) {\n        console.error(\"Error getting products from Firestore:\", error);\n        throw new Error(\"Failed to fetch products\");\n    }\n};\n// Get products by category\nconst getProductsByCategory = async (category)=>{\n    try {\n        const q = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.query)(productsCollection, (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.where)(\"category\", \"==\", category));\n        const snapshot = await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.getDocs)(q);\n        return snapshot.docs.map((doc)=>({\n                id: doc.id,\n                ...doc.data()\n            }));\n    } catch (error) {\n        console.error(\"Error getting \".concat(category, \" products:\"), error);\n        throw new Error(\"Failed to fetch \".concat(category, \" products\"));\n    }\n};\n// Get product by ID\nconst getProductById = async (id)=>{\n    try {\n        const productDoc = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.doc)(db, \"products\", id);\n        const snapshot = await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.getDoc)(productDoc);\n        if (snapshot.exists()) {\n            return {\n                id: snapshot.id,\n                ...snapshot.data()\n            };\n        }\n        return null;\n    } catch (error) {\n        console.error(\"Error getting product:\", error);\n        throw new Error(\"Failed to fetch product details\");\n    }\n};\n// Upload image to Firebase Storage\nconst uploadProductImage = async (file)=>{\n    try {\n        // Create a unique filename\n        const timestamp = new Date().getTime();\n        const fileName = \"product_\".concat(timestamp, \"_\").concat(file.name.replace(/[^a-zA-Z0-9.]/g, \"_\"));\n        // Create a reference to the file in storage\n        const storageRef = (0,firebase_storage__WEBPACK_IMPORTED_MODULE_2__.ref)(storage, \"product_images/\".concat(fileName));\n        // Upload the file\n        await (0,firebase_storage__WEBPACK_IMPORTED_MODULE_2__.uploadBytes)(storageRef, file);\n        // Get the download URL\n        const downloadURL = await (0,firebase_storage__WEBPACK_IMPORTED_MODULE_2__.getDownloadURL)(storageRef);\n        return downloadURL;\n    } catch (error) {\n        console.error(\"Error uploading image:\", error);\n        throw new Error(\"Failed to upload product image\");\n    }\n};\n// Add a new product with transaction for category tracking\nconst addProduct = async (product)=>{\n    try {\n        console.log(\"Adding product to Firestore:\", product);\n        // Validate product data\n        const validationError = validateProduct(product);\n        if (validationError) {\n            throw new Error(validationError);\n        }\n        // Clean the product data for Firestore\n        const cleanedProduct = cleanProductData(product);\n        console.log(\"Cleaned product data for Firestore:\", cleanedProduct);\n        // Use transaction to add product and update category data\n        const newProduct = await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.runTransaction)(db, async (transaction)=>{\n            // Add the product document\n            const docRef = await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.addDoc)(productsCollection, cleanedProduct);\n            const newProductWithId = {\n                id: docRef.id,\n                ...cleanedProduct\n            };\n            // Update or create category count\n            const categoryRef = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.doc)(categoriesCollection, cleanedProduct.category);\n            const categoryDoc = await transaction.get(categoryRef);\n            if (categoryDoc.exists()) {\n                // Update existing category\n                transaction.update(categoryRef, {\n                    count: (categoryDoc.data().count || 0) + 1,\n                    updatedAt: (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.serverTimestamp)()\n                });\n            } else {\n                // Create new category\n                transaction.set(categoryRef, {\n                    id: cleanedProduct.category,\n                    name: cleanedProduct.category.charAt(0).toUpperCase() + cleanedProduct.category.slice(1),\n                    count: 1,\n                    createdAt: (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.serverTimestamp)(),\n                    updatedAt: (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.serverTimestamp)()\n                });\n            }\n            return newProductWithId;\n        });\n        console.log(\"Product added successfully with ID:\", newProduct.id);\n        return newProduct;\n    } catch (error) {\n        console.error(\"Error adding product to Firestore:\", error);\n        throw error;\n    }\n};\n// Update a product\nconst updateProduct = async (id, product)=>{\n    try {\n        const productDoc = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.doc)(db, \"products\", id);\n        // Get existing product to check if category is changing\n        const existingProductSnap = await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.getDoc)(productDoc);\n        if (!existingProductSnap.exists()) {\n            throw new Error(\"Product not found\");\n        }\n        const existingProduct = existingProductSnap.data();\n        const cleanedUpdates = cleanProductData(product);\n        // Always update the timestamp when modified\n        cleanedUpdates.updatedAt = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.serverTimestamp)();\n        await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.runTransaction)(db, async (transaction)=>{\n            // Update product document\n            transaction.update(productDoc, cleanedUpdates);\n            // If category changed, update both old and new category counts\n            if (product.category && existingProduct.category !== product.category) {\n                // Decrease old category count\n                const oldCategoryRef = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.doc)(categoriesCollection, existingProduct.category);\n                const oldCategoryDoc = await transaction.get(oldCategoryRef);\n                if (oldCategoryDoc.exists()) {\n                    const oldCount = oldCategoryDoc.data().count || 0;\n                    if (oldCount > 1) {\n                        transaction.update(oldCategoryRef, {\n                            count: oldCount - 1,\n                            updatedAt: (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.serverTimestamp)()\n                        });\n                    } else {\n                        // Delete category if it will be empty\n                        transaction.delete(oldCategoryRef);\n                    }\n                }\n                // Increase new category count\n                const newCategoryRef = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.doc)(categoriesCollection, product.category);\n                const newCategoryDoc = await transaction.get(newCategoryRef);\n                if (newCategoryDoc.exists()) {\n                    transaction.update(newCategoryRef, {\n                        count: (newCategoryDoc.data().count || 0) + 1,\n                        updatedAt: (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.serverTimestamp)()\n                    });\n                } else {\n                    transaction.set(newCategoryRef, {\n                        id: product.category,\n                        name: product.category.charAt(0).toUpperCase() + product.category.slice(1),\n                        count: 1,\n                        createdAt: (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.serverTimestamp)(),\n                        updatedAt: (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.serverTimestamp)()\n                    });\n                }\n            }\n        });\n    } catch (error) {\n        console.error(\"Error updating product:\", error);\n        throw new Error(\"Failed to update product\");\n    }\n};\n// Delete a product\nconst deleteProduct = async (id)=>{\n    try {\n        const productDoc = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.doc)(db, \"products\", id);\n        // Get product to find its category\n        const productSnap = await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.getDoc)(productDoc);\n        if (!productSnap.exists()) {\n            throw new Error(\"Product not found\");\n        }\n        const productData = productSnap.data();\n        await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.runTransaction)(db, async (transaction)=>{\n            // Delete product\n            transaction.delete(productDoc);\n            // Update category count\n            if (productData.category) {\n                const categoryRef = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.doc)(categoriesCollection, productData.category);\n                const categoryDoc = await transaction.get(categoryRef);\n                if (categoryDoc.exists()) {\n                    const count = categoryDoc.data().count || 0;\n                    if (count > 1) {\n                        transaction.update(categoryRef, {\n                            count: count - 1,\n                            updatedAt: (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.serverTimestamp)()\n                        });\n                    } else {\n                        // Delete category if it will be empty\n                        transaction.delete(categoryRef);\n                    }\n                }\n            }\n        });\n    } catch (error) {\n        console.error(\"Error deleting product:\", error);\n        throw new Error(\"Failed to delete product\");\n    }\n};\n// Get all categories with product counts\nconst getAllCategories = async ()=>{\n    try {\n        const snapshot = await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.getDocs)(categoriesCollection);\n        return snapshot.docs.map((doc)=>doc.data());\n    } catch (error) {\n        console.error(\"Error getting categories:\", error);\n        throw new Error(\"Failed to fetch categories\");\n    }\n};\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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O0lBQzFDLEVBQUUsT0FBT0UsT0FBTztRQUNkUixRQUFRUSxLQUFLLENBQUMsNkJBQTZCQTtRQUMzQyxNQUFNLElBQUlDLE1BQU07SUFDbEI7QUFDRixFQUFFIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL3V0aWxzL2ZpcmVzdG9yZS50cz9hYTAwIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGFwcCB9IGZyb20gJy4vZmlyZWJhc2UnO1xyXG5pbXBvcnQgeyBnZXRGaXJlc3RvcmUsIGNvbGxlY3Rpb24sIGdldERvY3MsIGRvYywgZ2V0RG9jLCBhZGREb2MsIHVwZGF0ZURvYywgZGVsZXRlRG9jLCBxdWVyeSwgd2hlcmUsIHJ1blRyYW5zYWN0aW9uLCBzZXJ2ZXJUaW1lc3RhbXAsIERvY3VtZW50UmVmZXJlbmNlIH0gZnJvbSAnZmlyZWJhc2UvZmlyZXN0b3JlJztcclxuaW1wb3J0IHsgZ2V0U3RvcmFnZSwgcmVmLCB1cGxvYWRCeXRlcywgZ2V0RG93bmxvYWRVUkwgfSBmcm9tICdmaXJlYmFzZS9zdG9yYWdlJztcclxuaW1wb3J0IHsgUHJvZHVjdCB9IGZyb20gJy4uL2RhdGEvcHJvZHVjdHMnO1xyXG5cclxuLy8gSW5pdGlhbGl6ZSBGaXJlc3RvcmVcclxuZXhwb3J0IGNvbnN0IGRiID0gZ2V0RmlyZXN0b3JlKGFwcCk7XHJcblxyXG4vLyBJbml0aWFsaXplIFN0b3JhZ2VcclxuZXhwb3J0IGNvbnN0IHN0b3JhZ2UgPSBnZXRTdG9yYWdlKGFwcCk7XHJcblxyXG4vLyBDb2xsZWN0aW9uIHJlZmVyZW5jZXNcclxuY29uc3QgcHJvZHVjdHNDb2xsZWN0aW9uID0gY29sbGVjdGlvbihkYiwgJ3Byb2R1Y3RzJyk7XHJcbmNvbnN0IGNhdGVnb3JpZXNDb2xsZWN0aW9uID0gY29sbGVjdGlvbihkYiwgJ2NhdGVnb3JpZXMnKTtcclxuXHJcbi8vIFZhbGlkYXRlIHByb2R1Y3QgZGF0YSBiZWZvcmUgc2F2aW5nXHJcbmNvbnN0IHZhbGlkYXRlUHJvZHVjdCA9IChwcm9kdWN0OiBQYXJ0aWFsPFByb2R1Y3Q+KTogc3RyaW5nIHwgbnVsbCA9PiB7XHJcbiAgaWYgKCFwcm9kdWN0Lm5hbWUgfHwgdHlwZW9mIHByb2R1Y3QubmFtZSAhPT0gJ3N0cmluZycpIHtcclxuICAgIHJldHVybiAnUHJvZHVjdCBuYW1lIGlzIHJlcXVpcmVkJztcclxuICB9XHJcbiAgXHJcbiAgaWYgKCFwcm9kdWN0LnByaWNlIHx8IGlzTmFOKE51bWJlcihwcm9kdWN0LnByaWNlKSkpIHtcclxuICAgIHJldHVybiAnVmFsaWQgcHJvZHVjdCBwcmljZSBpcyByZXF1aXJlZCc7XHJcbiAgfVxyXG4gIFxyXG4gIGlmICghcHJvZHVjdC5jYXRlZ29yeSB8fCB0eXBlb2YgcHJvZHVjdC5jYXRlZ29yeSAhPT0gJ3N0cmluZycpIHtcclxuICAgIHJldHVybiAnUHJvZHVjdCBjYXRlZ29yeSBpcyByZXF1aXJlZCc7XHJcbiAgfVxyXG4gIFxyXG4gIGlmICghcHJvZHVjdC5pbWFnZSB8fCB0eXBlb2YgcHJvZHVjdC5pbWFnZSAhPT0gJ3N0cmluZycpIHtcclxuICAgIHJldHVybiAnUHJvZHVjdCBpbWFnZSBpcyByZXF1aXJlZCc7XHJcbiAgfVxyXG4gIFxyXG4gIHJldHVybiBudWxsOyAvLyBObyBlcnJvcnNcclxufTtcclxuXHJcbi8vIENsZWFuIHByb2R1Y3QgZGF0YSBmb3IgRmlyZXN0b3JlXHJcbmNvbnN0IGNsZWFuUHJvZHVjdERhdGEgPSAocHJvZHVjdDogUmVjb3JkPHN0cmluZywgYW55Pik6IFJlY29yZDxzdHJpbmcsIGFueT4gPT4ge1xyXG4gIGNvbnN0IGNsZWFuZWRQcm9kdWN0OiBSZWNvcmQ8c3RyaW5nLCBhbnk+ID0ge307XHJcbiAgXHJcbiAgT2JqZWN0LmVudHJpZXMocHJvZHVjdCkuZm9yRWFjaCgoW2tleSwgdmFsdWVdKSA9PiB7XHJcbiAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZCAmJiB2YWx1ZSAhPT0gbnVsbCkge1xyXG4gICAgICAvLyBIYW5kbGUgc3BlY2lmaWMgZmllbGQgdHlwZXNcclxuICAgICAgaWYgKGtleSA9PT0gJ3ByaWNlJyB8fCBrZXkgPT09ICdvcmlnaW5hbFByaWNlJyB8fCBrZXkgPT09ICdzdG9jaycpIHtcclxuICAgICAgICBjbGVhbmVkUHJvZHVjdFtrZXldID0gTnVtYmVyKHZhbHVlKTtcclxuICAgICAgfSBlbHNlIGlmIChrZXkgPT09ICdzaXplcycgJiYgdHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xyXG4gICAgICAgIGNsZWFuZWRQcm9kdWN0W2tleV0gPSB2YWx1ZS5zcGxpdCgnLCcpLm1hcCgoczogc3RyaW5nKSA9PiBzLnRyaW0oKSkuZmlsdGVyKEJvb2xlYW4pO1xyXG4gICAgICB9IGVsc2UgaWYgKGtleSA9PT0gJ2ZlYXR1cmVkJyAmJiB0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgY2xlYW5lZFByb2R1Y3Rba2V5XSA9IHZhbHVlID09PSAndHJ1ZSc7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgY2xlYW5lZFByb2R1Y3Rba2V5XSA9IHZhbHVlO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfSk7XHJcbiAgXHJcbiAgLy8gQWRkIGNyZWF0aW9uIHRpbWVzdGFtcFxyXG4gIGNsZWFuZWRQcm9kdWN0LmNyZWF0ZWRBdCA9IHNlcnZlclRpbWVzdGFtcCgpO1xyXG4gIGNsZWFuZWRQcm9kdWN0LnVwZGF0ZWRBdCA9IHNlcnZlclRpbWVzdGFtcCgpO1xyXG4gIFxyXG4gIHJldHVybiBjbGVhbmVkUHJvZHVjdDtcclxufTtcclxuXHJcbi8vIEdldCBhbGwgcHJvZHVjdHNcclxuZXhwb3J0IGNvbnN0IGdldEFsbFByb2R1Y3RzID0gYXN5bmMgKCk6IFByb21pc2U8UHJvZHVjdFtdPiA9PiB7XHJcbiAgdHJ5IHtcclxuICAgIGNvbnNvbGUubG9nKCdGZXRjaGluZyBhbGwgcHJvZHVjdHMgZnJvbSBGaXJlc3RvcmUnKTtcclxuICAgIGNvbnN0IHNuYXBzaG90ID0gYXdhaXQgZ2V0RG9jcyhwcm9kdWN0c0NvbGxlY3Rpb24pO1xyXG4gICAgY29uc3QgcHJvZHVjdHMgPSBzbmFwc2hvdC5kb2NzLm1hcChkb2MgPT4gKHtcclxuICAgICAgaWQ6IGRvYy5pZCxcclxuICAgICAgLi4uZG9jLmRhdGEoKVxyXG4gICAgfSBhcyBQcm9kdWN0KSk7XHJcbiAgICBjb25zb2xlLmxvZyhgUmV0cmlldmVkICR7cHJvZHVjdHMubGVuZ3RofSBwcm9kdWN0cyBmcm9tIEZpcmVzdG9yZWApO1xyXG4gICAgcmV0dXJuIHByb2R1Y3RzO1xyXG4gIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICBjb25zb2xlLmVycm9yKCdFcnJvciBnZXR0aW5nIHByb2R1Y3RzIGZyb20gRmlyZXN0b3JlOicsIGVycm9yKTtcclxuICAgIHRocm93IG5ldyBFcnJvcignRmFpbGVkIHRvIGZldGNoIHByb2R1Y3RzJyk7XHJcbiAgfVxyXG59O1xyXG5cclxuLy8gR2V0IHByb2R1Y3RzIGJ5IGNhdGVnb3J5XHJcbmV4cG9ydCBjb25zdCBnZXRQcm9kdWN0c0J5Q2F0ZWdvcnkgPSBhc3luYyAoY2F0ZWdvcnk6IHN0cmluZyk6IFByb21pc2U8UHJvZHVjdFtdPiA9PiB7XHJcbiAgdHJ5IHtcclxuICAgIGNvbnN0IHEgPSBxdWVyeShwcm9kdWN0c0NvbGxlY3Rpb24sIHdoZXJlKCdjYXRlZ29yeScsICc9PScsIGNhdGVnb3J5KSk7XHJcbiAgICBjb25zdCBzbmFwc2hvdCA9IGF3YWl0IGdldERvY3MocSk7XHJcbiAgICByZXR1cm4gc25hcHNob3QuZG9jcy5tYXAoZG9jID0+ICh7XHJcbiAgICAgIGlkOiBkb2MuaWQsXHJcbiAgICAgIC4uLmRvYy5kYXRhKClcclxuICAgIH0gYXMgUHJvZHVjdCkpO1xyXG4gIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICBjb25zb2xlLmVycm9yKGBFcnJvciBnZXR0aW5nICR7Y2F0ZWdvcnl9IHByb2R1Y3RzOmAsIGVycm9yKTtcclxuICAgIHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIGZldGNoICR7Y2F0ZWdvcnl9IHByb2R1Y3RzYCk7XHJcbiAgfVxyXG59O1xyXG5cclxuLy8gR2V0IHByb2R1Y3QgYnkgSURcclxuZXhwb3J0IGNvbnN0IGdldFByb2R1Y3RCeUlkID0gYXN5bmMgKGlkOiBzdHJpbmcpOiBQcm9taXNlPFByb2R1Y3QgfCBudWxsPiA9PiB7XHJcbiAgdHJ5IHtcclxuICAgIGNvbnN0IHByb2R1Y3REb2MgPSBkb2MoZGIsICdwcm9kdWN0cycsIGlkKTtcclxuICAgIGNvbnN0IHNuYXBzaG90ID0gYXdhaXQgZ2V0RG9jKHByb2R1Y3REb2MpO1xyXG4gICAgXHJcbiAgICBpZiAoc25hcHNob3QuZXhpc3RzKCkpIHtcclxuICAgICAgcmV0dXJuIHtcclxuICAgICAgICBpZDogc25hcHNob3QuaWQsXHJcbiAgICAgICAgLi4uc25hcHNob3QuZGF0YSgpXHJcbiAgICAgIH0gYXMgUHJvZHVjdDtcclxuICAgIH1cclxuICAgIHJldHVybiBudWxsO1xyXG4gIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICBjb25zb2xlLmVycm9yKCdFcnJvciBnZXR0aW5nIHByb2R1Y3Q6JywgZXJyb3IpO1xyXG4gICAgdGhyb3cgbmV3IEVycm9yKCdGYWlsZWQgdG8gZmV0Y2ggcHJvZHVjdCBkZXRhaWxzJyk7XHJcbiAgfVxyXG59O1xyXG5cclxuLy8gVXBsb2FkIGltYWdlIHRvIEZpcmViYXNlIFN0b3JhZ2VcclxuZXhwb3J0IGNvbnN0IHVwbG9hZFByb2R1Y3RJbWFnZSA9IGFzeW5jIChmaWxlOiBGaWxlKTogUHJvbWlzZTxzdHJpbmc+ID0+IHtcclxuICB0cnkge1xyXG4gICAgLy8gQ3JlYXRlIGEgdW5pcXVlIGZpbGVuYW1lXHJcbiAgICBjb25zdCB0aW1lc3RhbXAgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcclxuICAgIGNvbnN0IGZpbGVOYW1lID0gYHByb2R1Y3RfJHt0aW1lc3RhbXB9XyR7ZmlsZS5uYW1lLnJlcGxhY2UoL1teYS16QS1aMC05Ll0vZywgJ18nKX1gO1xyXG4gICAgXHJcbiAgICAvLyBDcmVhdGUgYSByZWZlcmVuY2UgdG8gdGhlIGZpbGUgaW4gc3RvcmFnZVxyXG4gICAgY29uc3Qgc3RvcmFnZVJlZiA9IHJlZihzdG9yYWdlLCBgcHJvZHVjdF9pbWFnZXMvJHtmaWxlTmFtZX1gKTtcclxuICAgIFxyXG4gICAgLy8gVXBsb2FkIHRoZSBmaWxlXHJcbiAgICBhd2FpdCB1cGxvYWRCeXRlcyhzdG9yYWdlUmVmLCBmaWxlKTtcclxuICAgIFxyXG4gICAgLy8gR2V0IHRoZSBkb3dubG9hZCBVUkxcclxuICAgIGNvbnN0IGRvd25sb2FkVVJMID0gYXdhaXQgZ2V0RG93bmxvYWRVUkwoc3RvcmFnZVJlZik7XHJcbiAgICByZXR1cm4gZG93bmxvYWRVUkw7XHJcbiAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIHVwbG9hZGluZyBpbWFnZTonLCBlcnJvcik7XHJcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZhaWxlZCB0byB1cGxvYWQgcHJvZHVjdCBpbWFnZScpO1xyXG4gIH1cclxufTtcclxuXHJcbi8vIEFkZCBhIG5ldyBwcm9kdWN0IHdpdGggdHJhbnNhY3Rpb24gZm9yIGNhdGVnb3J5IHRyYWNraW5nXHJcbmV4cG9ydCBjb25zdCBhZGRQcm9kdWN0ID0gYXN5bmMgKHByb2R1Y3Q6IE9taXQ8UHJvZHVjdCwgJ2lkJz4pOiBQcm9taXNlPFByb2R1Y3Q+ID0+IHtcclxuICB0cnkge1xyXG4gICAgY29uc29sZS5sb2coJ0FkZGluZyBwcm9kdWN0IHRvIEZpcmVzdG9yZTonLCBwcm9kdWN0KTtcclxuICAgIFxyXG4gICAgLy8gVmFsaWRhdGUgcHJvZHVjdCBkYXRhXHJcbiAgICBjb25zdCB2YWxpZGF0aW9uRXJyb3IgPSB2YWxpZGF0ZVByb2R1Y3QocHJvZHVjdCk7XHJcbiAgICBpZiAodmFsaWRhdGlvbkVycm9yKSB7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcih2YWxpZGF0aW9uRXJyb3IpO1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICAvLyBDbGVhbiB0aGUgcHJvZHVjdCBkYXRhIGZvciBGaXJlc3RvcmVcclxuICAgIGNvbnN0IGNsZWFuZWRQcm9kdWN0ID0gY2xlYW5Qcm9kdWN0RGF0YShwcm9kdWN0KTtcclxuICAgIGNvbnNvbGUubG9nKCdDbGVhbmVkIHByb2R1Y3QgZGF0YSBmb3IgRmlyZXN0b3JlOicsIGNsZWFuZWRQcm9kdWN0KTtcclxuICAgIFxyXG4gICAgLy8gVXNlIHRyYW5zYWN0aW9uIHRvIGFkZCBwcm9kdWN0IGFuZCB1cGRhdGUgY2F0ZWdvcnkgZGF0YVxyXG4gICAgY29uc3QgbmV3UHJvZHVjdCA9IGF3YWl0IHJ1blRyYW5zYWN0aW9uKGRiLCBhc3luYyAodHJhbnNhY3Rpb24pID0+IHtcclxuICAgICAgLy8gQWRkIHRoZSBwcm9kdWN0IGRvY3VtZW50XHJcbiAgICAgIGNvbnN0IGRvY1JlZiA9IGF3YWl0IGFkZERvYyhwcm9kdWN0c0NvbGxlY3Rpb24sIGNsZWFuZWRQcm9kdWN0KTtcclxuICAgICAgY29uc3QgbmV3UHJvZHVjdFdpdGhJZCA9IHsgaWQ6IGRvY1JlZi5pZCwgLi4uY2xlYW5lZFByb2R1Y3QgfTtcclxuICAgICAgXHJcbiAgICAgIC8vIFVwZGF0ZSBvciBjcmVhdGUgY2F0ZWdvcnkgY291bnRcclxuICAgICAgY29uc3QgY2F0ZWdvcnlSZWYgPSBkb2MoY2F0ZWdvcmllc0NvbGxlY3Rpb24sIGNsZWFuZWRQcm9kdWN0LmNhdGVnb3J5KTtcclxuICAgICAgY29uc3QgY2F0ZWdvcnlEb2MgPSBhd2FpdCB0cmFuc2FjdGlvbi5nZXQoY2F0ZWdvcnlSZWYpO1xyXG4gICAgICBcclxuICAgICAgaWYgKGNhdGVnb3J5RG9jLmV4aXN0cygpKSB7XHJcbiAgICAgICAgLy8gVXBkYXRlIGV4aXN0aW5nIGNhdGVnb3J5XHJcbiAgICAgICAgdHJhbnNhY3Rpb24udXBkYXRlKGNhdGVnb3J5UmVmLCB7XHJcbiAgICAgICAgICBjb3VudDogKGNhdGVnb3J5RG9jLmRhdGEoKS5jb3VudCB8fCAwKSArIDEsXHJcbiAgICAgICAgICB1cGRhdGVkQXQ6IHNlcnZlclRpbWVzdGFtcCgpXHJcbiAgICAgICAgfSk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgLy8gQ3JlYXRlIG5ldyBjYXRlZ29yeVxyXG4gICAgICAgIHRyYW5zYWN0aW9uLnNldChjYXRlZ29yeVJlZiwge1xyXG4gICAgICAgICAgaWQ6IGNsZWFuZWRQcm9kdWN0LmNhdGVnb3J5LFxyXG4gICAgICAgICAgbmFtZTogY2xlYW5lZFByb2R1Y3QuY2F0ZWdvcnkuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBjbGVhbmVkUHJvZHVjdC5jYXRlZ29yeS5zbGljZSgxKSxcclxuICAgICAgICAgIGNvdW50OiAxLFxyXG4gICAgICAgICAgY3JlYXRlZEF0OiBzZXJ2ZXJUaW1lc3RhbXAoKSxcclxuICAgICAgICAgIHVwZGF0ZWRBdDogc2VydmVyVGltZXN0YW1wKClcclxuICAgICAgICB9KTtcclxuICAgICAgfVxyXG4gICAgICBcclxuICAgICAgcmV0dXJuIG5ld1Byb2R1Y3RXaXRoSWQ7XHJcbiAgICB9KTtcclxuICAgIFxyXG4gICAgY29uc29sZS5sb2coJ1Byb2R1Y3QgYWRkZWQgc3VjY2Vzc2Z1bGx5IHdpdGggSUQ6JywgbmV3UHJvZHVjdC5pZCk7XHJcbiAgICByZXR1cm4gbmV3UHJvZHVjdCBhcyBQcm9kdWN0O1xyXG4gIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICBjb25zb2xlLmVycm9yKCdFcnJvciBhZGRpbmcgcHJvZHVjdCB0byBGaXJlc3RvcmU6JywgZXJyb3IpO1xyXG4gICAgdGhyb3cgZXJyb3I7XHJcbiAgfVxyXG59O1xyXG5cclxuLy8gVXBkYXRlIGEgcHJvZHVjdFxyXG5leHBvcnQgY29uc3QgdXBkYXRlUHJvZHVjdCA9IGFzeW5jIChpZDogc3RyaW5nLCBwcm9kdWN0OiBQYXJ0aWFsPFByb2R1Y3Q+KTogUHJvbWlzZTx2b2lkPiA9PiB7XHJcbiAgdHJ5IHtcclxuICAgIGNvbnN0IHByb2R1Y3REb2MgPSBkb2MoZGIsICdwcm9kdWN0cycsIGlkKTtcclxuICAgIFxyXG4gICAgLy8gR2V0IGV4aXN0aW5nIHByb2R1Y3QgdG8gY2hlY2sgaWYgY2F0ZWdvcnkgaXMgY2hhbmdpbmdcclxuICAgIGNvbnN0IGV4aXN0aW5nUHJvZHVjdFNuYXAgPSBhd2FpdCBnZXREb2MocHJvZHVjdERvYyk7XHJcbiAgICBpZiAoIWV4aXN0aW5nUHJvZHVjdFNuYXAuZXhpc3RzKCkpIHtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdQcm9kdWN0IG5vdCBmb3VuZCcpO1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICBjb25zdCBleGlzdGluZ1Byb2R1Y3QgPSBleGlzdGluZ1Byb2R1Y3RTbmFwLmRhdGEoKTtcclxuICAgIGNvbnN0IGNsZWFuZWRVcGRhdGVzID0gY2xlYW5Qcm9kdWN0RGF0YShwcm9kdWN0KTtcclxuICAgIFxyXG4gICAgLy8gQWx3YXlzIHVwZGF0ZSB0aGUgdGltZXN0YW1wIHdoZW4gbW9kaWZpZWRcclxuICAgIGNsZWFuZWRVcGRhdGVzLnVwZGF0ZWRBdCA9IHNlcnZlclRpbWVzdGFtcCgpO1xyXG4gICAgXHJcbiAgICBhd2FpdCBydW5UcmFuc2FjdGlvbihkYiwgYXN5bmMgKHRyYW5zYWN0aW9uKSA9PiB7XHJcbiAgICAgIC8vIFVwZGF0ZSBwcm9kdWN0IGRvY3VtZW50XHJcbiAgICAgIHRyYW5zYWN0aW9uLnVwZGF0ZShwcm9kdWN0RG9jLCBjbGVhbmVkVXBkYXRlcyk7XHJcbiAgICAgIFxyXG4gICAgICAvLyBJZiBjYXRlZ29yeSBjaGFuZ2VkLCB1cGRhdGUgYm90aCBvbGQgYW5kIG5ldyBjYXRlZ29yeSBjb3VudHNcclxuICAgICAgaWYgKHByb2R1Y3QuY2F0ZWdvcnkgJiYgZXhpc3RpbmdQcm9kdWN0LmNhdGVnb3J5ICE9PSBwcm9kdWN0LmNhdGVnb3J5KSB7XHJcbiAgICAgICAgLy8gRGVjcmVhc2Ugb2xkIGNhdGVnb3J5IGNvdW50XHJcbiAgICAgICAgY29uc3Qgb2xkQ2F0ZWdvcnlSZWYgPSBkb2MoY2F0ZWdvcmllc0NvbGxlY3Rpb24sIGV4aXN0aW5nUHJvZHVjdC5jYXRlZ29yeSk7XHJcbiAgICAgICAgY29uc3Qgb2xkQ2F0ZWdvcnlEb2MgPSBhd2FpdCB0cmFuc2FjdGlvbi5nZXQob2xkQ2F0ZWdvcnlSZWYpO1xyXG4gICAgICAgIFxyXG4gICAgICAgIGlmIChvbGRDYXRlZ29yeURvYy5leGlzdHMoKSkge1xyXG4gICAgICAgICAgY29uc3Qgb2xkQ291bnQgPSBvbGRDYXRlZ29yeURvYy5kYXRhKCkuY291bnQgfHwgMDtcclxuICAgICAgICAgIGlmIChvbGRDb3VudCA+IDEpIHtcclxuICAgICAgICAgICAgdHJhbnNhY3Rpb24udXBkYXRlKG9sZENhdGVnb3J5UmVmLCB7IFxyXG4gICAgICAgICAgICAgIGNvdW50OiBvbGRDb3VudCAtIDEsXHJcbiAgICAgICAgICAgICAgdXBkYXRlZEF0OiBzZXJ2ZXJUaW1lc3RhbXAoKVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIC8vIERlbGV0ZSBjYXRlZ29yeSBpZiBpdCB3aWxsIGJlIGVtcHR5XHJcbiAgICAgICAgICAgIHRyYW5zYWN0aW9uLmRlbGV0ZShvbGRDYXRlZ29yeVJlZik7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIFxyXG4gICAgICAgIC8vIEluY3JlYXNlIG5ldyBjYXRlZ29yeSBjb3VudFxyXG4gICAgICAgIGNvbnN0IG5ld0NhdGVnb3J5UmVmID0gZG9jKGNhdGVnb3JpZXNDb2xsZWN0aW9uLCBwcm9kdWN0LmNhdGVnb3J5KTtcclxuICAgICAgICBjb25zdCBuZXdDYXRlZ29yeURvYyA9IGF3YWl0IHRyYW5zYWN0aW9uLmdldChuZXdDYXRlZ29yeVJlZik7XHJcbiAgICAgICAgXHJcbiAgICAgICAgaWYgKG5ld0NhdGVnb3J5RG9jLmV4aXN0cygpKSB7XHJcbiAgICAgICAgICB0cmFuc2FjdGlvbi51cGRhdGUobmV3Q2F0ZWdvcnlSZWYsIHsgXHJcbiAgICAgICAgICAgIGNvdW50OiAobmV3Q2F0ZWdvcnlEb2MuZGF0YSgpLmNvdW50IHx8IDApICsgMSxcclxuICAgICAgICAgICAgdXBkYXRlZEF0OiBzZXJ2ZXJUaW1lc3RhbXAoKVxyXG4gICAgICAgICAgfSk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIHRyYW5zYWN0aW9uLnNldChuZXdDYXRlZ29yeVJlZiwge1xyXG4gICAgICAgICAgICBpZDogcHJvZHVjdC5jYXRlZ29yeSxcclxuICAgICAgICAgICAgbmFtZTogcHJvZHVjdC5jYXRlZ29yeS5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIHByb2R1Y3QuY2F0ZWdvcnkuc2xpY2UoMSksXHJcbiAgICAgICAgICAgIGNvdW50OiAxLFxyXG4gICAgICAgICAgICBjcmVhdGVkQXQ6IHNlcnZlclRpbWVzdGFtcCgpLFxyXG4gICAgICAgICAgICB1cGRhdGVkQXQ6IHNlcnZlclRpbWVzdGFtcCgpXHJcbiAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG4gICAgXHJcbiAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIHVwZGF0aW5nIHByb2R1Y3Q6JywgZXJyb3IpO1xyXG4gICAgdGhyb3cgbmV3IEVycm9yKCdGYWlsZWQgdG8gdXBkYXRlIHByb2R1Y3QnKTtcclxuICB9XHJcbn07XHJcblxyXG4vLyBEZWxldGUgYSBwcm9kdWN0XHJcbmV4cG9ydCBjb25zdCBkZWxldGVQcm9kdWN0ID0gYXN5bmMgKGlkOiBzdHJpbmcpOiBQcm9taXNlPHZvaWQ+ID0+IHtcclxuICB0cnkge1xyXG4gICAgY29uc3QgcHJvZHVjdERvYyA9IGRvYyhkYiwgJ3Byb2R1Y3RzJywgaWQpO1xyXG4gICAgXHJcbiAgICAvLyBHZXQgcHJvZHVjdCB0byBmaW5kIGl0cyBjYXRlZ29yeVxyXG4gICAgY29uc3QgcHJvZHVjdFNuYXAgPSBhd2FpdCBnZXREb2MocHJvZHVjdERvYyk7XHJcbiAgICBpZiAoIXByb2R1Y3RTbmFwLmV4aXN0cygpKSB7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcignUHJvZHVjdCBub3QgZm91bmQnKTtcclxuICAgIH1cclxuICAgIFxyXG4gICAgY29uc3QgcHJvZHVjdERhdGEgPSBwcm9kdWN0U25hcC5kYXRhKCk7XHJcbiAgICBcclxuICAgIGF3YWl0IHJ1blRyYW5zYWN0aW9uKGRiLCBhc3luYyAodHJhbnNhY3Rpb24pID0+IHtcclxuICAgICAgLy8gRGVsZXRlIHByb2R1Y3RcclxuICAgICAgdHJhbnNhY3Rpb24uZGVsZXRlKHByb2R1Y3REb2MpO1xyXG4gICAgICBcclxuICAgICAgLy8gVXBkYXRlIGNhdGVnb3J5IGNvdW50XHJcbiAgICAgIGlmIChwcm9kdWN0RGF0YS5jYXRlZ29yeSkge1xyXG4gICAgICAgIGNvbnN0IGNhdGVnb3J5UmVmID0gZG9jKGNhdGVnb3JpZXNDb2xsZWN0aW9uLCBwcm9kdWN0RGF0YS5jYXRlZ29yeSk7XHJcbiAgICAgICAgY29uc3QgY2F0ZWdvcnlEb2MgPSBhd2FpdCB0cmFuc2FjdGlvbi5nZXQoY2F0ZWdvcnlSZWYpO1xyXG4gICAgICAgIFxyXG4gICAgICAgIGlmIChjYXRlZ29yeURvYy5leGlzdHMoKSkge1xyXG4gICAgICAgICAgY29uc3QgY291bnQgPSBjYXRlZ29yeURvYy5kYXRhKCkuY291bnQgfHwgMDtcclxuICAgICAgICAgIGlmIChjb3VudCA+IDEpIHtcclxuICAgICAgICAgICAgdHJhbnNhY3Rpb24udXBkYXRlKGNhdGVnb3J5UmVmLCB7IFxyXG4gICAgICAgICAgICAgIGNvdW50OiBjb3VudCAtIDEsXHJcbiAgICAgICAgICAgICAgdXBkYXRlZEF0OiBzZXJ2ZXJUaW1lc3RhbXAoKVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIC8vIERlbGV0ZSBjYXRlZ29yeSBpZiBpdCB3aWxsIGJlIGVtcHR5XHJcbiAgICAgICAgICAgIHRyYW5zYWN0aW9uLmRlbGV0ZShjYXRlZ29yeVJlZik7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9KTtcclxuICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgY29uc29sZS5lcnJvcignRXJyb3IgZGVsZXRpbmcgcHJvZHVjdDonLCBlcnJvcik7XHJcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZhaWxlZCB0byBkZWxldGUgcHJvZHVjdCcpO1xyXG4gIH1cclxufTtcclxuXHJcbi8vIEdldCBhbGwgY2F0ZWdvcmllcyB3aXRoIHByb2R1Y3QgY291bnRzXHJcbmV4cG9ydCBjb25zdCBnZXRBbGxDYXRlZ29yaWVzID0gYXN5bmMgKCkgPT4ge1xyXG4gIHRyeSB7XHJcbiAgICBjb25zdCBzbmFwc2hvdCA9IGF3YWl0IGdldERvY3MoY2F0ZWdvcmllc0NvbGxlY3Rpb24pO1xyXG4gICAgcmV0dXJuIHNuYXBzaG90LmRvY3MubWFwKGRvYyA9PiBkb2MuZGF0YSgpKTtcclxuICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgY29uc29sZS5lcnJvcignRXJyb3IgZ2V0dGluZyBjYXRlZ29yaWVzOicsIGVycm9yKTtcclxuICAgIHRocm93IG5ldyBFcnJvcignRmFpbGVkIHRvIGZldGNoIGNhdGVnb3JpZXMnKTtcclxuICB9XHJcbn07ICJdLCJuYW1lcyI6WyJhcHAiLCJnZXRGaXJlc3RvcmUiLCJjb2xsZWN0aW9uIiwiZ2V0RG9jcyIsImRvYyIsImdldERvYyIsImFkZERvYyIsInF1ZXJ5Iiwid2hlcmUiLCJydW5UcmFuc2FjdGlvbiIsInNlcnZlclRpbWVzdGFtcCIsImdldFN0b3JhZ2UiLCJyZWYiLCJ1cGxvYWRCeXRlcyIsImdldERvd25sb2FkVVJMIiwiZGIiLCJzdG9yYWdlIiwicHJvZHVjdHNDb2xsZWN0aW9uIiwiY2F0ZWdvcmllc0NvbGxlY3Rpb24iLCJ2YWxpZGF0ZVByb2R1Y3QiLCJwcm9kdWN0IiwibmFtZSIsInByaWNlIiwiaXNOYU4iLCJOdW1iZXIiLCJjYXRlZ29yeSIsImltYWdlIiwiY2xlYW5Qcm9kdWN0RGF0YSIsImNsZWFuZWRQcm9kdWN0IiwiT2JqZWN0IiwiZW50cmllcyIsImZvckVhY2giLCJrZXkiLCJ2YWx1ZSIsInVuZGVmaW5lZCIsInNwbGl0IiwibWFwIiwicyIsInRyaW0iLCJmaWx0ZXIiLCJCb29sZWFuIiwiY3JlYXRlZEF0IiwidXBkYXRlZEF0IiwiZ2V0QWxsUHJvZHVjdHMiLCJjb25zb2xlIiwibG9nIiwic25hcHNob3QiLCJwcm9kdWN0cyIsImRvY3MiLCJpZCIsImRhdGEiLCJsZW5ndGgiLCJlcnJvciIsIkVycm9yIiwiZ2V0UHJvZHVjdHNCeUNhdGVnb3J5IiwicSIsImdldFByb2R1Y3RCeUlkIiwicHJvZHVjdERvYyIsImV4aXN0cyIsInVwbG9hZFByb2R1Y3RJbWFnZSIsImZpbGUiLCJ0aW1lc3RhbXAiLCJEYXRlIiwiZ2V0VGltZSIsImZpbGVOYW1lIiwicmVwbGFjZSIsInN0b3JhZ2VSZWYiLCJkb3dubG9hZFVSTCIsImFkZFByb2R1Y3QiLCJ2YWxpZGF0aW9uRXJyb3IiLCJuZXdQcm9kdWN0IiwidHJhbnNhY3Rpb24iLCJkb2NSZWYiLCJuZXdQcm9kdWN0V2l0aElkIiwiY2F0ZWdvcnlSZWYiLCJjYXRlZ29yeURvYyIsImdldCIsInVwZGF0ZSIsImNvdW50Iiwic2V0IiwiY2hhckF0IiwidG9VcHBlckNhc2UiLCJzbGljZSIsInVwZGF0ZVByb2R1Y3QiLCJleGlzdGluZ1Byb2R1Y3RTbmFwIiwiZXhpc3RpbmdQcm9kdWN0IiwiY2xlYW5lZFVwZGF0ZXMiLCJvbGRDYXRlZ29yeVJlZiIsIm9sZENhdGVnb3J5RG9jIiwib2xkQ291bnQiLCJkZWxldGUiLCJuZXdDYXRlZ29yeVJlZiIsIm5ld0NhdGVnb3J5RG9jIiwiZGVsZXRlUHJvZHVjdCIsInByb2R1Y3RTbmFwIiwicHJvZHVjdERhdGEiLCJnZXRBbGxDYXRlZ29yaWVzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./utils/firestore.ts\n"));

/***/ })

});