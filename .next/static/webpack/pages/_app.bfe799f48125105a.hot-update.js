"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("pages/_app",{

/***/ "./context/ProductContext.tsx":
/*!************************************!*\
  !*** ./context/ProductContext.tsx ***!
  \************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ProductProvider: function() { return /* binding */ ProductProvider; },\n/* harmony export */   useProducts: function() { return /* binding */ useProducts; }\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"./node_modules/react/jsx-dev-runtime.js\");\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _utils_firestore__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/firestore */ \"./utils/firestore.ts\");\n\nvar _s = $RefreshSig$(), _s1 = $RefreshSig$();\n\n\nconst ProductContext = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.createContext)(undefined);\nconst useProducts = ()=>{\n    _s();\n    const context = (0,react__WEBPACK_IMPORTED_MODULE_1__.useContext)(ProductContext);\n    if (!context) {\n        throw new Error(\"useProducts must be used within a ProductProvider\");\n    }\n    return context;\n};\n_s(useProducts, \"b9L3QQ+jgeyIrH0NfHrJ8nn7VMU=\");\nconst ProductProvider = (param)=>{\n    let { children } = param;\n    _s1();\n    const [products, setProducts] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)([]);\n    const [categories, setCategories] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)([]);\n    const [productsByCategory, setProductsByCategory] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)({});\n    const [loading, setLoading] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(true);\n    const [error, setError] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n    // Organize products by category\n    const organizeProductsByCategory = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)((allProducts)=>{\n        const byCategory = {};\n        allProducts.forEach((product)=>{\n            if (!product.category) return;\n            if (!byCategory[product.category]) {\n                byCategory[product.category] = [];\n            }\n            byCategory[product.category].push(product);\n        });\n        setProductsByCategory(byCategory);\n    }, []);\n    // Fetch all products from Firestore\n    const fetchProducts = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)(async ()=>{\n        try {\n            setLoading(true);\n            setError(null);\n            // Clear product cache to ensure fresh data\n            await _utils_firestore__WEBPACK_IMPORTED_MODULE_2__.clearProductCache();\n            // Get data from Firestore\n            console.log(\"Fetching products from Firestore in ProductContext\");\n            const fetchedProducts = await _utils_firestore__WEBPACK_IMPORTED_MODULE_2__.getAllProducts();\n            console.log(\"Fetched \".concat(fetchedProducts.length, \" products from Firestore\"));\n            // Get categories from Firestore\n            // This is handled automatically by the Firestore API\n            setProducts(fetchedProducts);\n            organizeProductsByCategory(fetchedProducts);\n        } catch (err) {\n            console.error(\"Error fetching products:\", err);\n            setError(err.message || \"Failed to load products. Please try again later.\");\n        } finally{\n            setLoading(false);\n        }\n    }, [\n        organizeProductsByCategory\n    ]);\n    // Load products on mount\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        fetchProducts();\n    }, [\n        fetchProducts\n    ]);\n    // Get products in a specific category\n    const getProductsInCategory = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)((category)=>{\n        return productsByCategory[category] || [];\n    }, [\n        productsByCategory\n    ]);\n    // Add a new product\n    const addNewProduct = async (product)=>{\n        try {\n            setError(null);\n            // Ensure product has required fields\n            if (!product.category) {\n                throw new Error(\"Product category is required\");\n            }\n            // Add product to Firestore\n            const newProduct = await _utils_firestore__WEBPACK_IMPORTED_MODULE_2__.addProduct(product);\n            // Update local state\n            setProducts((prevProducts)=>[\n                    ...prevProducts,\n                    newProduct\n                ]);\n            // Update category cache\n            setProductsByCategory((prev)=>{\n                const updated = {\n                    ...prev\n                };\n                const category = product.category;\n                if (!updated[category]) {\n                    updated[category] = [];\n                }\n                updated[category] = [\n                    ...updated[category],\n                    newProduct\n                ];\n                return updated;\n            });\n            return newProduct;\n        } catch (err) {\n            console.error(\"Error adding product:\", err);\n            setError(err.message || \"Failed to add product\");\n            throw err;\n        }\n    };\n    // Update an existing product\n    const updateExistingProduct = async (id, updates)=>{\n        try {\n            setError(null);\n            // Find the existing product to check for category changes\n            const existingProduct = products.find((p)=>p.id === id);\n            if (!existingProduct) {\n                throw new Error(\"Product not found\");\n            }\n            // Update in Firestore\n            await _utils_firestore__WEBPACK_IMPORTED_MODULE_2__.updateProduct(id, updates);\n            // Get the updated product\n            const updatedProduct = {\n                ...existingProduct,\n                ...updates\n            };\n            // Update local state\n            setProducts((prevProducts)=>prevProducts.map((p)=>p.id === id ? updatedProduct : p));\n            // Handle category change if needed\n            if (updates.category && existingProduct.category !== updates.category) {\n                // Refetch products to ensure they're up to date\n                await fetchProducts();\n            } else {\n                // Just update the product in its existing category\n                setProductsByCategory((prev)=>{\n                    const category = existingProduct.category;\n                    if (category && prev[category]) {\n                        return {\n                            ...prev,\n                            [category]: prev[category].map((p)=>p.id === id ? updatedProduct : p)\n                        };\n                    }\n                    return prev;\n                });\n            }\n        } catch (err) {\n            console.error(\"Error updating product:\", err);\n            setError(err.message || \"Failed to update product\");\n            throw err;\n        }\n    };\n    // Remove a product\n    const removeProduct = async (id)=>{\n        try {\n            setError(null);\n            // Find the product to get its category\n            const productToRemove = products.find((p)=>p.id === id);\n            if (!productToRemove) {\n                throw new Error(\"Product not found\");\n            }\n            // Delete from Firestore\n            await _utils_firestore__WEBPACK_IMPORTED_MODULE_2__.deleteProduct(id);\n            // Update local state\n            setProducts((prevProducts)=>prevProducts.filter((p)=>p.id !== id));\n            // Update category cache\n            if (productToRemove.category) {\n                setProductsByCategory((prev)=>{\n                    const updated = {\n                        ...prev\n                    };\n                    if (updated[productToRemove.category]) {\n                        updated[productToRemove.category] = updated[productToRemove.category].filter((p)=>p.id !== id);\n                        // Remove category array if empty\n                        if (updated[productToRemove.category].length === 0) {\n                            delete updated[productToRemove.category];\n                        }\n                    }\n                    return updated;\n                });\n            }\n        } catch (err) {\n            console.error(\"Error removing product:\", err);\n            setError(err.message || \"Failed to delete product\");\n            throw err;\n        }\n    };\n    // Upload an image to Firebase Storage\n    const uploadImage = async (file)=>{\n        try {\n            setError(null);\n            return await _utils_firestore__WEBPACK_IMPORTED_MODULE_2__.uploadProductImage(file);\n        } catch (err) {\n            console.error(\"Error uploading image:\", err);\n            setError(err.message || \"Failed to upload image\");\n            throw err;\n        }\n    };\n    // Manual refresh function\n    const refreshProducts = async ()=>{\n        await fetchProducts();\n    };\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(ProductContext.Provider, {\n        value: {\n            products,\n            categories,\n            productsByCategory,\n            loading,\n            error,\n            addNewProduct,\n            updateExistingProduct,\n            removeProduct,\n            uploadImage,\n            refreshProducts,\n            getProductsInCategory\n        },\n        children: children\n    }, void 0, false, {\n        fileName: \"C:\\\\Projects\\\\Freelansing websites\\\\rangya-master\\\\context\\\\ProductContext.tsx\",\n        lineNumber: 235,\n        columnNumber: 5\n    }, undefined);\n};\n_s1(ProductProvider, \"dNCeWSqA52/VNPCqWEXHWbkh33o=\");\n_c = ProductProvider;\nvar _c;\n$RefreshReg$(_c, \"ProductProvider\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9jb250ZXh0L1Byb2R1Y3RDb250ZXh0LnRzeCIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7QUFBMkY7QUFHeEM7QUFnQm5ELE1BQU1PLCtCQUFpQk4sb0RBQWFBLENBQWlDTztBQUU5RCxNQUFNQyxjQUFjOztJQUN6QixNQUFNQyxVQUFVUixpREFBVUEsQ0FBQ0s7SUFDM0IsSUFBSSxDQUFDRyxTQUFTO1FBQ1osTUFBTSxJQUFJQyxNQUFNO0lBQ2xCO0lBQ0EsT0FBT0Q7QUFDVCxFQUFFO0dBTldEO0FBUU4sTUFBTUcsa0JBQTJEO1FBQUMsRUFBRUMsUUFBUSxFQUFFOztJQUNuRixNQUFNLENBQUNDLFVBQVVDLFlBQVksR0FBR1osK0NBQVFBLENBQVksRUFBRTtJQUN0RCxNQUFNLENBQUNhLFlBQVlDLGNBQWMsR0FBR2QsK0NBQVFBLENBQWEsRUFBRTtJQUMzRCxNQUFNLENBQUNlLG9CQUFvQkMsc0JBQXNCLEdBQUdoQiwrQ0FBUUEsQ0FBNEIsQ0FBQztJQUN6RixNQUFNLENBQUNpQixTQUFTQyxXQUFXLEdBQUdsQiwrQ0FBUUEsQ0FBVTtJQUNoRCxNQUFNLENBQUNtQixPQUFPQyxTQUFTLEdBQUdwQiwrQ0FBUUEsQ0FBZ0I7SUFFbEQsZ0NBQWdDO0lBQ2hDLE1BQU1xQiw2QkFBNkJuQixrREFBV0EsQ0FBQyxDQUFDb0I7UUFDOUMsTUFBTUMsYUFBd0MsQ0FBQztRQUUvQ0QsWUFBWUUsT0FBTyxDQUFDQyxDQUFBQTtZQUNsQixJQUFJLENBQUNBLFFBQVFDLFFBQVEsRUFBRTtZQUV2QixJQUFJLENBQUNILFVBQVUsQ0FBQ0UsUUFBUUMsUUFBUSxDQUFDLEVBQUU7Z0JBQ2pDSCxVQUFVLENBQUNFLFFBQVFDLFFBQVEsQ0FBQyxHQUFHLEVBQUU7WUFDbkM7WUFFQUgsVUFBVSxDQUFDRSxRQUFRQyxRQUFRLENBQUMsQ0FBQ0MsSUFBSSxDQUFDRjtRQUNwQztRQUVBVCxzQkFBc0JPO0lBQ3hCLEdBQUcsRUFBRTtJQUVMLG9DQUFvQztJQUNwQyxNQUFNSyxnQkFBZ0IxQixrREFBV0EsQ0FBQztRQUNoQyxJQUFJO1lBQ0ZnQixXQUFXO1lBQ1hFLFNBQVM7WUFFVCwyQ0FBMkM7WUFDM0MsTUFBTWpCLCtEQUE4QjtZQUVwQywwQkFBMEI7WUFDMUIyQixRQUFRQyxHQUFHLENBQUM7WUFDWixNQUFNQyxrQkFBa0IsTUFBTTdCLDREQUEyQjtZQUN6RDJCLFFBQVFDLEdBQUcsQ0FBQyxXQUFrQyxPQUF2QkMsZ0JBQWdCRSxNQUFNLEVBQUM7WUFFOUMsZ0NBQWdDO1lBQ2hDLHFEQUFxRDtZQUVyRHRCLFlBQVlvQjtZQUNaWCwyQkFBMkJXO1FBRTdCLEVBQUUsT0FBT0csS0FBVTtZQUNqQkwsUUFBUVgsS0FBSyxDQUFDLDRCQUE0QmdCO1lBQzFDZixTQUFTZSxJQUFJQyxPQUFPLElBQUk7UUFDMUIsU0FBVTtZQUNSbEIsV0FBVztRQUNiO0lBQ0YsR0FBRztRQUFDRztLQUEyQjtJQUUvQix5QkFBeUI7SUFDekJwQixnREFBU0EsQ0FBQztRQUNSMkI7SUFDRixHQUFHO1FBQUNBO0tBQWM7SUFFbEIsc0NBQXNDO0lBQ3RDLE1BQU1TLHdCQUF3Qm5DLGtEQUFXQSxDQUFDLENBQUN3QjtRQUN6QyxPQUFPWCxrQkFBa0IsQ0FBQ1csU0FBUyxJQUFJLEVBQUU7SUFDM0MsR0FBRztRQUFDWDtLQUFtQjtJQUV2QixvQkFBb0I7SUFDcEIsTUFBTXVCLGdCQUFnQixPQUFPYjtRQUMzQixJQUFJO1lBQ0ZMLFNBQVM7WUFFVCxxQ0FBcUM7WUFDckMsSUFBSSxDQUFDSyxRQUFRQyxRQUFRLEVBQUU7Z0JBQ3JCLE1BQU0sSUFBSWxCLE1BQU07WUFDbEI7WUFFQSwyQkFBMkI7WUFDM0IsTUFBTStCLGFBQWEsTUFBTXBDLHdEQUF1QixDQUFDc0I7WUFFakQscUJBQXFCO1lBQ3JCYixZQUFZNkIsQ0FBQUEsZUFBZ0I7dUJBQUlBO29CQUFjRjtpQkFBVztZQUV6RCx3QkFBd0I7WUFDeEJ2QixzQkFBc0IwQixDQUFBQTtnQkFDcEIsTUFBTUMsVUFBVTtvQkFBRSxHQUFHRCxJQUFJO2dCQUFDO2dCQUMxQixNQUFNaEIsV0FBV0QsUUFBUUMsUUFBUTtnQkFFakMsSUFBSSxDQUFDaUIsT0FBTyxDQUFDakIsU0FBUyxFQUFFO29CQUN0QmlCLE9BQU8sQ0FBQ2pCLFNBQVMsR0FBRyxFQUFFO2dCQUN4QjtnQkFDQWlCLE9BQU8sQ0FBQ2pCLFNBQVMsR0FBRzt1QkFBSWlCLE9BQU8sQ0FBQ2pCLFNBQVM7b0JBQUVhO2lCQUFXO2dCQUN0RCxPQUFPSTtZQUNUO1lBRUEsT0FBT0o7UUFDVCxFQUFFLE9BQU9KLEtBQVU7WUFDakJMLFFBQVFYLEtBQUssQ0FBQyx5QkFBeUJnQjtZQUN2Q2YsU0FBU2UsSUFBSUMsT0FBTyxJQUFJO1lBQ3hCLE1BQU1EO1FBQ1I7SUFDRjtJQUVBLDZCQUE2QjtJQUM3QixNQUFNUyx3QkFBd0IsT0FBT0MsSUFBWUM7UUFDL0MsSUFBSTtZQUNGMUIsU0FBUztZQUVULDBEQUEwRDtZQUMxRCxNQUFNMkIsa0JBQWtCcEMsU0FBU3FDLElBQUksQ0FBQ0MsQ0FBQUEsSUFBS0EsRUFBRUosRUFBRSxLQUFLQTtZQUNwRCxJQUFJLENBQUNFLGlCQUFpQjtnQkFDcEIsTUFBTSxJQUFJdkMsTUFBTTtZQUNsQjtZQUVBLHNCQUFzQjtZQUN0QixNQUFNTCwyREFBMEIsQ0FBQzBDLElBQUlDO1lBRXJDLDBCQUEwQjtZQUMxQixNQUFNSyxpQkFBaUI7Z0JBQUUsR0FBR0osZUFBZTtnQkFBRSxHQUFHRCxPQUFPO1lBQUM7WUFFeEQscUJBQXFCO1lBQ3JCbEMsWUFBWTZCLENBQUFBLGVBQ1ZBLGFBQWFXLEdBQUcsQ0FBQ0gsQ0FBQUEsSUFBS0EsRUFBRUosRUFBRSxLQUFLQSxLQUFLTSxpQkFBaUJGO1lBR3ZELG1DQUFtQztZQUNuQyxJQUFJSCxRQUFRcEIsUUFBUSxJQUFJcUIsZ0JBQWdCckIsUUFBUSxLQUFLb0IsUUFBUXBCLFFBQVEsRUFBRTtnQkFDckUsZ0RBQWdEO2dCQUNoRCxNQUFNRTtZQUNSLE9BQU87Z0JBQ0wsbURBQW1EO2dCQUNuRFosc0JBQXNCMEIsQ0FBQUE7b0JBQ3BCLE1BQU1oQixXQUFXcUIsZ0JBQWdCckIsUUFBUTtvQkFDekMsSUFBSUEsWUFBWWdCLElBQUksQ0FBQ2hCLFNBQVMsRUFBRTt3QkFDOUIsT0FBTzs0QkFDTCxHQUFHZ0IsSUFBSTs0QkFDUCxDQUFDaEIsU0FBUyxFQUFFZ0IsSUFBSSxDQUFDaEIsU0FBUyxDQUFDMEIsR0FBRyxDQUFDSCxDQUFBQSxJQUM3QkEsRUFBRUosRUFBRSxLQUFLQSxLQUFLTSxpQkFBaUJGO3dCQUVuQztvQkFDRjtvQkFDQSxPQUFPUDtnQkFDVDtZQUNGO1FBQ0YsRUFBRSxPQUFPUCxLQUFVO1lBQ2pCTCxRQUFRWCxLQUFLLENBQUMsMkJBQTJCZ0I7WUFDekNmLFNBQVNlLElBQUlDLE9BQU8sSUFBSTtZQUN4QixNQUFNRDtRQUNSO0lBQ0Y7SUFFQSxtQkFBbUI7SUFDbkIsTUFBTWtCLGdCQUFnQixPQUFPUjtRQUMzQixJQUFJO1lBQ0Z6QixTQUFTO1lBRVQsdUNBQXVDO1lBQ3ZDLE1BQU1rQyxrQkFBa0IzQyxTQUFTcUMsSUFBSSxDQUFDQyxDQUFBQSxJQUFLQSxFQUFFSixFQUFFLEtBQUtBO1lBQ3BELElBQUksQ0FBQ1MsaUJBQWlCO2dCQUNwQixNQUFNLElBQUk5QyxNQUFNO1lBQ2xCO1lBRUEsd0JBQXdCO1lBQ3hCLE1BQU1MLDJEQUEwQixDQUFDMEM7WUFFakMscUJBQXFCO1lBQ3JCakMsWUFBWTZCLENBQUFBLGVBQWdCQSxhQUFhZSxNQUFNLENBQUNQLENBQUFBLElBQUtBLEVBQUVKLEVBQUUsS0FBS0E7WUFFOUQsd0JBQXdCO1lBQ3hCLElBQUlTLGdCQUFnQjVCLFFBQVEsRUFBRTtnQkFDNUJWLHNCQUFzQjBCLENBQUFBO29CQUNwQixNQUFNQyxVQUFVO3dCQUFFLEdBQUdELElBQUk7b0JBQUM7b0JBQzFCLElBQUlDLE9BQU8sQ0FBQ1csZ0JBQWdCNUIsUUFBUSxDQUFDLEVBQUU7d0JBQ3JDaUIsT0FBTyxDQUFDVyxnQkFBZ0I1QixRQUFRLENBQUMsR0FBR2lCLE9BQU8sQ0FBQ1csZ0JBQWdCNUIsUUFBUSxDQUFDLENBQUM4QixNQUFNLENBQzFFUCxDQUFBQSxJQUFLQSxFQUFFSixFQUFFLEtBQUtBO3dCQUdoQixpQ0FBaUM7d0JBQ2pDLElBQUlGLE9BQU8sQ0FBQ1csZ0JBQWdCNUIsUUFBUSxDQUFDLENBQUNRLE1BQU0sS0FBSyxHQUFHOzRCQUNsRCxPQUFPUyxPQUFPLENBQUNXLGdCQUFnQjVCLFFBQVEsQ0FBQzt3QkFDMUM7b0JBQ0Y7b0JBQ0EsT0FBT2lCO2dCQUNUO1lBQ0Y7UUFDRixFQUFFLE9BQU9SLEtBQVU7WUFDakJMLFFBQVFYLEtBQUssQ0FBQywyQkFBMkJnQjtZQUN6Q2YsU0FBU2UsSUFBSUMsT0FBTyxJQUFJO1lBQ3hCLE1BQU1EO1FBQ1I7SUFDRjtJQUVBLHNDQUFzQztJQUN0QyxNQUFNc0IsY0FBYyxPQUFPQztRQUN6QixJQUFJO1lBQ0Z0QyxTQUFTO1lBQ1QsT0FBTyxNQUFNakIsZ0VBQStCLENBQUN1RDtRQUMvQyxFQUFFLE9BQU92QixLQUFVO1lBQ2pCTCxRQUFRWCxLQUFLLENBQUMsMEJBQTBCZ0I7WUFDeENmLFNBQVNlLElBQUlDLE9BQU8sSUFBSTtZQUN4QixNQUFNRDtRQUNSO0lBQ0Y7SUFFQSwwQkFBMEI7SUFDMUIsTUFBTXlCLGtCQUFrQjtRQUN0QixNQUFNaEM7SUFDUjtJQUVBLHFCQUNFLDhEQUFDeEIsZUFBZXlELFFBQVE7UUFDdEJDLE9BQU87WUFDTG5EO1lBQ0FFO1lBQ0FFO1lBQ0FFO1lBQ0FFO1lBQ0FtQjtZQUNBTTtZQUNBUztZQUNBSTtZQUNBRztZQUNBdkI7UUFDRjtrQkFFQzNCOzs7Ozs7QUFHUCxFQUFFO0lBL05XRDtLQUFBQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9jb250ZXh0L1Byb2R1Y3RDb250ZXh0LnRzeD81OGU2Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBSZWFjdCwgeyBjcmVhdGVDb250ZXh0LCB1c2VDb250ZXh0LCB1c2VTdGF0ZSwgdXNlRWZmZWN0LCB1c2VDYWxsYmFjayB9IGZyb20gJ3JlYWN0JztcclxuaW1wb3J0IHsgUHJvZHVjdCB9IGZyb20gJy4uL2RhdGEvcHJvZHVjdHMnO1xyXG5pbXBvcnQgeyBDYXRlZ29yeSB9IGZyb20gJy4uL3V0aWxzL2xvY2FsU3RvcmFnZSc7XHJcbmltcG9ydCAqIGFzIGZpcmVzdG9yZUFQSSBmcm9tICcuLi91dGlscy9maXJlc3RvcmUnO1xyXG5cclxuaW50ZXJmYWNlIFByb2R1Y3RDb250ZXh0VHlwZSB7XHJcbiAgcHJvZHVjdHM6IFByb2R1Y3RbXTtcclxuICBjYXRlZ29yaWVzOiBDYXRlZ29yeVtdO1xyXG4gIHByb2R1Y3RzQnlDYXRlZ29yeTogUmVjb3JkPHN0cmluZywgUHJvZHVjdFtdPjtcclxuICBsb2FkaW5nOiBib29sZWFuO1xyXG4gIGVycm9yOiBzdHJpbmcgfCBudWxsO1xyXG4gIGFkZE5ld1Byb2R1Y3Q6IChwcm9kdWN0OiBPbWl0PFByb2R1Y3QsICdpZCc+KSA9PiBQcm9taXNlPFByb2R1Y3Q+O1xyXG4gIHVwZGF0ZUV4aXN0aW5nUHJvZHVjdDogKGlkOiBzdHJpbmcsIHByb2R1Y3Q6IFBhcnRpYWw8UHJvZHVjdD4pID0+IFByb21pc2U8dm9pZD47XHJcbiAgcmVtb3ZlUHJvZHVjdDogKGlkOiBzdHJpbmcpID0+IFByb21pc2U8dm9pZD47XHJcbiAgdXBsb2FkSW1hZ2U6IChmaWxlOiBGaWxlKSA9PiBQcm9taXNlPHN0cmluZz47XHJcbiAgcmVmcmVzaFByb2R1Y3RzOiAoKSA9PiBQcm9taXNlPHZvaWQ+O1xyXG4gIGdldFByb2R1Y3RzSW5DYXRlZ29yeTogKGNhdGVnb3J5OiBzdHJpbmcpID0+IFByb2R1Y3RbXTtcclxufVxyXG5cclxuY29uc3QgUHJvZHVjdENvbnRleHQgPSBjcmVhdGVDb250ZXh0PFByb2R1Y3RDb250ZXh0VHlwZSB8IHVuZGVmaW5lZD4odW5kZWZpbmVkKTtcclxuXHJcbmV4cG9ydCBjb25zdCB1c2VQcm9kdWN0cyA9ICgpID0+IHtcclxuICBjb25zdCBjb250ZXh0ID0gdXNlQ29udGV4dChQcm9kdWN0Q29udGV4dCk7XHJcbiAgaWYgKCFjb250ZXh0KSB7XHJcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3VzZVByb2R1Y3RzIG11c3QgYmUgdXNlZCB3aXRoaW4gYSBQcm9kdWN0UHJvdmlkZXInKTtcclxuICB9XHJcbiAgcmV0dXJuIGNvbnRleHQ7XHJcbn07XHJcblxyXG5leHBvcnQgY29uc3QgUHJvZHVjdFByb3ZpZGVyOiBSZWFjdC5GQzx7IGNoaWxkcmVuOiBSZWFjdC5SZWFjdE5vZGUgfT4gPSAoeyBjaGlsZHJlbiB9KSA9PiB7XHJcbiAgY29uc3QgW3Byb2R1Y3RzLCBzZXRQcm9kdWN0c10gPSB1c2VTdGF0ZTxQcm9kdWN0W10+KFtdKTtcclxuICBjb25zdCBbY2F0ZWdvcmllcywgc2V0Q2F0ZWdvcmllc10gPSB1c2VTdGF0ZTxDYXRlZ29yeVtdPihbXSk7XHJcbiAgY29uc3QgW3Byb2R1Y3RzQnlDYXRlZ29yeSwgc2V0UHJvZHVjdHNCeUNhdGVnb3J5XSA9IHVzZVN0YXRlPFJlY29yZDxzdHJpbmcsIFByb2R1Y3RbXT4+KHt9KTtcclxuICBjb25zdCBbbG9hZGluZywgc2V0TG9hZGluZ10gPSB1c2VTdGF0ZTxib29sZWFuPih0cnVlKTtcclxuICBjb25zdCBbZXJyb3IsIHNldEVycm9yXSA9IHVzZVN0YXRlPHN0cmluZyB8IG51bGw+KG51bGwpO1xyXG5cclxuICAvLyBPcmdhbml6ZSBwcm9kdWN0cyBieSBjYXRlZ29yeVxyXG4gIGNvbnN0IG9yZ2FuaXplUHJvZHVjdHNCeUNhdGVnb3J5ID0gdXNlQ2FsbGJhY2soKGFsbFByb2R1Y3RzOiBQcm9kdWN0W10pID0+IHtcclxuICAgIGNvbnN0IGJ5Q2F0ZWdvcnk6IFJlY29yZDxzdHJpbmcsIFByb2R1Y3RbXT4gPSB7fTtcclxuICAgIFxyXG4gICAgYWxsUHJvZHVjdHMuZm9yRWFjaChwcm9kdWN0ID0+IHtcclxuICAgICAgaWYgKCFwcm9kdWN0LmNhdGVnb3J5KSByZXR1cm47XHJcbiAgICAgIFxyXG4gICAgICBpZiAoIWJ5Q2F0ZWdvcnlbcHJvZHVjdC5jYXRlZ29yeV0pIHtcclxuICAgICAgICBieUNhdGVnb3J5W3Byb2R1Y3QuY2F0ZWdvcnldID0gW107XHJcbiAgICAgIH1cclxuICAgICAgXHJcbiAgICAgIGJ5Q2F0ZWdvcnlbcHJvZHVjdC5jYXRlZ29yeV0ucHVzaChwcm9kdWN0KTtcclxuICAgIH0pO1xyXG4gICAgXHJcbiAgICBzZXRQcm9kdWN0c0J5Q2F0ZWdvcnkoYnlDYXRlZ29yeSk7XHJcbiAgfSwgW10pO1xyXG5cclxuICAvLyBGZXRjaCBhbGwgcHJvZHVjdHMgZnJvbSBGaXJlc3RvcmVcclxuICBjb25zdCBmZXRjaFByb2R1Y3RzID0gdXNlQ2FsbGJhY2soYXN5bmMgKCkgPT4ge1xyXG4gICAgdHJ5IHtcclxuICAgICAgc2V0TG9hZGluZyh0cnVlKTtcclxuICAgICAgc2V0RXJyb3IobnVsbCk7XHJcbiAgICAgIFxyXG4gICAgICAvLyBDbGVhciBwcm9kdWN0IGNhY2hlIHRvIGVuc3VyZSBmcmVzaCBkYXRhXHJcbiAgICAgIGF3YWl0IGZpcmVzdG9yZUFQSS5jbGVhclByb2R1Y3RDYWNoZSgpO1xyXG4gICAgICBcclxuICAgICAgLy8gR2V0IGRhdGEgZnJvbSBGaXJlc3RvcmVcclxuICAgICAgY29uc29sZS5sb2coJ0ZldGNoaW5nIHByb2R1Y3RzIGZyb20gRmlyZXN0b3JlIGluIFByb2R1Y3RDb250ZXh0Jyk7XHJcbiAgICAgIGNvbnN0IGZldGNoZWRQcm9kdWN0cyA9IGF3YWl0IGZpcmVzdG9yZUFQSS5nZXRBbGxQcm9kdWN0cygpO1xyXG4gICAgICBjb25zb2xlLmxvZyhgRmV0Y2hlZCAke2ZldGNoZWRQcm9kdWN0cy5sZW5ndGh9IHByb2R1Y3RzIGZyb20gRmlyZXN0b3JlYCk7XHJcbiAgICAgIFxyXG4gICAgICAvLyBHZXQgY2F0ZWdvcmllcyBmcm9tIEZpcmVzdG9yZVxyXG4gICAgICAvLyBUaGlzIGlzIGhhbmRsZWQgYXV0b21hdGljYWxseSBieSB0aGUgRmlyZXN0b3JlIEFQSVxyXG4gICAgICBcclxuICAgICAgc2V0UHJvZHVjdHMoZmV0Y2hlZFByb2R1Y3RzKTtcclxuICAgICAgb3JnYW5pemVQcm9kdWN0c0J5Q2F0ZWdvcnkoZmV0Y2hlZFByb2R1Y3RzKTtcclxuICAgICAgXHJcbiAgICB9IGNhdGNoIChlcnI6IGFueSkge1xyXG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBmZXRjaGluZyBwcm9kdWN0czonLCBlcnIpO1xyXG4gICAgICBzZXRFcnJvcihlcnIubWVzc2FnZSB8fCAnRmFpbGVkIHRvIGxvYWQgcHJvZHVjdHMuIFBsZWFzZSB0cnkgYWdhaW4gbGF0ZXIuJyk7XHJcbiAgICB9IGZpbmFsbHkge1xyXG4gICAgICBzZXRMb2FkaW5nKGZhbHNlKTtcclxuICAgIH1cclxuICB9LCBbb3JnYW5pemVQcm9kdWN0c0J5Q2F0ZWdvcnldKTtcclxuXHJcbiAgLy8gTG9hZCBwcm9kdWN0cyBvbiBtb3VudFxyXG4gIHVzZUVmZmVjdCgoKSA9PiB7XHJcbiAgICBmZXRjaFByb2R1Y3RzKCk7XHJcbiAgfSwgW2ZldGNoUHJvZHVjdHNdKTtcclxuXHJcbiAgLy8gR2V0IHByb2R1Y3RzIGluIGEgc3BlY2lmaWMgY2F0ZWdvcnlcclxuICBjb25zdCBnZXRQcm9kdWN0c0luQ2F0ZWdvcnkgPSB1c2VDYWxsYmFjaygoY2F0ZWdvcnk6IHN0cmluZyk6IFByb2R1Y3RbXSA9PiB7XHJcbiAgICByZXR1cm4gcHJvZHVjdHNCeUNhdGVnb3J5W2NhdGVnb3J5XSB8fCBbXTtcclxuICB9LCBbcHJvZHVjdHNCeUNhdGVnb3J5XSk7XHJcblxyXG4gIC8vIEFkZCBhIG5ldyBwcm9kdWN0XHJcbiAgY29uc3QgYWRkTmV3UHJvZHVjdCA9IGFzeW5jIChwcm9kdWN0OiBPbWl0PFByb2R1Y3QsICdpZCc+KTogUHJvbWlzZTxQcm9kdWN0PiA9PiB7XHJcbiAgICB0cnkge1xyXG4gICAgICBzZXRFcnJvcihudWxsKTtcclxuICAgICAgXHJcbiAgICAgIC8vIEVuc3VyZSBwcm9kdWN0IGhhcyByZXF1aXJlZCBmaWVsZHNcclxuICAgICAgaWYgKCFwcm9kdWN0LmNhdGVnb3J5KSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdQcm9kdWN0IGNhdGVnb3J5IGlzIHJlcXVpcmVkJyk7XHJcbiAgICAgIH1cclxuICAgICAgXHJcbiAgICAgIC8vIEFkZCBwcm9kdWN0IHRvIEZpcmVzdG9yZVxyXG4gICAgICBjb25zdCBuZXdQcm9kdWN0ID0gYXdhaXQgZmlyZXN0b3JlQVBJLmFkZFByb2R1Y3QocHJvZHVjdCk7XHJcbiAgICAgIFxyXG4gICAgICAvLyBVcGRhdGUgbG9jYWwgc3RhdGVcclxuICAgICAgc2V0UHJvZHVjdHMocHJldlByb2R1Y3RzID0+IFsuLi5wcmV2UHJvZHVjdHMsIG5ld1Byb2R1Y3RdKTtcclxuICAgICAgXHJcbiAgICAgIC8vIFVwZGF0ZSBjYXRlZ29yeSBjYWNoZVxyXG4gICAgICBzZXRQcm9kdWN0c0J5Q2F0ZWdvcnkocHJldiA9PiB7XHJcbiAgICAgICAgY29uc3QgdXBkYXRlZCA9IHsgLi4ucHJldiB9O1xyXG4gICAgICAgIGNvbnN0IGNhdGVnb3J5ID0gcHJvZHVjdC5jYXRlZ29yeSBhcyBzdHJpbmc7XHJcbiAgICAgICAgXHJcbiAgICAgICAgaWYgKCF1cGRhdGVkW2NhdGVnb3J5XSkge1xyXG4gICAgICAgICAgdXBkYXRlZFtjYXRlZ29yeV0gPSBbXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdXBkYXRlZFtjYXRlZ29yeV0gPSBbLi4udXBkYXRlZFtjYXRlZ29yeV0sIG5ld1Byb2R1Y3RdO1xyXG4gICAgICAgIHJldHVybiB1cGRhdGVkO1xyXG4gICAgICB9KTtcclxuICAgICAgXHJcbiAgICAgIHJldHVybiBuZXdQcm9kdWN0O1xyXG4gICAgfSBjYXRjaCAoZXJyOiBhbnkpIHtcclxuICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgYWRkaW5nIHByb2R1Y3Q6JywgZXJyKTtcclxuICAgICAgc2V0RXJyb3IoZXJyLm1lc3NhZ2UgfHwgJ0ZhaWxlZCB0byBhZGQgcHJvZHVjdCcpO1xyXG4gICAgICB0aHJvdyBlcnI7XHJcbiAgICB9XHJcbiAgfTtcclxuXHJcbiAgLy8gVXBkYXRlIGFuIGV4aXN0aW5nIHByb2R1Y3RcclxuICBjb25zdCB1cGRhdGVFeGlzdGluZ1Byb2R1Y3QgPSBhc3luYyAoaWQ6IHN0cmluZywgdXBkYXRlczogUGFydGlhbDxQcm9kdWN0Pik6IFByb21pc2U8dm9pZD4gPT4ge1xyXG4gICAgdHJ5IHtcclxuICAgICAgc2V0RXJyb3IobnVsbCk7XHJcbiAgICAgIFxyXG4gICAgICAvLyBGaW5kIHRoZSBleGlzdGluZyBwcm9kdWN0IHRvIGNoZWNrIGZvciBjYXRlZ29yeSBjaGFuZ2VzXHJcbiAgICAgIGNvbnN0IGV4aXN0aW5nUHJvZHVjdCA9IHByb2R1Y3RzLmZpbmQocCA9PiBwLmlkID09PSBpZCk7XHJcbiAgICAgIGlmICghZXhpc3RpbmdQcm9kdWN0KSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdQcm9kdWN0IG5vdCBmb3VuZCcpO1xyXG4gICAgICB9XHJcbiAgICAgIFxyXG4gICAgICAvLyBVcGRhdGUgaW4gRmlyZXN0b3JlXHJcbiAgICAgIGF3YWl0IGZpcmVzdG9yZUFQSS51cGRhdGVQcm9kdWN0KGlkLCB1cGRhdGVzKTtcclxuICAgICAgXHJcbiAgICAgIC8vIEdldCB0aGUgdXBkYXRlZCBwcm9kdWN0XHJcbiAgICAgIGNvbnN0IHVwZGF0ZWRQcm9kdWN0ID0geyAuLi5leGlzdGluZ1Byb2R1Y3QsIC4uLnVwZGF0ZXMgfTtcclxuICAgICAgXHJcbiAgICAgIC8vIFVwZGF0ZSBsb2NhbCBzdGF0ZVxyXG4gICAgICBzZXRQcm9kdWN0cyhwcmV2UHJvZHVjdHMgPT4gXHJcbiAgICAgICAgcHJldlByb2R1Y3RzLm1hcChwID0+IHAuaWQgPT09IGlkID8gdXBkYXRlZFByb2R1Y3QgOiBwKVxyXG4gICAgICApO1xyXG4gICAgICBcclxuICAgICAgLy8gSGFuZGxlIGNhdGVnb3J5IGNoYW5nZSBpZiBuZWVkZWRcclxuICAgICAgaWYgKHVwZGF0ZXMuY2F0ZWdvcnkgJiYgZXhpc3RpbmdQcm9kdWN0LmNhdGVnb3J5ICE9PSB1cGRhdGVzLmNhdGVnb3J5KSB7XHJcbiAgICAgICAgLy8gUmVmZXRjaCBwcm9kdWN0cyB0byBlbnN1cmUgdGhleSdyZSB1cCB0byBkYXRlXHJcbiAgICAgICAgYXdhaXQgZmV0Y2hQcm9kdWN0cygpO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIC8vIEp1c3QgdXBkYXRlIHRoZSBwcm9kdWN0IGluIGl0cyBleGlzdGluZyBjYXRlZ29yeVxyXG4gICAgICAgIHNldFByb2R1Y3RzQnlDYXRlZ29yeShwcmV2ID0+IHtcclxuICAgICAgICAgIGNvbnN0IGNhdGVnb3J5ID0gZXhpc3RpbmdQcm9kdWN0LmNhdGVnb3J5O1xyXG4gICAgICAgICAgaWYgKGNhdGVnb3J5ICYmIHByZXZbY2F0ZWdvcnldKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgLi4ucHJldixcclxuICAgICAgICAgICAgICBbY2F0ZWdvcnldOiBwcmV2W2NhdGVnb3J5XS5tYXAocCA9PiBcclxuICAgICAgICAgICAgICAgIHAuaWQgPT09IGlkID8gdXBkYXRlZFByb2R1Y3QgOiBwXHJcbiAgICAgICAgICAgICAgKVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgcmV0dXJuIHByZXY7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgIH1cclxuICAgIH0gY2F0Y2ggKGVycjogYW55KSB7XHJcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIHVwZGF0aW5nIHByb2R1Y3Q6JywgZXJyKTtcclxuICAgICAgc2V0RXJyb3IoZXJyLm1lc3NhZ2UgfHwgJ0ZhaWxlZCB0byB1cGRhdGUgcHJvZHVjdCcpO1xyXG4gICAgICB0aHJvdyBlcnI7XHJcbiAgICB9XHJcbiAgfTtcclxuXHJcbiAgLy8gUmVtb3ZlIGEgcHJvZHVjdFxyXG4gIGNvbnN0IHJlbW92ZVByb2R1Y3QgPSBhc3luYyAoaWQ6IHN0cmluZyk6IFByb21pc2U8dm9pZD4gPT4ge1xyXG4gICAgdHJ5IHtcclxuICAgICAgc2V0RXJyb3IobnVsbCk7XHJcbiAgICAgIFxyXG4gICAgICAvLyBGaW5kIHRoZSBwcm9kdWN0IHRvIGdldCBpdHMgY2F0ZWdvcnlcclxuICAgICAgY29uc3QgcHJvZHVjdFRvUmVtb3ZlID0gcHJvZHVjdHMuZmluZChwID0+IHAuaWQgPT09IGlkKTtcclxuICAgICAgaWYgKCFwcm9kdWN0VG9SZW1vdmUpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Byb2R1Y3Qgbm90IGZvdW5kJyk7XHJcbiAgICAgIH1cclxuICAgICAgXHJcbiAgICAgIC8vIERlbGV0ZSBmcm9tIEZpcmVzdG9yZVxyXG4gICAgICBhd2FpdCBmaXJlc3RvcmVBUEkuZGVsZXRlUHJvZHVjdChpZCk7XHJcbiAgICAgIFxyXG4gICAgICAvLyBVcGRhdGUgbG9jYWwgc3RhdGVcclxuICAgICAgc2V0UHJvZHVjdHMocHJldlByb2R1Y3RzID0+IHByZXZQcm9kdWN0cy5maWx0ZXIocCA9PiBwLmlkICE9PSBpZCkpO1xyXG4gICAgICBcclxuICAgICAgLy8gVXBkYXRlIGNhdGVnb3J5IGNhY2hlXHJcbiAgICAgIGlmIChwcm9kdWN0VG9SZW1vdmUuY2F0ZWdvcnkpIHtcclxuICAgICAgICBzZXRQcm9kdWN0c0J5Q2F0ZWdvcnkocHJldiA9PiB7XHJcbiAgICAgICAgICBjb25zdCB1cGRhdGVkID0geyAuLi5wcmV2IH07XHJcbiAgICAgICAgICBpZiAodXBkYXRlZFtwcm9kdWN0VG9SZW1vdmUuY2F0ZWdvcnldKSB7XHJcbiAgICAgICAgICAgIHVwZGF0ZWRbcHJvZHVjdFRvUmVtb3ZlLmNhdGVnb3J5XSA9IHVwZGF0ZWRbcHJvZHVjdFRvUmVtb3ZlLmNhdGVnb3J5XS5maWx0ZXIoXHJcbiAgICAgICAgICAgICAgcCA9PiBwLmlkICE9PSBpZFxyXG4gICAgICAgICAgICApO1xyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgLy8gUmVtb3ZlIGNhdGVnb3J5IGFycmF5IGlmIGVtcHR5XHJcbiAgICAgICAgICAgIGlmICh1cGRhdGVkW3Byb2R1Y3RUb1JlbW92ZS5jYXRlZ29yeV0ubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgZGVsZXRlIHVwZGF0ZWRbcHJvZHVjdFRvUmVtb3ZlLmNhdGVnb3J5XTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgcmV0dXJuIHVwZGF0ZWQ7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgIH1cclxuICAgIH0gY2F0Y2ggKGVycjogYW55KSB7XHJcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIHJlbW92aW5nIHByb2R1Y3Q6JywgZXJyKTtcclxuICAgICAgc2V0RXJyb3IoZXJyLm1lc3NhZ2UgfHwgJ0ZhaWxlZCB0byBkZWxldGUgcHJvZHVjdCcpO1xyXG4gICAgICB0aHJvdyBlcnI7XHJcbiAgICB9XHJcbiAgfTtcclxuXHJcbiAgLy8gVXBsb2FkIGFuIGltYWdlIHRvIEZpcmViYXNlIFN0b3JhZ2VcclxuICBjb25zdCB1cGxvYWRJbWFnZSA9IGFzeW5jIChmaWxlOiBGaWxlKTogUHJvbWlzZTxzdHJpbmc+ID0+IHtcclxuICAgIHRyeSB7XHJcbiAgICAgIHNldEVycm9yKG51bGwpO1xyXG4gICAgICByZXR1cm4gYXdhaXQgZmlyZXN0b3JlQVBJLnVwbG9hZFByb2R1Y3RJbWFnZShmaWxlKTtcclxuICAgIH0gY2F0Y2ggKGVycjogYW55KSB7XHJcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIHVwbG9hZGluZyBpbWFnZTonLCBlcnIpO1xyXG4gICAgICBzZXRFcnJvcihlcnIubWVzc2FnZSB8fCAnRmFpbGVkIHRvIHVwbG9hZCBpbWFnZScpO1xyXG4gICAgICB0aHJvdyBlcnI7XHJcbiAgICB9XHJcbiAgfTtcclxuXHJcbiAgLy8gTWFudWFsIHJlZnJlc2ggZnVuY3Rpb25cclxuICBjb25zdCByZWZyZXNoUHJvZHVjdHMgPSBhc3luYyAoKTogUHJvbWlzZTx2b2lkPiA9PiB7XHJcbiAgICBhd2FpdCBmZXRjaFByb2R1Y3RzKCk7XHJcbiAgfTtcclxuXHJcbiAgcmV0dXJuIChcclxuICAgIDxQcm9kdWN0Q29udGV4dC5Qcm92aWRlclxyXG4gICAgICB2YWx1ZT17e1xyXG4gICAgICAgIHByb2R1Y3RzLFxyXG4gICAgICAgIGNhdGVnb3JpZXMsXHJcbiAgICAgICAgcHJvZHVjdHNCeUNhdGVnb3J5LFxyXG4gICAgICAgIGxvYWRpbmcsXHJcbiAgICAgICAgZXJyb3IsXHJcbiAgICAgICAgYWRkTmV3UHJvZHVjdCxcclxuICAgICAgICB1cGRhdGVFeGlzdGluZ1Byb2R1Y3QsXHJcbiAgICAgICAgcmVtb3ZlUHJvZHVjdCxcclxuICAgICAgICB1cGxvYWRJbWFnZSxcclxuICAgICAgICByZWZyZXNoUHJvZHVjdHMsXHJcbiAgICAgICAgZ2V0UHJvZHVjdHNJbkNhdGVnb3J5XHJcbiAgICAgIH19XHJcbiAgICA+XHJcbiAgICAgIHtjaGlsZHJlbn1cclxuICAgIDwvUHJvZHVjdENvbnRleHQuUHJvdmlkZXI+XHJcbiAgKTtcclxufTsgIl0sIm5hbWVzIjpbIlJlYWN0IiwiY3JlYXRlQ29udGV4dCIsInVzZUNvbnRleHQiLCJ1c2VTdGF0ZSIsInVzZUVmZmVjdCIsInVzZUNhbGxiYWNrIiwiZmlyZXN0b3JlQVBJIiwiUHJvZHVjdENvbnRleHQiLCJ1bmRlZmluZWQiLCJ1c2VQcm9kdWN0cyIsImNvbnRleHQiLCJFcnJvciIsIlByb2R1Y3RQcm92aWRlciIsImNoaWxkcmVuIiwicHJvZHVjdHMiLCJzZXRQcm9kdWN0cyIsImNhdGVnb3JpZXMiLCJzZXRDYXRlZ29yaWVzIiwicHJvZHVjdHNCeUNhdGVnb3J5Iiwic2V0UHJvZHVjdHNCeUNhdGVnb3J5IiwibG9hZGluZyIsInNldExvYWRpbmciLCJlcnJvciIsInNldEVycm9yIiwib3JnYW5pemVQcm9kdWN0c0J5Q2F0ZWdvcnkiLCJhbGxQcm9kdWN0cyIsImJ5Q2F0ZWdvcnkiLCJmb3JFYWNoIiwicHJvZHVjdCIsImNhdGVnb3J5IiwicHVzaCIsImZldGNoUHJvZHVjdHMiLCJjbGVhclByb2R1Y3RDYWNoZSIsImNvbnNvbGUiLCJsb2ciLCJmZXRjaGVkUHJvZHVjdHMiLCJnZXRBbGxQcm9kdWN0cyIsImxlbmd0aCIsImVyciIsIm1lc3NhZ2UiLCJnZXRQcm9kdWN0c0luQ2F0ZWdvcnkiLCJhZGROZXdQcm9kdWN0IiwibmV3UHJvZHVjdCIsImFkZFByb2R1Y3QiLCJwcmV2UHJvZHVjdHMiLCJwcmV2IiwidXBkYXRlZCIsInVwZGF0ZUV4aXN0aW5nUHJvZHVjdCIsImlkIiwidXBkYXRlcyIsImV4aXN0aW5nUHJvZHVjdCIsImZpbmQiLCJwIiwidXBkYXRlUHJvZHVjdCIsInVwZGF0ZWRQcm9kdWN0IiwibWFwIiwicmVtb3ZlUHJvZHVjdCIsInByb2R1Y3RUb1JlbW92ZSIsImRlbGV0ZVByb2R1Y3QiLCJmaWx0ZXIiLCJ1cGxvYWRJbWFnZSIsImZpbGUiLCJ1cGxvYWRQcm9kdWN0SW1hZ2UiLCJyZWZyZXNoUHJvZHVjdHMiLCJQcm92aWRlciIsInZhbHVlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./context/ProductContext.tsx\n"));

/***/ })

});