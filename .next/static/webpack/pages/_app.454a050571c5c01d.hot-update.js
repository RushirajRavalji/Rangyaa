"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("pages/_app",{

/***/ "./utils/firestore.ts":
/*!****************************!*\
  !*** ./utils/firestore.ts ***!
  \****************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   addProduct: function() { return /* binding */ addProduct; },\n/* harmony export */   clearProductCache: function() { return /* binding */ clearProductCache; },\n/* harmony export */   db: function() { return /* binding */ db; },\n/* harmony export */   deleteProduct: function() { return /* binding */ deleteProduct; },\n/* harmony export */   deleteProductImage: function() { return /* binding */ deleteProductImage; },\n/* harmony export */   getAllCategories: function() { return /* binding */ getAllCategories; },\n/* harmony export */   getAllProducts: function() { return /* binding */ getAllProducts; },\n/* harmony export */   getFeaturedProducts: function() { return /* binding */ getFeaturedProducts; },\n/* harmony export */   getNewArrivals: function() { return /* binding */ getNewArrivals; },\n/* harmony export */   getNextProductsPage: function() { return /* binding */ getNextProductsPage; },\n/* harmony export */   getProductById: function() { return /* binding */ getProductById; },\n/* harmony export */   getProductsByCategory: function() { return /* binding */ getProductsByCategory; },\n/* harmony export */   storage: function() { return /* binding */ storage; },\n/* harmony export */   updateProduct: function() { return /* binding */ updateProduct; },\n/* harmony export */   uploadProductImage: function() { return /* binding */ uploadProductImage; }\n/* harmony export */ });\n/* harmony import */ var _firebase__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./firebase */ \"./utils/firebase.ts\");\n/* harmony import */ var firebase_firestore__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! firebase/firestore */ \"./node_modules/firebase/firestore/dist/esm/index.esm.js\");\n/* harmony import */ var firebase_storage__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! firebase/storage */ \"./node_modules/firebase/storage/dist/esm/index.esm.js\");\n\n\n\n// Initialize Firestore\nconst db = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.getFirestore)(_firebase__WEBPACK_IMPORTED_MODULE_0__.app);\n// Initialize Storage\nconst storage = (0,firebase_storage__WEBPACK_IMPORTED_MODULE_2__.getStorage)(_firebase__WEBPACK_IMPORTED_MODULE_0__.app);\n// Collection references\nconst productsCollection = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.collection)(db, \"products\");\nconst categoriesCollection = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.collection)(db, \"categories\");\n// Cache for products\nconst productCache = {\n    all: null,\n    byId: {},\n    byCategory: {},\n    lastFetched: 0\n};\n// Cache expiration time (5 minutes)\nconst CACHE_EXPIRATION = 5 * 60 * 1000;\n// Validate product data before saving\nconst validateProduct = (product)=>{\n    if (!product.name || typeof product.name !== \"string\") {\n        return \"Product name is required\";\n    }\n    if (!product.price || isNaN(Number(product.price))) {\n        return \"Valid product price is required\";\n    }\n    if (!product.category || typeof product.category !== \"string\") {\n        return \"Product category is required\";\n    }\n    if (!product.image || typeof product.image !== \"string\") {\n        return \"Product image is required\";\n    }\n    return null; // No errors\n};\n// Clean product data for Firestore\nconst cleanProductData = (product)=>{\n    const cleanedProduct = {};\n    Object.entries(product).forEach((param)=>{\n        let [key, value] = param;\n        if (value !== undefined && value !== null) {\n            // Handle specific field types\n            if (key === \"price\" || key === \"originalPrice\" || key === \"stock\") {\n                cleanedProduct[key] = Number(value);\n            } else if (key === \"sizes\" && typeof value === \"string\") {\n                cleanedProduct[key] = value.split(\",\").map((s)=>s.trim()).filter(Boolean);\n            } else if (key === \"featured\" && typeof value === \"string\") {\n                cleanedProduct[key] = value === \"true\";\n            } else {\n                cleanedProduct[key] = value;\n            }\n        }\n    });\n    // Add timestamps\n    if (!cleanedProduct.createdAt) {\n        cleanedProduct.createdAt = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.serverTimestamp)();\n    }\n    cleanedProduct.updatedAt = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.serverTimestamp)();\n    return cleanedProduct;\n};\n// Check if cache is valid\nconst isCacheValid = ()=>{\n    return productCache.all !== null && Date.now() - productCache.lastFetched < CACHE_EXPIRATION;\n};\n// Get all products with pagination and caching\nconst getAllProducts = async function() {\n    let pageSize = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;\n    try {\n        // If cache is valid and we're not paginating, return cached products\n        if (isCacheValid() && pageSize === 0 && productCache.all) {\n            console.log(\"Returning products from cache\");\n            return productCache.all;\n        }\n        console.log(\"Fetching products from Firestore\");\n        let productsQuery = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.query)(productsCollection, (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.orderBy)(\"createdAt\", \"desc\"));\n        // Apply pagination if pageSize is specified\n        if (pageSize > 0) {\n            productsQuery = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.query)(productsQuery, (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.limit)(pageSize));\n        }\n        const snapshot = await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.getDocs)(productsQuery);\n        const products = snapshot.docs.map((doc)=>({\n                id: doc.id,\n                ...doc.data()\n            }));\n        // Update cache if we're getting all products\n        if (pageSize === 0) {\n            productCache.all = products;\n            // Update byId and byCategory caches\n            products.forEach((product)=>{\n                productCache.byId[product.id] = product;\n                if (product.category) {\n                    if (!productCache.byCategory[product.category]) {\n                        productCache.byCategory[product.category] = [];\n                    }\n                    productCache.byCategory[product.category].push(product);\n                }\n            });\n            productCache.lastFetched = Date.now();\n        }\n        console.log(\"Retrieved \".concat(products.length, \" products from Firestore\"));\n        return products;\n    } catch (error) {\n        console.error(\"Error getting products from Firestore:\", error);\n        throw new Error(\"Failed to fetch products\");\n    }\n};\n// Get next page of products\nconst getNextProductsPage = async function(lastVisible) {\n    let pageSize = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 20;\n    try {\n        const productsQuery = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.query)(productsCollection, (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.orderBy)(\"createdAt\", \"desc\"), (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.startAfter)(lastVisible), (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.limit)(pageSize));\n        const snapshot = await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.getDocs)(productsQuery);\n        const products = snapshot.docs.map((doc)=>({\n                id: doc.id,\n                ...doc.data()\n            }));\n        // Update cache for these products\n        products.forEach((product)=>{\n            productCache.byId[product.id] = product;\n            if (product.category) {\n                if (!productCache.byCategory[product.category]) {\n                    productCache.byCategory[product.category] = [];\n                }\n                // Check if product already exists in category cache\n                const existingIndex = productCache.byCategory[product.category].findIndex((p)=>p.id === product.id);\n                if (existingIndex >= 0) {\n                    productCache.byCategory[product.category][existingIndex] = product;\n                } else {\n                    productCache.byCategory[product.category].push(product);\n                }\n            }\n        });\n        return products;\n    } catch (error) {\n        console.error(\"Error getting next page of products:\", error);\n        throw new Error(\"Failed to fetch more products\");\n    }\n};\n// Get products by category with caching\nconst getProductsByCategory = async (category)=>{\n    try {\n        // Check if we have this category in cache and it's still valid\n        if (isCacheValid() && productCache.byCategory[category] && productCache.byCategory[category].length > 0) {\n            console.log(\"Returning \".concat(category, \" products from cache\"));\n            return productCache.byCategory[category];\n        }\n        console.log(\"Fetching \".concat(category, \" products from Firestore\"));\n        const q = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.query)(productsCollection, (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.where)(\"category\", \"==\", category));\n        const snapshot = await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.getDocs)(q);\n        const products = snapshot.docs.map((doc)=>({\n                id: doc.id,\n                ...doc.data()\n            }));\n        // Update cache\n        productCache.byCategory[category] = products;\n        // Also update byId cache\n        products.forEach((product)=>{\n            productCache.byId[product.id] = product;\n        });\n        return products;\n    } catch (error) {\n        console.error(\"Error getting \".concat(category, \" products:\"), error);\n        throw new Error(\"Failed to fetch \".concat(category, \" products\"));\n    }\n};\n// Get featured products with caching\nconst getFeaturedProducts = async function() {\n    let limit = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 8;\n    try {\n        // If we have all products cached, filter them\n        if (isCacheValid() && productCache.all) {\n            const featured = productCache.all.filter((p)=>p.featured).slice(0, limit);\n            if (featured.length > 0) {\n                console.log(\"Returning featured products from cache\");\n                return featured;\n            }\n        }\n        console.log(\"Fetching featured products from Firestore\");\n        const q = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.query)(productsCollection, (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.where)(\"featured\", \"==\", true), (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.orderBy)(\"createdAt\", \"desc\"), limit);\n        const snapshot = await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.getDocs)(q);\n        const products = snapshot.docs.map((doc)=>({\n                id: doc.id,\n                ...doc.data()\n            }));\n        // Update byId cache\n        products.forEach((product)=>{\n            productCache.byId[product.id] = product;\n            // Update category cache if needed\n            if (product.category) {\n                if (!productCache.byCategory[product.category]) {\n                    productCache.byCategory[product.category] = [];\n                }\n                // Check if product already exists in category cache\n                const existingIndex = productCache.byCategory[product.category].findIndex((p)=>p.id === product.id);\n                if (existingIndex >= 0) {\n                    productCache.byCategory[product.category][existingIndex] = product;\n                } else {\n                    productCache.byCategory[product.category].push(product);\n                }\n            }\n        });\n        return products;\n    } catch (error) {\n        console.error(\"Error getting featured products:\", error);\n        throw new Error(\"Failed to fetch featured products\");\n    }\n};\n// Get new arrivals with caching\nconst getNewArrivals = async function() {\n    let limit = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 8;\n    try {\n        // If we have all products cached, filter them\n        if (isCacheValid() && productCache.all) {\n            const newArrivals = productCache.all.filter((p)=>p.new).slice(0, limit);\n            if (newArrivals.length > 0) {\n                console.log(\"Returning new arrivals from cache\");\n                return newArrivals;\n            }\n        }\n        console.log(\"Fetching new arrivals from Firestore\");\n        const q = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.query)(productsCollection, (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.where)(\"new\", \"==\", true), (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.orderBy)(\"createdAt\", \"desc\"), limit);\n        const snapshot = await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.getDocs)(q);\n        const products = snapshot.docs.map((doc)=>({\n                id: doc.id,\n                ...doc.data()\n            }));\n        // Update byId cache\n        products.forEach((product)=>{\n            productCache.byId[product.id] = product;\n            // Update category cache if needed\n            if (product.category) {\n                if (!productCache.byCategory[product.category]) {\n                    productCache.byCategory[product.category] = [];\n                }\n                // Check if product already exists in category cache\n                const existingIndex = productCache.byCategory[product.category].findIndex((p)=>p.id === product.id);\n                if (existingIndex >= 0) {\n                    productCache.byCategory[product.category][existingIndex] = product;\n                } else {\n                    productCache.byCategory[product.category].push(product);\n                }\n            }\n        });\n        return products;\n    } catch (error) {\n        console.error(\"Error getting new arrivals:\", error);\n        throw new Error(\"Failed to fetch new arrivals\");\n    }\n};\n// Get product by ID with caching\nconst getProductById = async (id)=>{\n    try {\n        // Check if product is in cache\n        if (productCache.byId[id]) {\n            console.log(\"Returning product \".concat(id, \" from cache\"));\n            return productCache.byId[id];\n        }\n        console.log(\"Fetching product \".concat(id, \" from Firestore\"));\n        const productDoc = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.doc)(db, \"products\", id);\n        const snapshot = await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.getDoc)(productDoc);\n        if (snapshot.exists()) {\n            const product = {\n                id: snapshot.id,\n                ...snapshot.data()\n            };\n            // Update cache\n            productCache.byId[id] = product;\n            return product;\n        }\n        return null;\n    } catch (error) {\n        console.error(\"Error getting product:\", error);\n        throw new Error(\"Failed to fetch product details\");\n    }\n};\n// Clear cache for a specific product\nconst invalidateProductCache = (productId, categoryId)=>{\n    // Remove from byId cache\n    if (productCache.byId[productId]) {\n        delete productCache.byId[productId];\n    }\n    // Remove from category cache if category is provided\n    if (categoryId && productCache.byCategory[categoryId]) {\n        productCache.byCategory[categoryId] = productCache.byCategory[categoryId].filter((p)=>p.id !== productId);\n    }\n    // Set all cache to null to force refresh on next fetch\n    productCache.all = null;\n};\n// Clear entire cache\nconst clearProductCache = ()=>{\n    productCache.all = null;\n    productCache.byId = {};\n    productCache.byCategory = {};\n    productCache.lastFetched = 0;\n};\n// Upload image to Firebase Storage\nconst uploadProductImage = async (file)=>{\n    try {\n        // Create a unique filename\n        const timestamp = new Date().getTime();\n        const fileName = \"product_\".concat(timestamp, \"_\").concat(file.name.replace(/[^a-zA-Z0-9.]/g, \"_\"));\n        // Create a reference to the file in storage\n        const storageRef = (0,firebase_storage__WEBPACK_IMPORTED_MODULE_2__.ref)(storage, \"product_images/\".concat(fileName));\n        // Upload the file\n        await (0,firebase_storage__WEBPACK_IMPORTED_MODULE_2__.uploadBytes)(storageRef, file);\n        // Get the download URL\n        const downloadURL = await (0,firebase_storage__WEBPACK_IMPORTED_MODULE_2__.getDownloadURL)(storageRef);\n        return downloadURL;\n    } catch (error) {\n        console.error(\"Error uploading image:\", error);\n        throw new Error(\"Failed to upload product image\");\n    }\n};\n// Delete product image from Firebase Storage\nconst deleteProductImage = async (imageUrl)=>{\n    try {\n        // Extract the file path from the URL\n        const decodedUrl = decodeURIComponent(imageUrl);\n        const startIndex = decodedUrl.indexOf(\"product_images\");\n        if (startIndex === -1) {\n            console.warn(\"Not a Firebase Storage URL or not in product_images folder:\", imageUrl);\n            return;\n        }\n        const endIndex = decodedUrl.indexOf(\"?\", startIndex);\n        const filePath = endIndex !== -1 ? decodedUrl.substring(startIndex, endIndex) : decodedUrl.substring(startIndex);\n        // Create a reference to the file\n        const imageRef = (0,firebase_storage__WEBPACK_IMPORTED_MODULE_2__.ref)(storage, filePath);\n        // Delete the file\n        await (0,firebase_storage__WEBPACK_IMPORTED_MODULE_2__.deleteObject)(imageRef);\n        console.log(\"Product image deleted successfully:\", filePath);\n    } catch (error) {\n        console.error(\"Error deleting product image:\", error);\n    // Don't throw error here, as we want to continue with product deletion\n    // even if image deletion fails\n    }\n};\n// Add a new product with transaction for category tracking\nconst addProduct = async (product)=>{\n    try {\n        console.log(\"Adding product to Firestore:\", product);\n        // Validate product data\n        const validationError = validateProduct(product);\n        if (validationError) {\n            throw new Error(validationError);\n        }\n        // Clean the product data for Firestore\n        const cleanedProduct = cleanProductData(product);\n        console.log(\"Cleaned product data for Firestore:\", cleanedProduct);\n        // Use transaction to add product and update category data\n        const newProduct = await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.runTransaction)(db, async (transaction)=>{\n            // Add the product document\n            const docRef = await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.addDoc)(productsCollection, cleanedProduct);\n            const newProductWithId = {\n                id: docRef.id,\n                ...cleanedProduct\n            };\n            // Update or create category count\n            const categoryRef = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.doc)(categoriesCollection, cleanedProduct.category);\n            const categoryDoc = await transaction.get(categoryRef);\n            if (categoryDoc.exists()) {\n                // Update existing category\n                transaction.update(categoryRef, {\n                    count: (categoryDoc.data().count || 0) + 1,\n                    updatedAt: (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.serverTimestamp)()\n                });\n            } else {\n                // Create new category\n                transaction.set(categoryRef, {\n                    id: cleanedProduct.category,\n                    name: cleanedProduct.category.charAt(0).toUpperCase() + cleanedProduct.category.slice(1),\n                    count: 1,\n                    createdAt: (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.serverTimestamp)(),\n                    updatedAt: (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.serverTimestamp)()\n                });\n            }\n            return newProductWithId;\n        });\n        // Update cache with the new product\n        if (productCache.all) {\n            productCache.all.unshift(newProduct);\n        }\n        productCache.byId[newProduct.id] = newProduct;\n        if (newProduct.category) {\n            if (!productCache.byCategory[newProduct.category]) {\n                productCache.byCategory[newProduct.category] = [];\n            }\n            productCache.byCategory[newProduct.category].unshift(newProduct);\n        }\n        console.log(\"Product added successfully with ID:\", newProduct.id);\n        return newProduct;\n    } catch (error) {\n        console.error(\"Error adding product to Firestore:\", error);\n        throw error;\n    }\n};\n// Update a product\nconst updateProduct = async (id, product)=>{\n    try {\n        const productDoc = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.doc)(db, \"products\", id);\n        // Get existing product to check if category is changing\n        const existingProductSnap = await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.getDoc)(productDoc);\n        if (!existingProductSnap.exists()) {\n            throw new Error(\"Product not found\");\n        }\n        const existingProduct = existingProductSnap.data();\n        const cleanedUpdates = cleanProductData(product);\n        // Always update the timestamp when modified\n        cleanedUpdates.updatedAt = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.serverTimestamp)();\n        await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.runTransaction)(db, async (transaction)=>{\n            // Update product document\n            transaction.update(productDoc, cleanedUpdates);\n            // If category changed, update both old and new category counts\n            if (product.category && existingProduct.category !== product.category) {\n                // Decrease old category count\n                const oldCategoryRef = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.doc)(categoriesCollection, existingProduct.category);\n                const oldCategoryDoc = await transaction.get(oldCategoryRef);\n                if (oldCategoryDoc.exists()) {\n                    const oldCount = oldCategoryDoc.data().count || 0;\n                    if (oldCount > 1) {\n                        transaction.update(oldCategoryRef, {\n                            count: oldCount - 1,\n                            updatedAt: (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.serverTimestamp)()\n                        });\n                    } else {\n                        // Delete category if it will be empty\n                        transaction.delete(oldCategoryRef);\n                    }\n                }\n                // Increase new category count\n                const newCategoryRef = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.doc)(categoriesCollection, product.category);\n                const newCategoryDoc = await transaction.get(newCategoryRef);\n                if (newCategoryDoc.exists()) {\n                    transaction.update(newCategoryRef, {\n                        count: (newCategoryDoc.data().count || 0) + 1,\n                        updatedAt: (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.serverTimestamp)()\n                    });\n                } else {\n                    transaction.set(newCategoryRef, {\n                        id: product.category,\n                        name: product.category.charAt(0).toUpperCase() + product.category.slice(1),\n                        count: 1,\n                        createdAt: (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.serverTimestamp)(),\n                        updatedAt: (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.serverTimestamp)()\n                    });\n                }\n            }\n        });\n        // Update cache\n        if (productCache.byId[id]) {\n            const updatedProduct = {\n                ...productCache.byId[id],\n                ...product\n            };\n            productCache.byId[id] = updatedProduct;\n            // Update in all products cache if it exists\n            if (productCache.all) {\n                const index = productCache.all.findIndex((p)=>p.id === id);\n                if (index >= 0) {\n                    productCache.all[index] = updatedProduct;\n                }\n            }\n            // Handle category change in cache\n            if (product.category && existingProduct.category !== product.category) {\n                // Remove from old category cache\n                if (productCache.byCategory[existingProduct.category]) {\n                    productCache.byCategory[existingProduct.category] = productCache.byCategory[existingProduct.category].filter((p)=>p.id !== id);\n                }\n                // Add to new category cache\n                if (!productCache.byCategory[product.category]) {\n                    productCache.byCategory[product.category] = [];\n                }\n                productCache.byCategory[product.category].push(updatedProduct);\n            } else if (product.category) {\n                // Update in same category\n                if (productCache.byCategory[product.category]) {\n                    const catIndex = productCache.byCategory[product.category].findIndex((p)=>p.id === id);\n                    if (catIndex >= 0) {\n                        productCache.byCategory[product.category][catIndex] = updatedProduct;\n                    }\n                }\n            }\n        } else {\n            // If not in cache, invalidate all cache to force refresh\n            clearProductCache();\n        }\n    } catch (error) {\n        console.error(\"Error updating product:\", error);\n        throw new Error(\"Failed to update product\");\n    }\n};\n// Delete a product\nconst deleteProduct = async (id)=>{\n    try {\n        const productDoc = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.doc)(db, \"products\", id);\n        // Get product to find its category and image URL\n        const productSnap = await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.getDoc)(productDoc);\n        if (!productSnap.exists()) {\n            throw new Error(\"Product not found\");\n        }\n        const productData = productSnap.data();\n        // Try to delete the product image first\n        if (productData.image) {\n            try {\n                await deleteProductImage(productData.image);\n            } catch (error) {\n                console.error(\"Error deleting product image:\", error);\n            // Continue with product deletion even if image deletion fails\n            }\n        }\n        await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.runTransaction)(db, async (transaction)=>{\n            // Delete product\n            transaction.delete(productDoc);\n            // Update category count\n            if (productData.category) {\n                const categoryRef = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.doc)(categoriesCollection, productData.category);\n                const categoryDoc = await transaction.get(categoryRef);\n                if (categoryDoc.exists()) {\n                    const count = categoryDoc.data().count || 0;\n                    if (count > 1) {\n                        transaction.update(categoryRef, {\n                            count: count - 1,\n                            updatedAt: (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.serverTimestamp)()\n                        });\n                    } else {\n                        // Delete category if it will be empty\n                        transaction.delete(categoryRef);\n                    }\n                }\n            }\n        });\n        // Update cache\n        invalidateProductCache(id, productData.category);\n    } catch (error) {\n        console.error(\"Error deleting product:\", error);\n        throw new Error(\"Failed to delete product\");\n    }\n};\n// Get all categories with product counts\nconst getAllCategories = async ()=>{\n    try {\n        const snapshot = await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.getDocs)(categoriesCollection);\n        return snapshot.docs.map((doc)=>doc.data());\n    } catch (error) {\n        console.error(\"Error getting categories:\", error);\n        throw new Error(\"Failed to fetch categories\");\n    }\n};\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi91dGlscy9maXJlc3RvcmUudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQWlDO0FBQ3FOO0FBQ3hKO0FBRzlGLHVCQUF1QjtBQUNoQixNQUFNbUIsS0FBS2xCLGdFQUFZQSxDQUFDRCwwQ0FBR0EsRUFBRTtBQUVwQyxxQkFBcUI7QUFDZCxNQUFNb0IsVUFBVU4sNERBQVVBLENBQUNkLDBDQUFHQSxFQUFFO0FBRXZDLHdCQUF3QjtBQUN4QixNQUFNcUIscUJBQXFCbkIsOERBQVVBLENBQUNpQixJQUFJO0FBQzFDLE1BQU1HLHVCQUF1QnBCLDhEQUFVQSxDQUFDaUIsSUFBSTtBQUU1QyxxQkFBcUI7QUFDckIsTUFBTUksZUFLRjtJQUNGQyxLQUFLO0lBQ0xDLE1BQU0sQ0FBQztJQUNQQyxZQUFZLENBQUM7SUFDYkMsYUFBYTtBQUNmO0FBRUEsb0NBQW9DO0FBQ3BDLE1BQU1DLG1CQUFtQixJQUFJLEtBQUs7QUFFbEMsc0NBQXNDO0FBQ3RDLE1BQU1DLGtCQUFrQixDQUFDQztJQUN2QixJQUFJLENBQUNBLFFBQVFDLElBQUksSUFBSSxPQUFPRCxRQUFRQyxJQUFJLEtBQUssVUFBVTtRQUNyRCxPQUFPO0lBQ1Q7SUFFQSxJQUFJLENBQUNELFFBQVFFLEtBQUssSUFBSUMsTUFBTUMsT0FBT0osUUFBUUUsS0FBSyxJQUFJO1FBQ2xELE9BQU87SUFDVDtJQUVBLElBQUksQ0FBQ0YsUUFBUUssUUFBUSxJQUFJLE9BQU9MLFFBQVFLLFFBQVEsS0FBSyxVQUFVO1FBQzdELE9BQU87SUFDVDtJQUVBLElBQUksQ0FBQ0wsUUFBUU0sS0FBSyxJQUFJLE9BQU9OLFFBQVFNLEtBQUssS0FBSyxVQUFVO1FBQ3ZELE9BQU87SUFDVDtJQUVBLE9BQU8sTUFBTSxZQUFZO0FBQzNCO0FBRUEsbUNBQW1DO0FBQ25DLE1BQU1DLG1CQUFtQixDQUFDUDtJQUN4QixNQUFNUSxpQkFBc0MsQ0FBQztJQUU3Q0MsT0FBT0MsT0FBTyxDQUFDVixTQUFTVyxPQUFPLENBQUM7WUFBQyxDQUFDQyxLQUFLQyxNQUFNO1FBQzNDLElBQUlBLFVBQVVDLGFBQWFELFVBQVUsTUFBTTtZQUN6Qyw4QkFBOEI7WUFDOUIsSUFBSUQsUUFBUSxXQUFXQSxRQUFRLG1CQUFtQkEsUUFBUSxTQUFTO2dCQUNqRUosY0FBYyxDQUFDSSxJQUFJLEdBQUdSLE9BQU9TO1lBQy9CLE9BQU8sSUFBSUQsUUFBUSxXQUFXLE9BQU9DLFVBQVUsVUFBVTtnQkFDdkRMLGNBQWMsQ0FBQ0ksSUFBSSxHQUFHQyxNQUFNRSxLQUFLLENBQUMsS0FBS0MsR0FBRyxDQUFDLENBQUNDLElBQWNBLEVBQUVDLElBQUksSUFBSUMsTUFBTSxDQUFDQztZQUM3RSxPQUFPLElBQUlSLFFBQVEsY0FBYyxPQUFPQyxVQUFVLFVBQVU7Z0JBQzFETCxjQUFjLENBQUNJLElBQUksR0FBR0MsVUFBVTtZQUNsQyxPQUFPO2dCQUNMTCxjQUFjLENBQUNJLElBQUksR0FBR0M7WUFDeEI7UUFDRjtJQUNGO0lBRUEsaUJBQWlCO0lBQ2pCLElBQUksQ0FBQ0wsZUFBZWEsU0FBUyxFQUFFO1FBQzdCYixlQUFlYSxTQUFTLEdBQUd6QyxtRUFBZUE7SUFDNUM7SUFDQTRCLGVBQWVjLFNBQVMsR0FBRzFDLG1FQUFlQTtJQUUxQyxPQUFPNEI7QUFDVDtBQUVBLDBCQUEwQjtBQUMxQixNQUFNZSxlQUFlO0lBQ25CLE9BQ0U5QixhQUFhQyxHQUFHLEtBQUssUUFDckI4QixLQUFLQyxHQUFHLEtBQUtoQyxhQUFhSSxXQUFXLEdBQUdDO0FBRTVDO0FBRUEsK0NBQStDO0FBQ3hDLE1BQU00QixpQkFBaUI7UUFBT0MsNEVBQW1CO0lBQ3RELElBQUk7UUFDRixxRUFBcUU7UUFDckUsSUFBSUosa0JBQWtCSSxhQUFhLEtBQUtsQyxhQUFhQyxHQUFHLEVBQUU7WUFDeERrQyxRQUFRQyxHQUFHLENBQUM7WUFDWixPQUFPcEMsYUFBYUMsR0FBRztRQUN6QjtRQUVBa0MsUUFBUUMsR0FBRyxDQUFDO1FBRVosSUFBSUMsZ0JBQWdCckQseURBQUtBLENBQUNjLG9CQUFvQlQsMkRBQU9BLENBQUMsYUFBYTtRQUVuRSw0Q0FBNEM7UUFDNUMsSUFBSTZDLFdBQVcsR0FBRztZQUNoQkcsZ0JBQWdCckQseURBQUtBLENBQUNxRCxlQUFlakQseURBQUtBLENBQUM4QztRQUM3QztRQUVBLE1BQU1JLFdBQVcsTUFBTTFELDJEQUFPQSxDQUFDeUQ7UUFDL0IsTUFBTUUsV0FBV0QsU0FBU0UsSUFBSSxDQUFDakIsR0FBRyxDQUFDMUMsQ0FBQUEsTUFBUTtnQkFDekM0RCxJQUFJNUQsSUFBSTRELEVBQUU7Z0JBQ1YsR0FBRzVELElBQUk2RCxJQUFJLEVBQUU7WUFDZjtRQUVBLDZDQUE2QztRQUM3QyxJQUFJUixhQUFhLEdBQUc7WUFDbEJsQyxhQUFhQyxHQUFHLEdBQUdzQztZQUVuQixvQ0FBb0M7WUFDcENBLFNBQVNyQixPQUFPLENBQUNYLENBQUFBO2dCQUNmUCxhQUFhRSxJQUFJLENBQUNLLFFBQVFrQyxFQUFFLENBQUMsR0FBR2xDO2dCQUVoQyxJQUFJQSxRQUFRSyxRQUFRLEVBQUU7b0JBQ3BCLElBQUksQ0FBQ1osYUFBYUcsVUFBVSxDQUFDSSxRQUFRSyxRQUFRLENBQUMsRUFBRTt3QkFDOUNaLGFBQWFHLFVBQVUsQ0FBQ0ksUUFBUUssUUFBUSxDQUFDLEdBQUcsRUFBRTtvQkFDaEQ7b0JBQ0FaLGFBQWFHLFVBQVUsQ0FBQ0ksUUFBUUssUUFBUSxDQUFDLENBQUMrQixJQUFJLENBQUNwQztnQkFDakQ7WUFDRjtZQUVBUCxhQUFhSSxXQUFXLEdBQUcyQixLQUFLQyxHQUFHO1FBQ3JDO1FBRUFHLFFBQVFDLEdBQUcsQ0FBQyxhQUE2QixPQUFoQkcsU0FBU0ssTUFBTSxFQUFDO1FBQ3pDLE9BQU9MO0lBQ1QsRUFBRSxPQUFPTSxPQUFPO1FBQ2RWLFFBQVFVLEtBQUssQ0FBQywwQ0FBMENBO1FBQ3hELE1BQU0sSUFBSUMsTUFBTTtJQUNsQjtBQUNGLEVBQUU7QUFFRiw0QkFBNEI7QUFDckIsTUFBTUMsc0JBQXNCLGVBQ2pDQztRQUNBZCw0RUFBbUI7SUFFbkIsSUFBSTtRQUNGLE1BQU1HLGdCQUFnQnJELHlEQUFLQSxDQUN6QmMsb0JBQ0FULDJEQUFPQSxDQUFDLGFBQWEsU0FDckJDLDhEQUFVQSxDQUFDMEQsY0FDWDVELHlEQUFLQSxDQUFDOEM7UUFHUixNQUFNSSxXQUFXLE1BQU0xRCwyREFBT0EsQ0FBQ3lEO1FBQy9CLE1BQU1FLFdBQVdELFNBQVNFLElBQUksQ0FBQ2pCLEdBQUcsQ0FBQzFDLENBQUFBLE1BQVE7Z0JBQ3pDNEQsSUFBSTVELElBQUk0RCxFQUFFO2dCQUNWLEdBQUc1RCxJQUFJNkQsSUFBSSxFQUFFO1lBQ2Y7UUFFQSxrQ0FBa0M7UUFDbENILFNBQVNyQixPQUFPLENBQUNYLENBQUFBO1lBQ2ZQLGFBQWFFLElBQUksQ0FBQ0ssUUFBUWtDLEVBQUUsQ0FBQyxHQUFHbEM7WUFFaEMsSUFBSUEsUUFBUUssUUFBUSxFQUFFO2dCQUNwQixJQUFJLENBQUNaLGFBQWFHLFVBQVUsQ0FBQ0ksUUFBUUssUUFBUSxDQUFDLEVBQUU7b0JBQzlDWixhQUFhRyxVQUFVLENBQUNJLFFBQVFLLFFBQVEsQ0FBQyxHQUFHLEVBQUU7Z0JBQ2hEO2dCQUVBLG9EQUFvRDtnQkFDcEQsTUFBTXFDLGdCQUFnQmpELGFBQWFHLFVBQVUsQ0FBQ0ksUUFBUUssUUFBUSxDQUFDLENBQUNzQyxTQUFTLENBQ3ZFQyxDQUFBQSxJQUFLQSxFQUFFVixFQUFFLEtBQUtsQyxRQUFRa0MsRUFBRTtnQkFHMUIsSUFBSVEsaUJBQWlCLEdBQUc7b0JBQ3RCakQsYUFBYUcsVUFBVSxDQUFDSSxRQUFRSyxRQUFRLENBQUMsQ0FBQ3FDLGNBQWMsR0FBRzFDO2dCQUM3RCxPQUFPO29CQUNMUCxhQUFhRyxVQUFVLENBQUNJLFFBQVFLLFFBQVEsQ0FBQyxDQUFDK0IsSUFBSSxDQUFDcEM7Z0JBQ2pEO1lBQ0Y7UUFDRjtRQUVBLE9BQU9nQztJQUNULEVBQUUsT0FBT00sT0FBTztRQUNkVixRQUFRVSxLQUFLLENBQUMsd0NBQXdDQTtRQUN0RCxNQUFNLElBQUlDLE1BQU07SUFDbEI7QUFDRixFQUFFO0FBRUYsd0NBQXdDO0FBQ2pDLE1BQU1NLHdCQUF3QixPQUFPeEM7SUFDMUMsSUFBSTtRQUNGLCtEQUErRDtRQUMvRCxJQUNFa0Isa0JBQ0E5QixhQUFhRyxVQUFVLENBQUNTLFNBQVMsSUFDakNaLGFBQWFHLFVBQVUsQ0FBQ1MsU0FBUyxDQUFDZ0MsTUFBTSxHQUFHLEdBQzNDO1lBQ0FULFFBQVFDLEdBQUcsQ0FBQyxhQUFzQixPQUFUeEIsVUFBUztZQUNsQyxPQUFPWixhQUFhRyxVQUFVLENBQUNTLFNBQVM7UUFDMUM7UUFFQXVCLFFBQVFDLEdBQUcsQ0FBQyxZQUFxQixPQUFUeEIsVUFBUztRQUNqQyxNQUFNeUMsSUFBSXJFLHlEQUFLQSxDQUFDYyxvQkFBb0JiLHlEQUFLQSxDQUFDLFlBQVksTUFBTTJCO1FBQzVELE1BQU0wQixXQUFXLE1BQU0xRCwyREFBT0EsQ0FBQ3lFO1FBQy9CLE1BQU1kLFdBQVdELFNBQVNFLElBQUksQ0FBQ2pCLEdBQUcsQ0FBQzFDLENBQUFBLE1BQVE7Z0JBQ3pDNEQsSUFBSTVELElBQUk0RCxFQUFFO2dCQUNWLEdBQUc1RCxJQUFJNkQsSUFBSSxFQUFFO1lBQ2Y7UUFFQSxlQUFlO1FBQ2YxQyxhQUFhRyxVQUFVLENBQUNTLFNBQVMsR0FBRzJCO1FBRXBDLHlCQUF5QjtRQUN6QkEsU0FBU3JCLE9BQU8sQ0FBQ1gsQ0FBQUE7WUFDZlAsYUFBYUUsSUFBSSxDQUFDSyxRQUFRa0MsRUFBRSxDQUFDLEdBQUdsQztRQUNsQztRQUVBLE9BQU9nQztJQUNULEVBQUUsT0FBT00sT0FBTztRQUNkVixRQUFRVSxLQUFLLENBQUMsaUJBQTBCLE9BQVRqQyxVQUFTLGVBQWFpQztRQUNyRCxNQUFNLElBQUlDLE1BQU0sbUJBQTRCLE9BQVRsQyxVQUFTO0lBQzlDO0FBQ0YsRUFBRTtBQUVGLHFDQUFxQztBQUM5QixNQUFNMEMsc0JBQXNCO1FBQU9sRSx5RUFBZ0I7SUFDeEQsSUFBSTtRQUNGLDhDQUE4QztRQUM5QyxJQUFJMEMsa0JBQWtCOUIsYUFBYUMsR0FBRyxFQUFFO1lBQ3RDLE1BQU1zRCxXQUFXdkQsYUFBYUMsR0FBRyxDQUFDeUIsTUFBTSxDQUFDeUIsQ0FBQUEsSUFBS0EsRUFBRUksUUFBUSxFQUFFQyxLQUFLLENBQUMsR0FBR3BFO1lBQ25FLElBQUltRSxTQUFTWCxNQUFNLEdBQUcsR0FBRztnQkFDdkJULFFBQVFDLEdBQUcsQ0FBQztnQkFDWixPQUFPbUI7WUFDVDtRQUNGO1FBRUFwQixRQUFRQyxHQUFHLENBQUM7UUFDWixNQUFNaUIsSUFBSXJFLHlEQUFLQSxDQUNiYyxvQkFDQWIseURBQUtBLENBQUMsWUFBWSxNQUFNLE9BQ3hCSSwyREFBT0EsQ0FBQyxhQUFhLFNBQ3JCRDtRQUdGLE1BQU1rRCxXQUFXLE1BQU0xRCwyREFBT0EsQ0FBQ3lFO1FBQy9CLE1BQU1kLFdBQVdELFNBQVNFLElBQUksQ0FBQ2pCLEdBQUcsQ0FBQzFDLENBQUFBLE1BQVE7Z0JBQ3pDNEQsSUFBSTVELElBQUk0RCxFQUFFO2dCQUNWLEdBQUc1RCxJQUFJNkQsSUFBSSxFQUFFO1lBQ2Y7UUFFQSxvQkFBb0I7UUFDcEJILFNBQVNyQixPQUFPLENBQUNYLENBQUFBO1lBQ2ZQLGFBQWFFLElBQUksQ0FBQ0ssUUFBUWtDLEVBQUUsQ0FBQyxHQUFHbEM7WUFFaEMsa0NBQWtDO1lBQ2xDLElBQUlBLFFBQVFLLFFBQVEsRUFBRTtnQkFDcEIsSUFBSSxDQUFDWixhQUFhRyxVQUFVLENBQUNJLFFBQVFLLFFBQVEsQ0FBQyxFQUFFO29CQUM5Q1osYUFBYUcsVUFBVSxDQUFDSSxRQUFRSyxRQUFRLENBQUMsR0FBRyxFQUFFO2dCQUNoRDtnQkFFQSxvREFBb0Q7Z0JBQ3BELE1BQU1xQyxnQkFBZ0JqRCxhQUFhRyxVQUFVLENBQUNJLFFBQVFLLFFBQVEsQ0FBQyxDQUFDc0MsU0FBUyxDQUN2RUMsQ0FBQUEsSUFBS0EsRUFBRVYsRUFBRSxLQUFLbEMsUUFBUWtDLEVBQUU7Z0JBRzFCLElBQUlRLGlCQUFpQixHQUFHO29CQUN0QmpELGFBQWFHLFVBQVUsQ0FBQ0ksUUFBUUssUUFBUSxDQUFDLENBQUNxQyxjQUFjLEdBQUcxQztnQkFDN0QsT0FBTztvQkFDTFAsYUFBYUcsVUFBVSxDQUFDSSxRQUFRSyxRQUFRLENBQUMsQ0FBQytCLElBQUksQ0FBQ3BDO2dCQUNqRDtZQUNGO1FBQ0Y7UUFFQSxPQUFPZ0M7SUFDVCxFQUFFLE9BQU9NLE9BQU87UUFDZFYsUUFBUVUsS0FBSyxDQUFDLG9DQUFvQ0E7UUFDbEQsTUFBTSxJQUFJQyxNQUFNO0lBQ2xCO0FBQ0YsRUFBRTtBQUVGLGdDQUFnQztBQUN6QixNQUFNVyxpQkFBaUI7UUFBT3JFLHlFQUFnQjtJQUNuRCxJQUFJO1FBQ0YsOENBQThDO1FBQzlDLElBQUkwQyxrQkFBa0I5QixhQUFhQyxHQUFHLEVBQUU7WUFDdEMsTUFBTXlELGNBQWMxRCxhQUFhQyxHQUFHLENBQ2pDeUIsTUFBTSxDQUFDeUIsQ0FBQUEsSUFBS0EsRUFBRVEsR0FBRyxFQUNqQkgsS0FBSyxDQUFDLEdBQUdwRTtZQUVaLElBQUlzRSxZQUFZZCxNQUFNLEdBQUcsR0FBRztnQkFDMUJULFFBQVFDLEdBQUcsQ0FBQztnQkFDWixPQUFPc0I7WUFDVDtRQUNGO1FBRUF2QixRQUFRQyxHQUFHLENBQUM7UUFDWixNQUFNaUIsSUFBSXJFLHlEQUFLQSxDQUNiYyxvQkFDQWIseURBQUtBLENBQUMsT0FBTyxNQUFNLE9BQ25CSSwyREFBT0EsQ0FBQyxhQUFhLFNBQ3JCRDtRQUdGLE1BQU1rRCxXQUFXLE1BQU0xRCwyREFBT0EsQ0FBQ3lFO1FBQy9CLE1BQU1kLFdBQVdELFNBQVNFLElBQUksQ0FBQ2pCLEdBQUcsQ0FBQzFDLENBQUFBLE1BQVE7Z0JBQ3pDNEQsSUFBSTVELElBQUk0RCxFQUFFO2dCQUNWLEdBQUc1RCxJQUFJNkQsSUFBSSxFQUFFO1lBQ2Y7UUFFQSxvQkFBb0I7UUFDcEJILFNBQVNyQixPQUFPLENBQUNYLENBQUFBO1lBQ2ZQLGFBQWFFLElBQUksQ0FBQ0ssUUFBUWtDLEVBQUUsQ0FBQyxHQUFHbEM7WUFFaEMsa0NBQWtDO1lBQ2xDLElBQUlBLFFBQVFLLFFBQVEsRUFBRTtnQkFDcEIsSUFBSSxDQUFDWixhQUFhRyxVQUFVLENBQUNJLFFBQVFLLFFBQVEsQ0FBQyxFQUFFO29CQUM5Q1osYUFBYUcsVUFBVSxDQUFDSSxRQUFRSyxRQUFRLENBQUMsR0FBRyxFQUFFO2dCQUNoRDtnQkFFQSxvREFBb0Q7Z0JBQ3BELE1BQU1xQyxnQkFBZ0JqRCxhQUFhRyxVQUFVLENBQUNJLFFBQVFLLFFBQVEsQ0FBQyxDQUFDc0MsU0FBUyxDQUN2RUMsQ0FBQUEsSUFBS0EsRUFBRVYsRUFBRSxLQUFLbEMsUUFBUWtDLEVBQUU7Z0JBRzFCLElBQUlRLGlCQUFpQixHQUFHO29CQUN0QmpELGFBQWFHLFVBQVUsQ0FBQ0ksUUFBUUssUUFBUSxDQUFDLENBQUNxQyxjQUFjLEdBQUcxQztnQkFDN0QsT0FBTztvQkFDTFAsYUFBYUcsVUFBVSxDQUFDSSxRQUFRSyxRQUFRLENBQUMsQ0FBQytCLElBQUksQ0FBQ3BDO2dCQUNqRDtZQUNGO1FBQ0Y7UUFFQSxPQUFPZ0M7SUFDVCxFQUFFLE9BQU9NLE9BQU87UUFDZFYsUUFBUVUsS0FBSyxDQUFDLCtCQUErQkE7UUFDN0MsTUFBTSxJQUFJQyxNQUFNO0lBQ2xCO0FBQ0YsRUFBRTtBQUVGLGlDQUFpQztBQUMxQixNQUFNYyxpQkFBaUIsT0FBT25CO0lBQ25DLElBQUk7UUFDRiwrQkFBK0I7UUFDL0IsSUFBSXpDLGFBQWFFLElBQUksQ0FBQ3VDLEdBQUcsRUFBRTtZQUN6Qk4sUUFBUUMsR0FBRyxDQUFDLHFCQUF3QixPQUFISyxJQUFHO1lBQ3BDLE9BQU96QyxhQUFhRSxJQUFJLENBQUN1QyxHQUFHO1FBQzlCO1FBRUFOLFFBQVFDLEdBQUcsQ0FBQyxvQkFBdUIsT0FBSEssSUFBRztRQUNuQyxNQUFNb0IsYUFBYWhGLHVEQUFHQSxDQUFDZSxJQUFJLFlBQVk2QztRQUN2QyxNQUFNSCxXQUFXLE1BQU14RCwwREFBTUEsQ0FBQytFO1FBRTlCLElBQUl2QixTQUFTd0IsTUFBTSxJQUFJO1lBQ3JCLE1BQU12RCxVQUFVO2dCQUNka0MsSUFBSUgsU0FBU0csRUFBRTtnQkFDZixHQUFHSCxTQUFTSSxJQUFJLEVBQUU7WUFDcEI7WUFFQSxlQUFlO1lBQ2YxQyxhQUFhRSxJQUFJLENBQUN1QyxHQUFHLEdBQUdsQztZQUV4QixPQUFPQTtRQUNUO1FBQ0EsT0FBTztJQUNULEVBQUUsT0FBT3NDLE9BQU87UUFDZFYsUUFBUVUsS0FBSyxDQUFDLDBCQUEwQkE7UUFDeEMsTUFBTSxJQUFJQyxNQUFNO0lBQ2xCO0FBQ0YsRUFBRTtBQUVGLHFDQUFxQztBQUNyQyxNQUFNaUIseUJBQXlCLENBQUNDLFdBQW1CQztJQUNqRCx5QkFBeUI7SUFDekIsSUFBSWpFLGFBQWFFLElBQUksQ0FBQzhELFVBQVUsRUFBRTtRQUNoQyxPQUFPaEUsYUFBYUUsSUFBSSxDQUFDOEQsVUFBVTtJQUNyQztJQUVBLHFEQUFxRDtJQUNyRCxJQUFJQyxjQUFjakUsYUFBYUcsVUFBVSxDQUFDOEQsV0FBVyxFQUFFO1FBQ3JEakUsYUFBYUcsVUFBVSxDQUFDOEQsV0FBVyxHQUFHakUsYUFBYUcsVUFBVSxDQUFDOEQsV0FBVyxDQUFDdkMsTUFBTSxDQUM5RXlCLENBQUFBLElBQUtBLEVBQUVWLEVBQUUsS0FBS3VCO0lBRWxCO0lBRUEsdURBQXVEO0lBQ3ZEaEUsYUFBYUMsR0FBRyxHQUFHO0FBQ3JCO0FBRUEscUJBQXFCO0FBQ2QsTUFBTWlFLG9CQUFvQjtJQUMvQmxFLGFBQWFDLEdBQUcsR0FBRztJQUNuQkQsYUFBYUUsSUFBSSxHQUFHLENBQUM7SUFDckJGLGFBQWFHLFVBQVUsR0FBRyxDQUFDO0lBQzNCSCxhQUFhSSxXQUFXLEdBQUc7QUFDN0IsRUFBRTtBQUVGLG1DQUFtQztBQUM1QixNQUFNK0QscUJBQXFCLE9BQU9DO0lBQ3ZDLElBQUk7UUFDRiwyQkFBMkI7UUFDM0IsTUFBTUMsWUFBWSxJQUFJdEMsT0FBT3VDLE9BQU87UUFDcEMsTUFBTUMsV0FBVyxXQUF3QkgsT0FBYkMsV0FBVSxLQUE0QyxPQUF6Q0QsS0FBSzVELElBQUksQ0FBQ2dFLE9BQU8sQ0FBQyxrQkFBa0I7UUFFN0UsNENBQTRDO1FBQzVDLE1BQU1DLGFBQWFqRixxREFBR0EsQ0FBQ0ssU0FBUyxrQkFBMkIsT0FBVDBFO1FBRWxELGtCQUFrQjtRQUNsQixNQUFNOUUsNkRBQVdBLENBQUNnRixZQUFZTDtRQUU5Qix1QkFBdUI7UUFDdkIsTUFBTU0sY0FBYyxNQUFNaEYsZ0VBQWNBLENBQUMrRTtRQUN6QyxPQUFPQztJQUNULEVBQUUsT0FBTzdCLE9BQU87UUFDZFYsUUFBUVUsS0FBSyxDQUFDLDBCQUEwQkE7UUFDeEMsTUFBTSxJQUFJQyxNQUFNO0lBQ2xCO0FBQ0YsRUFBRTtBQUVGLDZDQUE2QztBQUN0QyxNQUFNNkIscUJBQXFCLE9BQU9DO0lBQ3ZDLElBQUk7UUFDRixxQ0FBcUM7UUFDckMsTUFBTUMsYUFBYUMsbUJBQW1CRjtRQUN0QyxNQUFNRyxhQUFhRixXQUFXRyxPQUFPLENBQUM7UUFFdEMsSUFBSUQsZUFBZSxDQUFDLEdBQUc7WUFDckI1QyxRQUFROEMsSUFBSSxDQUFDLCtEQUErREw7WUFDNUU7UUFDRjtRQUVBLE1BQU1NLFdBQVdMLFdBQVdHLE9BQU8sQ0FBQyxLQUFLRDtRQUN6QyxNQUFNSSxXQUFXRCxhQUFhLENBQUMsSUFDM0JMLFdBQVdPLFNBQVMsQ0FBQ0wsWUFBWUcsWUFDakNMLFdBQVdPLFNBQVMsQ0FBQ0w7UUFFekIsaUNBQWlDO1FBQ2pDLE1BQU1NLFdBQVc3RixxREFBR0EsQ0FBQ0ssU0FBU3NGO1FBRTlCLGtCQUFrQjtRQUNsQixNQUFNeEYsOERBQVlBLENBQUMwRjtRQUNuQmxELFFBQVFDLEdBQUcsQ0FBQyx1Q0FBdUMrQztJQUNyRCxFQUFFLE9BQU90QyxPQUFPO1FBQ2RWLFFBQVFVLEtBQUssQ0FBQyxpQ0FBaUNBO0lBQy9DLHVFQUF1RTtJQUN2RSwrQkFBK0I7SUFDakM7QUFDRixFQUFFO0FBRUYsMkRBQTJEO0FBQ3BELE1BQU15QyxhQUFhLE9BQU8vRTtJQUMvQixJQUFJO1FBQ0Y0QixRQUFRQyxHQUFHLENBQUMsZ0NBQWdDN0I7UUFFNUMsd0JBQXdCO1FBQ3hCLE1BQU1nRixrQkFBa0JqRixnQkFBZ0JDO1FBQ3hDLElBQUlnRixpQkFBaUI7WUFDbkIsTUFBTSxJQUFJekMsTUFBTXlDO1FBQ2xCO1FBRUEsdUNBQXVDO1FBQ3ZDLE1BQU14RSxpQkFBaUJELGlCQUFpQlA7UUFDeEM0QixRQUFRQyxHQUFHLENBQUMsdUNBQXVDckI7UUFFbkQsMERBQTBEO1FBQzFELE1BQU15RSxhQUFhLE1BQU10RyxrRUFBY0EsQ0FBQ1UsSUFBSSxPQUFPNkY7WUFDakQsMkJBQTJCO1lBQzNCLE1BQU1DLFNBQVMsTUFBTTNHLDBEQUFNQSxDQUFDZSxvQkFBb0JpQjtZQUNoRCxNQUFNNEUsbUJBQW1CO2dCQUFFbEQsSUFBSWlELE9BQU9qRCxFQUFFO2dCQUFFLEdBQUcxQixjQUFjO1lBQUM7WUFFNUQsa0NBQWtDO1lBQ2xDLE1BQU02RSxjQUFjL0csdURBQUdBLENBQUNrQixzQkFBc0JnQixlQUFlSCxRQUFRO1lBQ3JFLE1BQU1pRixjQUFjLE1BQU1KLFlBQVlLLEdBQUcsQ0FBQ0Y7WUFFMUMsSUFBSUMsWUFBWS9CLE1BQU0sSUFBSTtnQkFDeEIsMkJBQTJCO2dCQUMzQjJCLFlBQVlNLE1BQU0sQ0FBQ0gsYUFBYTtvQkFDOUJJLE9BQU8sQ0FBQ0gsWUFBWW5ELElBQUksR0FBR3NELEtBQUssSUFBSSxLQUFLO29CQUN6Q25FLFdBQVcxQyxtRUFBZUE7Z0JBQzVCO1lBQ0YsT0FBTztnQkFDTCxzQkFBc0I7Z0JBQ3RCc0csWUFBWVEsR0FBRyxDQUFDTCxhQUFhO29CQUMzQm5ELElBQUkxQixlQUFlSCxRQUFRO29CQUMzQkosTUFBTU8sZUFBZUgsUUFBUSxDQUFDc0YsTUFBTSxDQUFDLEdBQUdDLFdBQVcsS0FBS3BGLGVBQWVILFFBQVEsQ0FBQzRDLEtBQUssQ0FBQztvQkFDdEZ3QyxPQUFPO29CQUNQcEUsV0FBV3pDLG1FQUFlQTtvQkFDMUIwQyxXQUFXMUMsbUVBQWVBO2dCQUM1QjtZQUNGO1lBRUEsT0FBT3dHO1FBQ1Q7UUFFQSxvQ0FBb0M7UUFDcEMsSUFBSTNGLGFBQWFDLEdBQUcsRUFBRTtZQUNwQkQsYUFBYUMsR0FBRyxDQUFDbUcsT0FBTyxDQUFDWjtRQUMzQjtRQUVBeEYsYUFBYUUsSUFBSSxDQUFDc0YsV0FBVy9DLEVBQUUsQ0FBQyxHQUFHK0M7UUFFbkMsSUFBSUEsV0FBVzVFLFFBQVEsRUFBRTtZQUN2QixJQUFJLENBQUNaLGFBQWFHLFVBQVUsQ0FBQ3FGLFdBQVc1RSxRQUFRLENBQUMsRUFBRTtnQkFDakRaLGFBQWFHLFVBQVUsQ0FBQ3FGLFdBQVc1RSxRQUFRLENBQUMsR0FBRyxFQUFFO1lBQ25EO1lBQ0FaLGFBQWFHLFVBQVUsQ0FBQ3FGLFdBQVc1RSxRQUFRLENBQUMsQ0FBQ3dGLE9BQU8sQ0FBQ1o7UUFDdkQ7UUFFQXJELFFBQVFDLEdBQUcsQ0FBQyx1Q0FBdUNvRCxXQUFXL0MsRUFBRTtRQUNoRSxPQUFPK0M7SUFDVCxFQUFFLE9BQU8zQyxPQUFPO1FBQ2RWLFFBQVFVLEtBQUssQ0FBQyxzQ0FBc0NBO1FBQ3BELE1BQU1BO0lBQ1I7QUFDRixFQUFFO0FBRUYsbUJBQW1CO0FBQ1osTUFBTXdELGdCQUFnQixPQUFPNUQsSUFBWWxDO0lBQzlDLElBQUk7UUFDRixNQUFNc0QsYUFBYWhGLHVEQUFHQSxDQUFDZSxJQUFJLFlBQVk2QztRQUV2Qyx3REFBd0Q7UUFDeEQsTUFBTTZELHNCQUFzQixNQUFNeEgsMERBQU1BLENBQUMrRTtRQUN6QyxJQUFJLENBQUN5QyxvQkFBb0J4QyxNQUFNLElBQUk7WUFDakMsTUFBTSxJQUFJaEIsTUFBTTtRQUNsQjtRQUVBLE1BQU15RCxrQkFBa0JELG9CQUFvQjVELElBQUk7UUFDaEQsTUFBTThELGlCQUFpQjFGLGlCQUFpQlA7UUFFeEMsNENBQTRDO1FBQzVDaUcsZUFBZTNFLFNBQVMsR0FBRzFDLG1FQUFlQTtRQUUxQyxNQUFNRCxrRUFBY0EsQ0FBQ1UsSUFBSSxPQUFPNkY7WUFDOUIsMEJBQTBCO1lBQzFCQSxZQUFZTSxNQUFNLENBQUNsQyxZQUFZMkM7WUFFL0IsK0RBQStEO1lBQy9ELElBQUlqRyxRQUFRSyxRQUFRLElBQUkyRixnQkFBZ0IzRixRQUFRLEtBQUtMLFFBQVFLLFFBQVEsRUFBRTtnQkFDckUsOEJBQThCO2dCQUM5QixNQUFNNkYsaUJBQWlCNUgsdURBQUdBLENBQUNrQixzQkFBc0J3RyxnQkFBZ0IzRixRQUFRO2dCQUN6RSxNQUFNOEYsaUJBQWlCLE1BQU1qQixZQUFZSyxHQUFHLENBQUNXO2dCQUU3QyxJQUFJQyxlQUFlNUMsTUFBTSxJQUFJO29CQUMzQixNQUFNNkMsV0FBV0QsZUFBZWhFLElBQUksR0FBR3NELEtBQUssSUFBSTtvQkFDaEQsSUFBSVcsV0FBVyxHQUFHO3dCQUNoQmxCLFlBQVlNLE1BQU0sQ0FBQ1UsZ0JBQWdCOzRCQUNqQ1QsT0FBT1csV0FBVzs0QkFDbEI5RSxXQUFXMUMsbUVBQWVBO3dCQUM1QjtvQkFDRixPQUFPO3dCQUNMLHNDQUFzQzt3QkFDdENzRyxZQUFZbUIsTUFBTSxDQUFDSDtvQkFDckI7Z0JBQ0Y7Z0JBRUEsOEJBQThCO2dCQUM5QixNQUFNSSxpQkFBaUJoSSx1REFBR0EsQ0FBQ2tCLHNCQUFzQlEsUUFBUUssUUFBUTtnQkFDakUsTUFBTWtHLGlCQUFpQixNQUFNckIsWUFBWUssR0FBRyxDQUFDZTtnQkFFN0MsSUFBSUMsZUFBZWhELE1BQU0sSUFBSTtvQkFDM0IyQixZQUFZTSxNQUFNLENBQUNjLGdCQUFnQjt3QkFDakNiLE9BQU8sQ0FBQ2MsZUFBZXBFLElBQUksR0FBR3NELEtBQUssSUFBSSxLQUFLO3dCQUM1Q25FLFdBQVcxQyxtRUFBZUE7b0JBQzVCO2dCQUNGLE9BQU87b0JBQ0xzRyxZQUFZUSxHQUFHLENBQUNZLGdCQUFnQjt3QkFDOUJwRSxJQUFJbEMsUUFBUUssUUFBUTt3QkFDcEJKLE1BQU1ELFFBQVFLLFFBQVEsQ0FBQ3NGLE1BQU0sQ0FBQyxHQUFHQyxXQUFXLEtBQUs1RixRQUFRSyxRQUFRLENBQUM0QyxLQUFLLENBQUM7d0JBQ3hFd0MsT0FBTzt3QkFDUHBFLFdBQVd6QyxtRUFBZUE7d0JBQzFCMEMsV0FBVzFDLG1FQUFlQTtvQkFDNUI7Z0JBQ0Y7WUFDRjtRQUNGO1FBRUEsZUFBZTtRQUNmLElBQUlhLGFBQWFFLElBQUksQ0FBQ3VDLEdBQUcsRUFBRTtZQUN6QixNQUFNc0UsaUJBQWlCO2dCQUFFLEdBQUcvRyxhQUFhRSxJQUFJLENBQUN1QyxHQUFHO2dCQUFFLEdBQUdsQyxPQUFPO1lBQUM7WUFDOURQLGFBQWFFLElBQUksQ0FBQ3VDLEdBQUcsR0FBR3NFO1lBRXhCLDRDQUE0QztZQUM1QyxJQUFJL0csYUFBYUMsR0FBRyxFQUFFO2dCQUNwQixNQUFNK0csUUFBUWhILGFBQWFDLEdBQUcsQ0FBQ2lELFNBQVMsQ0FBQ0MsQ0FBQUEsSUFBS0EsRUFBRVYsRUFBRSxLQUFLQTtnQkFDdkQsSUFBSXVFLFNBQVMsR0FBRztvQkFDZGhILGFBQWFDLEdBQUcsQ0FBQytHLE1BQU0sR0FBR0Q7Z0JBQzVCO1lBQ0Y7WUFFQSxrQ0FBa0M7WUFDbEMsSUFBSXhHLFFBQVFLLFFBQVEsSUFBSTJGLGdCQUFnQjNGLFFBQVEsS0FBS0wsUUFBUUssUUFBUSxFQUFFO2dCQUNyRSxpQ0FBaUM7Z0JBQ2pDLElBQUlaLGFBQWFHLFVBQVUsQ0FBQ29HLGdCQUFnQjNGLFFBQVEsQ0FBQyxFQUFFO29CQUNyRFosYUFBYUcsVUFBVSxDQUFDb0csZ0JBQWdCM0YsUUFBUSxDQUFDLEdBQUdaLGFBQWFHLFVBQVUsQ0FBQ29HLGdCQUFnQjNGLFFBQVEsQ0FBQyxDQUFDYyxNQUFNLENBQzFHeUIsQ0FBQUEsSUFBS0EsRUFBRVYsRUFBRSxLQUFLQTtnQkFFbEI7Z0JBRUEsNEJBQTRCO2dCQUM1QixJQUFJLENBQUN6QyxhQUFhRyxVQUFVLENBQUNJLFFBQVFLLFFBQVEsQ0FBQyxFQUFFO29CQUM5Q1osYUFBYUcsVUFBVSxDQUFDSSxRQUFRSyxRQUFRLENBQUMsR0FBRyxFQUFFO2dCQUNoRDtnQkFDQVosYUFBYUcsVUFBVSxDQUFDSSxRQUFRSyxRQUFRLENBQUMsQ0FBQytCLElBQUksQ0FBQ29FO1lBQ2pELE9BQU8sSUFBSXhHLFFBQVFLLFFBQVEsRUFBRTtnQkFDM0IsMEJBQTBCO2dCQUMxQixJQUFJWixhQUFhRyxVQUFVLENBQUNJLFFBQVFLLFFBQVEsQ0FBQyxFQUFFO29CQUM3QyxNQUFNcUcsV0FBV2pILGFBQWFHLFVBQVUsQ0FBQ0ksUUFBUUssUUFBUSxDQUFDLENBQUNzQyxTQUFTLENBQUNDLENBQUFBLElBQUtBLEVBQUVWLEVBQUUsS0FBS0E7b0JBQ25GLElBQUl3RSxZQUFZLEdBQUc7d0JBQ2pCakgsYUFBYUcsVUFBVSxDQUFDSSxRQUFRSyxRQUFRLENBQUMsQ0FBQ3FHLFNBQVMsR0FBR0Y7b0JBQ3hEO2dCQUNGO1lBQ0Y7UUFDRixPQUFPO1lBQ0wseURBQXlEO1lBQ3pEN0M7UUFDRjtJQUVGLEVBQUUsT0FBT3JCLE9BQU87UUFDZFYsUUFBUVUsS0FBSyxDQUFDLDJCQUEyQkE7UUFDekMsTUFBTSxJQUFJQyxNQUFNO0lBQ2xCO0FBQ0YsRUFBRTtBQUVGLG1CQUFtQjtBQUNaLE1BQU1vRSxnQkFBZ0IsT0FBT3pFO0lBQ2xDLElBQUk7UUFDRixNQUFNb0IsYUFBYWhGLHVEQUFHQSxDQUFDZSxJQUFJLFlBQVk2QztRQUV2QyxpREFBaUQ7UUFDakQsTUFBTTBFLGNBQWMsTUFBTXJJLDBEQUFNQSxDQUFDK0U7UUFDakMsSUFBSSxDQUFDc0QsWUFBWXJELE1BQU0sSUFBSTtZQUN6QixNQUFNLElBQUloQixNQUFNO1FBQ2xCO1FBRUEsTUFBTXNFLGNBQWNELFlBQVl6RSxJQUFJO1FBRXBDLHdDQUF3QztRQUN4QyxJQUFJMEUsWUFBWXZHLEtBQUssRUFBRTtZQUNyQixJQUFJO2dCQUNGLE1BQU04RCxtQkFBbUJ5QyxZQUFZdkcsS0FBSztZQUM1QyxFQUFFLE9BQU9nQyxPQUFPO2dCQUNkVixRQUFRVSxLQUFLLENBQUMsaUNBQWlDQTtZQUMvQyw4REFBOEQ7WUFDaEU7UUFDRjtRQUVBLE1BQU0zRCxrRUFBY0EsQ0FBQ1UsSUFBSSxPQUFPNkY7WUFDOUIsaUJBQWlCO1lBQ2pCQSxZQUFZbUIsTUFBTSxDQUFDL0M7WUFFbkIsd0JBQXdCO1lBQ3hCLElBQUl1RCxZQUFZeEcsUUFBUSxFQUFFO2dCQUN4QixNQUFNZ0YsY0FBYy9HLHVEQUFHQSxDQUFDa0Isc0JBQXNCcUgsWUFBWXhHLFFBQVE7Z0JBQ2xFLE1BQU1pRixjQUFjLE1BQU1KLFlBQVlLLEdBQUcsQ0FBQ0Y7Z0JBRTFDLElBQUlDLFlBQVkvQixNQUFNLElBQUk7b0JBQ3hCLE1BQU1rQyxRQUFRSCxZQUFZbkQsSUFBSSxHQUFHc0QsS0FBSyxJQUFJO29CQUMxQyxJQUFJQSxRQUFRLEdBQUc7d0JBQ2JQLFlBQVlNLE1BQU0sQ0FBQ0gsYUFBYTs0QkFDOUJJLE9BQU9BLFFBQVE7NEJBQ2ZuRSxXQUFXMUMsbUVBQWVBO3dCQUM1QjtvQkFDRixPQUFPO3dCQUNMLHNDQUFzQzt3QkFDdENzRyxZQUFZbUIsTUFBTSxDQUFDaEI7b0JBQ3JCO2dCQUNGO1lBQ0Y7UUFDRjtRQUVBLGVBQWU7UUFDZjdCLHVCQUF1QnRCLElBQUkyRSxZQUFZeEcsUUFBUTtJQUVqRCxFQUFFLE9BQU9pQyxPQUFPO1FBQ2RWLFFBQVFVLEtBQUssQ0FBQywyQkFBMkJBO1FBQ3pDLE1BQU0sSUFBSUMsTUFBTTtJQUNsQjtBQUNGLEVBQUU7QUFFRix5Q0FBeUM7QUFDbEMsTUFBTXVFLG1CQUFtQjtJQUM5QixJQUFJO1FBQ0YsTUFBTS9FLFdBQVcsTUFBTTFELDJEQUFPQSxDQUFDbUI7UUFDL0IsT0FBT3VDLFNBQVNFLElBQUksQ0FBQ2pCLEdBQUcsQ0FBQzFDLENBQUFBLE1BQU9BLElBQUk2RCxJQUFJO0lBQzFDLEVBQUUsT0FBT0csT0FBTztRQUNkVixRQUFRVSxLQUFLLENBQUMsNkJBQTZCQTtRQUMzQyxNQUFNLElBQUlDLE1BQU07SUFDbEI7QUFDRixFQUFFIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL3V0aWxzL2ZpcmVzdG9yZS50cz9hYTAwIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGFwcCB9IGZyb20gJy4vZmlyZWJhc2UnO1xyXG5pbXBvcnQgeyBnZXRGaXJlc3RvcmUsIGNvbGxlY3Rpb24sIGdldERvY3MsIGRvYywgZ2V0RG9jLCBhZGREb2MsIHVwZGF0ZURvYywgZGVsZXRlRG9jLCBxdWVyeSwgd2hlcmUsIHJ1blRyYW5zYWN0aW9uLCBzZXJ2ZXJUaW1lc3RhbXAsIERvY3VtZW50UmVmZXJlbmNlLCBsaW1pdCwgb3JkZXJCeSwgc3RhcnRBZnRlciwgUXVlcnlEb2N1bWVudFNuYXBzaG90LCBRdWVyeVNuYXBzaG90IH0gZnJvbSAnZmlyZWJhc2UvZmlyZXN0b3JlJztcclxuaW1wb3J0IHsgZ2V0U3RvcmFnZSwgcmVmLCB1cGxvYWRCeXRlcywgZ2V0RG93bmxvYWRVUkwsIGRlbGV0ZU9iamVjdCB9IGZyb20gJ2ZpcmViYXNlL3N0b3JhZ2UnO1xyXG5pbXBvcnQgeyBQcm9kdWN0IH0gZnJvbSAnLi4vZGF0YS9wcm9kdWN0cyc7XHJcblxyXG4vLyBJbml0aWFsaXplIEZpcmVzdG9yZVxyXG5leHBvcnQgY29uc3QgZGIgPSBnZXRGaXJlc3RvcmUoYXBwKTtcclxuXHJcbi8vIEluaXRpYWxpemUgU3RvcmFnZVxyXG5leHBvcnQgY29uc3Qgc3RvcmFnZSA9IGdldFN0b3JhZ2UoYXBwKTtcclxuXHJcbi8vIENvbGxlY3Rpb24gcmVmZXJlbmNlc1xyXG5jb25zdCBwcm9kdWN0c0NvbGxlY3Rpb24gPSBjb2xsZWN0aW9uKGRiLCAncHJvZHVjdHMnKTtcclxuY29uc3QgY2F0ZWdvcmllc0NvbGxlY3Rpb24gPSBjb2xsZWN0aW9uKGRiLCAnY2F0ZWdvcmllcycpO1xyXG5cclxuLy8gQ2FjaGUgZm9yIHByb2R1Y3RzXHJcbmNvbnN0IHByb2R1Y3RDYWNoZToge1xyXG4gIGFsbDogUHJvZHVjdFtdIHwgbnVsbDtcclxuICBieUlkOiBSZWNvcmQ8c3RyaW5nLCBQcm9kdWN0PjtcclxuICBieUNhdGVnb3J5OiBSZWNvcmQ8c3RyaW5nLCBQcm9kdWN0W10+O1xyXG4gIGxhc3RGZXRjaGVkOiBudW1iZXI7XHJcbn0gPSB7XHJcbiAgYWxsOiBudWxsLFxyXG4gIGJ5SWQ6IHt9LFxyXG4gIGJ5Q2F0ZWdvcnk6IHt9LFxyXG4gIGxhc3RGZXRjaGVkOiAwXHJcbn07XHJcblxyXG4vLyBDYWNoZSBleHBpcmF0aW9uIHRpbWUgKDUgbWludXRlcylcclxuY29uc3QgQ0FDSEVfRVhQSVJBVElPTiA9IDUgKiA2MCAqIDEwMDA7XHJcblxyXG4vLyBWYWxpZGF0ZSBwcm9kdWN0IGRhdGEgYmVmb3JlIHNhdmluZ1xyXG5jb25zdCB2YWxpZGF0ZVByb2R1Y3QgPSAocHJvZHVjdDogUGFydGlhbDxQcm9kdWN0Pik6IHN0cmluZyB8IG51bGwgPT4ge1xyXG4gIGlmICghcHJvZHVjdC5uYW1lIHx8IHR5cGVvZiBwcm9kdWN0Lm5hbWUgIT09ICdzdHJpbmcnKSB7XHJcbiAgICByZXR1cm4gJ1Byb2R1Y3QgbmFtZSBpcyByZXF1aXJlZCc7XHJcbiAgfVxyXG4gIFxyXG4gIGlmICghcHJvZHVjdC5wcmljZSB8fCBpc05hTihOdW1iZXIocHJvZHVjdC5wcmljZSkpKSB7XHJcbiAgICByZXR1cm4gJ1ZhbGlkIHByb2R1Y3QgcHJpY2UgaXMgcmVxdWlyZWQnO1xyXG4gIH1cclxuICBcclxuICBpZiAoIXByb2R1Y3QuY2F0ZWdvcnkgfHwgdHlwZW9mIHByb2R1Y3QuY2F0ZWdvcnkgIT09ICdzdHJpbmcnKSB7XHJcbiAgICByZXR1cm4gJ1Byb2R1Y3QgY2F0ZWdvcnkgaXMgcmVxdWlyZWQnO1xyXG4gIH1cclxuICBcclxuICBpZiAoIXByb2R1Y3QuaW1hZ2UgfHwgdHlwZW9mIHByb2R1Y3QuaW1hZ2UgIT09ICdzdHJpbmcnKSB7XHJcbiAgICByZXR1cm4gJ1Byb2R1Y3QgaW1hZ2UgaXMgcmVxdWlyZWQnO1xyXG4gIH1cclxuICBcclxuICByZXR1cm4gbnVsbDsgLy8gTm8gZXJyb3JzXHJcbn07XHJcblxyXG4vLyBDbGVhbiBwcm9kdWN0IGRhdGEgZm9yIEZpcmVzdG9yZVxyXG5jb25zdCBjbGVhblByb2R1Y3REYXRhID0gKHByb2R1Y3Q6IFJlY29yZDxzdHJpbmcsIGFueT4pOiBSZWNvcmQ8c3RyaW5nLCBhbnk+ID0+IHtcclxuICBjb25zdCBjbGVhbmVkUHJvZHVjdDogUmVjb3JkPHN0cmluZywgYW55PiA9IHt9O1xyXG4gIFxyXG4gIE9iamVjdC5lbnRyaWVzKHByb2R1Y3QpLmZvckVhY2goKFtrZXksIHZhbHVlXSkgPT4ge1xyXG4gICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQgJiYgdmFsdWUgIT09IG51bGwpIHtcclxuICAgICAgLy8gSGFuZGxlIHNwZWNpZmljIGZpZWxkIHR5cGVzXHJcbiAgICAgIGlmIChrZXkgPT09ICdwcmljZScgfHwga2V5ID09PSAnb3JpZ2luYWxQcmljZScgfHwga2V5ID09PSAnc3RvY2snKSB7XHJcbiAgICAgICAgY2xlYW5lZFByb2R1Y3Rba2V5XSA9IE51bWJlcih2YWx1ZSk7XHJcbiAgICAgIH0gZWxzZSBpZiAoa2V5ID09PSAnc2l6ZXMnICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcclxuICAgICAgICBjbGVhbmVkUHJvZHVjdFtrZXldID0gdmFsdWUuc3BsaXQoJywnKS5tYXAoKHM6IHN0cmluZykgPT4gcy50cmltKCkpLmZpbHRlcihCb29sZWFuKTtcclxuICAgICAgfSBlbHNlIGlmIChrZXkgPT09ICdmZWF0dXJlZCcgJiYgdHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xyXG4gICAgICAgIGNsZWFuZWRQcm9kdWN0W2tleV0gPSB2YWx1ZSA9PT0gJ3RydWUnO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIGNsZWFuZWRQcm9kdWN0W2tleV0gPSB2YWx1ZTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH0pO1xyXG4gIFxyXG4gIC8vIEFkZCB0aW1lc3RhbXBzXHJcbiAgaWYgKCFjbGVhbmVkUHJvZHVjdC5jcmVhdGVkQXQpIHtcclxuICAgIGNsZWFuZWRQcm9kdWN0LmNyZWF0ZWRBdCA9IHNlcnZlclRpbWVzdGFtcCgpO1xyXG4gIH1cclxuICBjbGVhbmVkUHJvZHVjdC51cGRhdGVkQXQgPSBzZXJ2ZXJUaW1lc3RhbXAoKTtcclxuICBcclxuICByZXR1cm4gY2xlYW5lZFByb2R1Y3Q7XHJcbn07XHJcblxyXG4vLyBDaGVjayBpZiBjYWNoZSBpcyB2YWxpZFxyXG5jb25zdCBpc0NhY2hlVmFsaWQgPSAoKTogYm9vbGVhbiA9PiB7XHJcbiAgcmV0dXJuIChcclxuICAgIHByb2R1Y3RDYWNoZS5hbGwgIT09IG51bGwgJiZcclxuICAgIERhdGUubm93KCkgLSBwcm9kdWN0Q2FjaGUubGFzdEZldGNoZWQgPCBDQUNIRV9FWFBJUkFUSU9OXHJcbiAgKTtcclxufTtcclxuXHJcbi8vIEdldCBhbGwgcHJvZHVjdHMgd2l0aCBwYWdpbmF0aW9uIGFuZCBjYWNoaW5nXHJcbmV4cG9ydCBjb25zdCBnZXRBbGxQcm9kdWN0cyA9IGFzeW5jIChwYWdlU2l6ZTogbnVtYmVyID0gMCk6IFByb21pc2U8UHJvZHVjdFtdPiA9PiB7XHJcbiAgdHJ5IHtcclxuICAgIC8vIElmIGNhY2hlIGlzIHZhbGlkIGFuZCB3ZSdyZSBub3QgcGFnaW5hdGluZywgcmV0dXJuIGNhY2hlZCBwcm9kdWN0c1xyXG4gICAgaWYgKGlzQ2FjaGVWYWxpZCgpICYmIHBhZ2VTaXplID09PSAwICYmIHByb2R1Y3RDYWNoZS5hbGwpIHtcclxuICAgICAgY29uc29sZS5sb2coJ1JldHVybmluZyBwcm9kdWN0cyBmcm9tIGNhY2hlJyk7XHJcbiAgICAgIHJldHVybiBwcm9kdWN0Q2FjaGUuYWxsO1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICBjb25zb2xlLmxvZygnRmV0Y2hpbmcgcHJvZHVjdHMgZnJvbSBGaXJlc3RvcmUnKTtcclxuICAgIFxyXG4gICAgbGV0IHByb2R1Y3RzUXVlcnkgPSBxdWVyeShwcm9kdWN0c0NvbGxlY3Rpb24sIG9yZGVyQnkoJ2NyZWF0ZWRBdCcsICdkZXNjJykpO1xyXG4gICAgXHJcbiAgICAvLyBBcHBseSBwYWdpbmF0aW9uIGlmIHBhZ2VTaXplIGlzIHNwZWNpZmllZFxyXG4gICAgaWYgKHBhZ2VTaXplID4gMCkge1xyXG4gICAgICBwcm9kdWN0c1F1ZXJ5ID0gcXVlcnkocHJvZHVjdHNRdWVyeSwgbGltaXQocGFnZVNpemUpKTtcclxuICAgIH1cclxuICAgIFxyXG4gICAgY29uc3Qgc25hcHNob3QgPSBhd2FpdCBnZXREb2NzKHByb2R1Y3RzUXVlcnkpO1xyXG4gICAgY29uc3QgcHJvZHVjdHMgPSBzbmFwc2hvdC5kb2NzLm1hcChkb2MgPT4gKHtcclxuICAgICAgaWQ6IGRvYy5pZCxcclxuICAgICAgLi4uZG9jLmRhdGEoKVxyXG4gICAgfSBhcyBQcm9kdWN0KSk7XHJcbiAgICBcclxuICAgIC8vIFVwZGF0ZSBjYWNoZSBpZiB3ZSdyZSBnZXR0aW5nIGFsbCBwcm9kdWN0c1xyXG4gICAgaWYgKHBhZ2VTaXplID09PSAwKSB7XHJcbiAgICAgIHByb2R1Y3RDYWNoZS5hbGwgPSBwcm9kdWN0cztcclxuICAgICAgXHJcbiAgICAgIC8vIFVwZGF0ZSBieUlkIGFuZCBieUNhdGVnb3J5IGNhY2hlc1xyXG4gICAgICBwcm9kdWN0cy5mb3JFYWNoKHByb2R1Y3QgPT4ge1xyXG4gICAgICAgIHByb2R1Y3RDYWNoZS5ieUlkW3Byb2R1Y3QuaWRdID0gcHJvZHVjdDtcclxuICAgICAgICBcclxuICAgICAgICBpZiAocHJvZHVjdC5jYXRlZ29yeSkge1xyXG4gICAgICAgICAgaWYgKCFwcm9kdWN0Q2FjaGUuYnlDYXRlZ29yeVtwcm9kdWN0LmNhdGVnb3J5XSkge1xyXG4gICAgICAgICAgICBwcm9kdWN0Q2FjaGUuYnlDYXRlZ29yeVtwcm9kdWN0LmNhdGVnb3J5XSA9IFtdO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgcHJvZHVjdENhY2hlLmJ5Q2F0ZWdvcnlbcHJvZHVjdC5jYXRlZ29yeV0ucHVzaChwcm9kdWN0KTtcclxuICAgICAgICB9XHJcbiAgICAgIH0pO1xyXG4gICAgICBcclxuICAgICAgcHJvZHVjdENhY2hlLmxhc3RGZXRjaGVkID0gRGF0ZS5ub3coKTtcclxuICAgIH1cclxuICAgIFxyXG4gICAgY29uc29sZS5sb2coYFJldHJpZXZlZCAke3Byb2R1Y3RzLmxlbmd0aH0gcHJvZHVjdHMgZnJvbSBGaXJlc3RvcmVgKTtcclxuICAgIHJldHVybiBwcm9kdWN0cztcclxuICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgY29uc29sZS5lcnJvcignRXJyb3IgZ2V0dGluZyBwcm9kdWN0cyBmcm9tIEZpcmVzdG9yZTonLCBlcnJvcik7XHJcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZhaWxlZCB0byBmZXRjaCBwcm9kdWN0cycpO1xyXG4gIH1cclxufTtcclxuXHJcbi8vIEdldCBuZXh0IHBhZ2Ugb2YgcHJvZHVjdHNcclxuZXhwb3J0IGNvbnN0IGdldE5leHRQcm9kdWN0c1BhZ2UgPSBhc3luYyAoXHJcbiAgbGFzdFZpc2libGU6IFF1ZXJ5RG9jdW1lbnRTbmFwc2hvdCxcclxuICBwYWdlU2l6ZTogbnVtYmVyID0gMjBcclxuKTogUHJvbWlzZTxQcm9kdWN0W10+ID0+IHtcclxuICB0cnkge1xyXG4gICAgY29uc3QgcHJvZHVjdHNRdWVyeSA9IHF1ZXJ5KFxyXG4gICAgICBwcm9kdWN0c0NvbGxlY3Rpb24sXHJcbiAgICAgIG9yZGVyQnkoJ2NyZWF0ZWRBdCcsICdkZXNjJyksXHJcbiAgICAgIHN0YXJ0QWZ0ZXIobGFzdFZpc2libGUpLFxyXG4gICAgICBsaW1pdChwYWdlU2l6ZSlcclxuICAgICk7XHJcbiAgICBcclxuICAgIGNvbnN0IHNuYXBzaG90ID0gYXdhaXQgZ2V0RG9jcyhwcm9kdWN0c1F1ZXJ5KTtcclxuICAgIGNvbnN0IHByb2R1Y3RzID0gc25hcHNob3QuZG9jcy5tYXAoZG9jID0+ICh7XHJcbiAgICAgIGlkOiBkb2MuaWQsXHJcbiAgICAgIC4uLmRvYy5kYXRhKClcclxuICAgIH0gYXMgUHJvZHVjdCkpO1xyXG4gICAgXHJcbiAgICAvLyBVcGRhdGUgY2FjaGUgZm9yIHRoZXNlIHByb2R1Y3RzXHJcbiAgICBwcm9kdWN0cy5mb3JFYWNoKHByb2R1Y3QgPT4ge1xyXG4gICAgICBwcm9kdWN0Q2FjaGUuYnlJZFtwcm9kdWN0LmlkXSA9IHByb2R1Y3Q7XHJcbiAgICAgIFxyXG4gICAgICBpZiAocHJvZHVjdC5jYXRlZ29yeSkge1xyXG4gICAgICAgIGlmICghcHJvZHVjdENhY2hlLmJ5Q2F0ZWdvcnlbcHJvZHVjdC5jYXRlZ29yeV0pIHtcclxuICAgICAgICAgIHByb2R1Y3RDYWNoZS5ieUNhdGVnb3J5W3Byb2R1Y3QuY2F0ZWdvcnldID0gW107XHJcbiAgICAgICAgfVxyXG4gICAgICAgIFxyXG4gICAgICAgIC8vIENoZWNrIGlmIHByb2R1Y3QgYWxyZWFkeSBleGlzdHMgaW4gY2F0ZWdvcnkgY2FjaGVcclxuICAgICAgICBjb25zdCBleGlzdGluZ0luZGV4ID0gcHJvZHVjdENhY2hlLmJ5Q2F0ZWdvcnlbcHJvZHVjdC5jYXRlZ29yeV0uZmluZEluZGV4KFxyXG4gICAgICAgICAgcCA9PiBwLmlkID09PSBwcm9kdWN0LmlkXHJcbiAgICAgICAgKTtcclxuICAgICAgICBcclxuICAgICAgICBpZiAoZXhpc3RpbmdJbmRleCA+PSAwKSB7XHJcbiAgICAgICAgICBwcm9kdWN0Q2FjaGUuYnlDYXRlZ29yeVtwcm9kdWN0LmNhdGVnb3J5XVtleGlzdGluZ0luZGV4XSA9IHByb2R1Y3Q7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIHByb2R1Y3RDYWNoZS5ieUNhdGVnb3J5W3Byb2R1Y3QuY2F0ZWdvcnldLnB1c2gocHJvZHVjdCk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9KTtcclxuICAgIFxyXG4gICAgcmV0dXJuIHByb2R1Y3RzO1xyXG4gIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICBjb25zb2xlLmVycm9yKCdFcnJvciBnZXR0aW5nIG5leHQgcGFnZSBvZiBwcm9kdWN0czonLCBlcnJvcik7XHJcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZhaWxlZCB0byBmZXRjaCBtb3JlIHByb2R1Y3RzJyk7XHJcbiAgfVxyXG59O1xyXG5cclxuLy8gR2V0IHByb2R1Y3RzIGJ5IGNhdGVnb3J5IHdpdGggY2FjaGluZ1xyXG5leHBvcnQgY29uc3QgZ2V0UHJvZHVjdHNCeUNhdGVnb3J5ID0gYXN5bmMgKGNhdGVnb3J5OiBzdHJpbmcpOiBQcm9taXNlPFByb2R1Y3RbXT4gPT4ge1xyXG4gIHRyeSB7XHJcbiAgICAvLyBDaGVjayBpZiB3ZSBoYXZlIHRoaXMgY2F0ZWdvcnkgaW4gY2FjaGUgYW5kIGl0J3Mgc3RpbGwgdmFsaWRcclxuICAgIGlmIChcclxuICAgICAgaXNDYWNoZVZhbGlkKCkgJiZcclxuICAgICAgcHJvZHVjdENhY2hlLmJ5Q2F0ZWdvcnlbY2F0ZWdvcnldICYmXHJcbiAgICAgIHByb2R1Y3RDYWNoZS5ieUNhdGVnb3J5W2NhdGVnb3J5XS5sZW5ndGggPiAwXHJcbiAgICApIHtcclxuICAgICAgY29uc29sZS5sb2coYFJldHVybmluZyAke2NhdGVnb3J5fSBwcm9kdWN0cyBmcm9tIGNhY2hlYCk7XHJcbiAgICAgIHJldHVybiBwcm9kdWN0Q2FjaGUuYnlDYXRlZ29yeVtjYXRlZ29yeV07XHJcbiAgICB9XHJcbiAgICBcclxuICAgIGNvbnNvbGUubG9nKGBGZXRjaGluZyAke2NhdGVnb3J5fSBwcm9kdWN0cyBmcm9tIEZpcmVzdG9yZWApO1xyXG4gICAgY29uc3QgcSA9IHF1ZXJ5KHByb2R1Y3RzQ29sbGVjdGlvbiwgd2hlcmUoJ2NhdGVnb3J5JywgJz09JywgY2F0ZWdvcnkpKTtcclxuICAgIGNvbnN0IHNuYXBzaG90ID0gYXdhaXQgZ2V0RG9jcyhxKTtcclxuICAgIGNvbnN0IHByb2R1Y3RzID0gc25hcHNob3QuZG9jcy5tYXAoZG9jID0+ICh7XHJcbiAgICAgIGlkOiBkb2MuaWQsXHJcbiAgICAgIC4uLmRvYy5kYXRhKClcclxuICAgIH0gYXMgUHJvZHVjdCkpO1xyXG4gICAgXHJcbiAgICAvLyBVcGRhdGUgY2FjaGVcclxuICAgIHByb2R1Y3RDYWNoZS5ieUNhdGVnb3J5W2NhdGVnb3J5XSA9IHByb2R1Y3RzO1xyXG4gICAgXHJcbiAgICAvLyBBbHNvIHVwZGF0ZSBieUlkIGNhY2hlXHJcbiAgICBwcm9kdWN0cy5mb3JFYWNoKHByb2R1Y3QgPT4ge1xyXG4gICAgICBwcm9kdWN0Q2FjaGUuYnlJZFtwcm9kdWN0LmlkXSA9IHByb2R1Y3Q7XHJcbiAgICB9KTtcclxuICAgIFxyXG4gICAgcmV0dXJuIHByb2R1Y3RzO1xyXG4gIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICBjb25zb2xlLmVycm9yKGBFcnJvciBnZXR0aW5nICR7Y2F0ZWdvcnl9IHByb2R1Y3RzOmAsIGVycm9yKTtcclxuICAgIHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIGZldGNoICR7Y2F0ZWdvcnl9IHByb2R1Y3RzYCk7XHJcbiAgfVxyXG59O1xyXG5cclxuLy8gR2V0IGZlYXR1cmVkIHByb2R1Y3RzIHdpdGggY2FjaGluZ1xyXG5leHBvcnQgY29uc3QgZ2V0RmVhdHVyZWRQcm9kdWN0cyA9IGFzeW5jIChsaW1pdDogbnVtYmVyID0gOCk6IFByb21pc2U8UHJvZHVjdFtdPiA9PiB7XHJcbiAgdHJ5IHtcclxuICAgIC8vIElmIHdlIGhhdmUgYWxsIHByb2R1Y3RzIGNhY2hlZCwgZmlsdGVyIHRoZW1cclxuICAgIGlmIChpc0NhY2hlVmFsaWQoKSAmJiBwcm9kdWN0Q2FjaGUuYWxsKSB7XHJcbiAgICAgIGNvbnN0IGZlYXR1cmVkID0gcHJvZHVjdENhY2hlLmFsbC5maWx0ZXIocCA9PiBwLmZlYXR1cmVkKS5zbGljZSgwLCBsaW1pdCk7XHJcbiAgICAgIGlmIChmZWF0dXJlZC5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgY29uc29sZS5sb2coJ1JldHVybmluZyBmZWF0dXJlZCBwcm9kdWN0cyBmcm9tIGNhY2hlJyk7XHJcbiAgICAgICAgcmV0dXJuIGZlYXR1cmVkO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICBcclxuICAgIGNvbnNvbGUubG9nKCdGZXRjaGluZyBmZWF0dXJlZCBwcm9kdWN0cyBmcm9tIEZpcmVzdG9yZScpO1xyXG4gICAgY29uc3QgcSA9IHF1ZXJ5KFxyXG4gICAgICBwcm9kdWN0c0NvbGxlY3Rpb24sXHJcbiAgICAgIHdoZXJlKCdmZWF0dXJlZCcsICc9PScsIHRydWUpLFxyXG4gICAgICBvcmRlckJ5KCdjcmVhdGVkQXQnLCAnZGVzYycpLFxyXG4gICAgICBsaW1pdFxyXG4gICAgKTtcclxuICAgIFxyXG4gICAgY29uc3Qgc25hcHNob3QgPSBhd2FpdCBnZXREb2NzKHEpO1xyXG4gICAgY29uc3QgcHJvZHVjdHMgPSBzbmFwc2hvdC5kb2NzLm1hcChkb2MgPT4gKHtcclxuICAgICAgaWQ6IGRvYy5pZCxcclxuICAgICAgLi4uZG9jLmRhdGEoKVxyXG4gICAgfSBhcyBQcm9kdWN0KSk7XHJcbiAgICBcclxuICAgIC8vIFVwZGF0ZSBieUlkIGNhY2hlXHJcbiAgICBwcm9kdWN0cy5mb3JFYWNoKHByb2R1Y3QgPT4ge1xyXG4gICAgICBwcm9kdWN0Q2FjaGUuYnlJZFtwcm9kdWN0LmlkXSA9IHByb2R1Y3Q7XHJcbiAgICAgIFxyXG4gICAgICAvLyBVcGRhdGUgY2F0ZWdvcnkgY2FjaGUgaWYgbmVlZGVkXHJcbiAgICAgIGlmIChwcm9kdWN0LmNhdGVnb3J5KSB7XHJcbiAgICAgICAgaWYgKCFwcm9kdWN0Q2FjaGUuYnlDYXRlZ29yeVtwcm9kdWN0LmNhdGVnb3J5XSkge1xyXG4gICAgICAgICAgcHJvZHVjdENhY2hlLmJ5Q2F0ZWdvcnlbcHJvZHVjdC5jYXRlZ29yeV0gPSBbXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgXHJcbiAgICAgICAgLy8gQ2hlY2sgaWYgcHJvZHVjdCBhbHJlYWR5IGV4aXN0cyBpbiBjYXRlZ29yeSBjYWNoZVxyXG4gICAgICAgIGNvbnN0IGV4aXN0aW5nSW5kZXggPSBwcm9kdWN0Q2FjaGUuYnlDYXRlZ29yeVtwcm9kdWN0LmNhdGVnb3J5XS5maW5kSW5kZXgoXHJcbiAgICAgICAgICBwID0+IHAuaWQgPT09IHByb2R1Y3QuaWRcclxuICAgICAgICApO1xyXG4gICAgICAgIFxyXG4gICAgICAgIGlmIChleGlzdGluZ0luZGV4ID49IDApIHtcclxuICAgICAgICAgIHByb2R1Y3RDYWNoZS5ieUNhdGVnb3J5W3Byb2R1Y3QuY2F0ZWdvcnldW2V4aXN0aW5nSW5kZXhdID0gcHJvZHVjdDtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgcHJvZHVjdENhY2hlLmJ5Q2F0ZWdvcnlbcHJvZHVjdC5jYXRlZ29yeV0ucHVzaChwcm9kdWN0KTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG4gICAgXHJcbiAgICByZXR1cm4gcHJvZHVjdHM7XHJcbiAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGdldHRpbmcgZmVhdHVyZWQgcHJvZHVjdHM6JywgZXJyb3IpO1xyXG4gICAgdGhyb3cgbmV3IEVycm9yKCdGYWlsZWQgdG8gZmV0Y2ggZmVhdHVyZWQgcHJvZHVjdHMnKTtcclxuICB9XHJcbn07XHJcblxyXG4vLyBHZXQgbmV3IGFycml2YWxzIHdpdGggY2FjaGluZ1xyXG5leHBvcnQgY29uc3QgZ2V0TmV3QXJyaXZhbHMgPSBhc3luYyAobGltaXQ6IG51bWJlciA9IDgpOiBQcm9taXNlPFByb2R1Y3RbXT4gPT4ge1xyXG4gIHRyeSB7XHJcbiAgICAvLyBJZiB3ZSBoYXZlIGFsbCBwcm9kdWN0cyBjYWNoZWQsIGZpbHRlciB0aGVtXHJcbiAgICBpZiAoaXNDYWNoZVZhbGlkKCkgJiYgcHJvZHVjdENhY2hlLmFsbCkge1xyXG4gICAgICBjb25zdCBuZXdBcnJpdmFscyA9IHByb2R1Y3RDYWNoZS5hbGxcclxuICAgICAgICAuZmlsdGVyKHAgPT4gcC5uZXcpXHJcbiAgICAgICAgLnNsaWNlKDAsIGxpbWl0KTtcclxuICAgICAgICBcclxuICAgICAgaWYgKG5ld0Fycml2YWxzLmxlbmd0aCA+IDApIHtcclxuICAgICAgICBjb25zb2xlLmxvZygnUmV0dXJuaW5nIG5ldyBhcnJpdmFscyBmcm9tIGNhY2hlJyk7XHJcbiAgICAgICAgcmV0dXJuIG5ld0Fycml2YWxzO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICBcclxuICAgIGNvbnNvbGUubG9nKCdGZXRjaGluZyBuZXcgYXJyaXZhbHMgZnJvbSBGaXJlc3RvcmUnKTtcclxuICAgIGNvbnN0IHEgPSBxdWVyeShcclxuICAgICAgcHJvZHVjdHNDb2xsZWN0aW9uLFxyXG4gICAgICB3aGVyZSgnbmV3JywgJz09JywgdHJ1ZSksXHJcbiAgICAgIG9yZGVyQnkoJ2NyZWF0ZWRBdCcsICdkZXNjJyksXHJcbiAgICAgIGxpbWl0XHJcbiAgICApO1xyXG4gICAgXHJcbiAgICBjb25zdCBzbmFwc2hvdCA9IGF3YWl0IGdldERvY3MocSk7XHJcbiAgICBjb25zdCBwcm9kdWN0cyA9IHNuYXBzaG90LmRvY3MubWFwKGRvYyA9PiAoe1xyXG4gICAgICBpZDogZG9jLmlkLFxyXG4gICAgICAuLi5kb2MuZGF0YSgpXHJcbiAgICB9IGFzIFByb2R1Y3QpKTtcclxuICAgIFxyXG4gICAgLy8gVXBkYXRlIGJ5SWQgY2FjaGVcclxuICAgIHByb2R1Y3RzLmZvckVhY2gocHJvZHVjdCA9PiB7XHJcbiAgICAgIHByb2R1Y3RDYWNoZS5ieUlkW3Byb2R1Y3QuaWRdID0gcHJvZHVjdDtcclxuICAgICAgXHJcbiAgICAgIC8vIFVwZGF0ZSBjYXRlZ29yeSBjYWNoZSBpZiBuZWVkZWRcclxuICAgICAgaWYgKHByb2R1Y3QuY2F0ZWdvcnkpIHtcclxuICAgICAgICBpZiAoIXByb2R1Y3RDYWNoZS5ieUNhdGVnb3J5W3Byb2R1Y3QuY2F0ZWdvcnldKSB7XHJcbiAgICAgICAgICBwcm9kdWN0Q2FjaGUuYnlDYXRlZ29yeVtwcm9kdWN0LmNhdGVnb3J5XSA9IFtdO1xyXG4gICAgICAgIH1cclxuICAgICAgICBcclxuICAgICAgICAvLyBDaGVjayBpZiBwcm9kdWN0IGFscmVhZHkgZXhpc3RzIGluIGNhdGVnb3J5IGNhY2hlXHJcbiAgICAgICAgY29uc3QgZXhpc3RpbmdJbmRleCA9IHByb2R1Y3RDYWNoZS5ieUNhdGVnb3J5W3Byb2R1Y3QuY2F0ZWdvcnldLmZpbmRJbmRleChcclxuICAgICAgICAgIHAgPT4gcC5pZCA9PT0gcHJvZHVjdC5pZFxyXG4gICAgICAgICk7XHJcbiAgICAgICAgXHJcbiAgICAgICAgaWYgKGV4aXN0aW5nSW5kZXggPj0gMCkge1xyXG4gICAgICAgICAgcHJvZHVjdENhY2hlLmJ5Q2F0ZWdvcnlbcHJvZHVjdC5jYXRlZ29yeV1bZXhpc3RpbmdJbmRleF0gPSBwcm9kdWN0O1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBwcm9kdWN0Q2FjaGUuYnlDYXRlZ29yeVtwcm9kdWN0LmNhdGVnb3J5XS5wdXNoKHByb2R1Y3QpO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfSk7XHJcbiAgICBcclxuICAgIHJldHVybiBwcm9kdWN0cztcclxuICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgY29uc29sZS5lcnJvcignRXJyb3IgZ2V0dGluZyBuZXcgYXJyaXZhbHM6JywgZXJyb3IpO1xyXG4gICAgdGhyb3cgbmV3IEVycm9yKCdGYWlsZWQgdG8gZmV0Y2ggbmV3IGFycml2YWxzJyk7XHJcbiAgfVxyXG59O1xyXG5cclxuLy8gR2V0IHByb2R1Y3QgYnkgSUQgd2l0aCBjYWNoaW5nXHJcbmV4cG9ydCBjb25zdCBnZXRQcm9kdWN0QnlJZCA9IGFzeW5jIChpZDogc3RyaW5nKTogUHJvbWlzZTxQcm9kdWN0IHwgbnVsbD4gPT4ge1xyXG4gIHRyeSB7XHJcbiAgICAvLyBDaGVjayBpZiBwcm9kdWN0IGlzIGluIGNhY2hlXHJcbiAgICBpZiAocHJvZHVjdENhY2hlLmJ5SWRbaWRdKSB7XHJcbiAgICAgIGNvbnNvbGUubG9nKGBSZXR1cm5pbmcgcHJvZHVjdCAke2lkfSBmcm9tIGNhY2hlYCk7XHJcbiAgICAgIHJldHVybiBwcm9kdWN0Q2FjaGUuYnlJZFtpZF07XHJcbiAgICB9XHJcbiAgICBcclxuICAgIGNvbnNvbGUubG9nKGBGZXRjaGluZyBwcm9kdWN0ICR7aWR9IGZyb20gRmlyZXN0b3JlYCk7XHJcbiAgICBjb25zdCBwcm9kdWN0RG9jID0gZG9jKGRiLCAncHJvZHVjdHMnLCBpZCk7XHJcbiAgICBjb25zdCBzbmFwc2hvdCA9IGF3YWl0IGdldERvYyhwcm9kdWN0RG9jKTtcclxuICAgIFxyXG4gICAgaWYgKHNuYXBzaG90LmV4aXN0cygpKSB7XHJcbiAgICAgIGNvbnN0IHByb2R1Y3QgPSB7XHJcbiAgICAgICAgaWQ6IHNuYXBzaG90LmlkLFxyXG4gICAgICAgIC4uLnNuYXBzaG90LmRhdGEoKVxyXG4gICAgICB9IGFzIFByb2R1Y3Q7XHJcbiAgICAgIFxyXG4gICAgICAvLyBVcGRhdGUgY2FjaGVcclxuICAgICAgcHJvZHVjdENhY2hlLmJ5SWRbaWRdID0gcHJvZHVjdDtcclxuICAgICAgXHJcbiAgICAgIHJldHVybiBwcm9kdWN0O1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIG51bGw7XHJcbiAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGdldHRpbmcgcHJvZHVjdDonLCBlcnJvcik7XHJcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZhaWxlZCB0byBmZXRjaCBwcm9kdWN0IGRldGFpbHMnKTtcclxuICB9XHJcbn07XHJcblxyXG4vLyBDbGVhciBjYWNoZSBmb3IgYSBzcGVjaWZpYyBwcm9kdWN0XHJcbmNvbnN0IGludmFsaWRhdGVQcm9kdWN0Q2FjaGUgPSAocHJvZHVjdElkOiBzdHJpbmcsIGNhdGVnb3J5SWQ/OiBzdHJpbmcpID0+IHtcclxuICAvLyBSZW1vdmUgZnJvbSBieUlkIGNhY2hlXHJcbiAgaWYgKHByb2R1Y3RDYWNoZS5ieUlkW3Byb2R1Y3RJZF0pIHtcclxuICAgIGRlbGV0ZSBwcm9kdWN0Q2FjaGUuYnlJZFtwcm9kdWN0SWRdO1xyXG4gIH1cclxuICBcclxuICAvLyBSZW1vdmUgZnJvbSBjYXRlZ29yeSBjYWNoZSBpZiBjYXRlZ29yeSBpcyBwcm92aWRlZFxyXG4gIGlmIChjYXRlZ29yeUlkICYmIHByb2R1Y3RDYWNoZS5ieUNhdGVnb3J5W2NhdGVnb3J5SWRdKSB7XHJcbiAgICBwcm9kdWN0Q2FjaGUuYnlDYXRlZ29yeVtjYXRlZ29yeUlkXSA9IHByb2R1Y3RDYWNoZS5ieUNhdGVnb3J5W2NhdGVnb3J5SWRdLmZpbHRlcihcclxuICAgICAgcCA9PiBwLmlkICE9PSBwcm9kdWN0SWRcclxuICAgICk7XHJcbiAgfVxyXG4gIFxyXG4gIC8vIFNldCBhbGwgY2FjaGUgdG8gbnVsbCB0byBmb3JjZSByZWZyZXNoIG9uIG5leHQgZmV0Y2hcclxuICBwcm9kdWN0Q2FjaGUuYWxsID0gbnVsbDtcclxufTtcclxuXHJcbi8vIENsZWFyIGVudGlyZSBjYWNoZVxyXG5leHBvcnQgY29uc3QgY2xlYXJQcm9kdWN0Q2FjaGUgPSAoKSA9PiB7XHJcbiAgcHJvZHVjdENhY2hlLmFsbCA9IG51bGw7XHJcbiAgcHJvZHVjdENhY2hlLmJ5SWQgPSB7fTtcclxuICBwcm9kdWN0Q2FjaGUuYnlDYXRlZ29yeSA9IHt9O1xyXG4gIHByb2R1Y3RDYWNoZS5sYXN0RmV0Y2hlZCA9IDA7XHJcbn07XHJcblxyXG4vLyBVcGxvYWQgaW1hZ2UgdG8gRmlyZWJhc2UgU3RvcmFnZVxyXG5leHBvcnQgY29uc3QgdXBsb2FkUHJvZHVjdEltYWdlID0gYXN5bmMgKGZpbGU6IEZpbGUpOiBQcm9taXNlPHN0cmluZz4gPT4ge1xyXG4gIHRyeSB7XHJcbiAgICAvLyBDcmVhdGUgYSB1bmlxdWUgZmlsZW5hbWVcclxuICAgIGNvbnN0IHRpbWVzdGFtcCA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xyXG4gICAgY29uc3QgZmlsZU5hbWUgPSBgcHJvZHVjdF8ke3RpbWVzdGFtcH1fJHtmaWxlLm5hbWUucmVwbGFjZSgvW15hLXpBLVowLTkuXS9nLCAnXycpfWA7XHJcbiAgICBcclxuICAgIC8vIENyZWF0ZSBhIHJlZmVyZW5jZSB0byB0aGUgZmlsZSBpbiBzdG9yYWdlXHJcbiAgICBjb25zdCBzdG9yYWdlUmVmID0gcmVmKHN0b3JhZ2UsIGBwcm9kdWN0X2ltYWdlcy8ke2ZpbGVOYW1lfWApO1xyXG4gICAgXHJcbiAgICAvLyBVcGxvYWQgdGhlIGZpbGVcclxuICAgIGF3YWl0IHVwbG9hZEJ5dGVzKHN0b3JhZ2VSZWYsIGZpbGUpO1xyXG4gICAgXHJcbiAgICAvLyBHZXQgdGhlIGRvd25sb2FkIFVSTFxyXG4gICAgY29uc3QgZG93bmxvYWRVUkwgPSBhd2FpdCBnZXREb3dubG9hZFVSTChzdG9yYWdlUmVmKTtcclxuICAgIHJldHVybiBkb3dubG9hZFVSTDtcclxuICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgY29uc29sZS5lcnJvcignRXJyb3IgdXBsb2FkaW5nIGltYWdlOicsIGVycm9yKTtcclxuICAgIHRocm93IG5ldyBFcnJvcignRmFpbGVkIHRvIHVwbG9hZCBwcm9kdWN0IGltYWdlJyk7XHJcbiAgfVxyXG59O1xyXG5cclxuLy8gRGVsZXRlIHByb2R1Y3QgaW1hZ2UgZnJvbSBGaXJlYmFzZSBTdG9yYWdlXHJcbmV4cG9ydCBjb25zdCBkZWxldGVQcm9kdWN0SW1hZ2UgPSBhc3luYyAoaW1hZ2VVcmw6IHN0cmluZyk6IFByb21pc2U8dm9pZD4gPT4ge1xyXG4gIHRyeSB7XHJcbiAgICAvLyBFeHRyYWN0IHRoZSBmaWxlIHBhdGggZnJvbSB0aGUgVVJMXHJcbiAgICBjb25zdCBkZWNvZGVkVXJsID0gZGVjb2RlVVJJQ29tcG9uZW50KGltYWdlVXJsKTtcclxuICAgIGNvbnN0IHN0YXJ0SW5kZXggPSBkZWNvZGVkVXJsLmluZGV4T2YoJ3Byb2R1Y3RfaW1hZ2VzJyk7XHJcbiAgICBcclxuICAgIGlmIChzdGFydEluZGV4ID09PSAtMSkge1xyXG4gICAgICBjb25zb2xlLndhcm4oJ05vdCBhIEZpcmViYXNlIFN0b3JhZ2UgVVJMIG9yIG5vdCBpbiBwcm9kdWN0X2ltYWdlcyBmb2xkZXI6JywgaW1hZ2VVcmwpO1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICBcclxuICAgIGNvbnN0IGVuZEluZGV4ID0gZGVjb2RlZFVybC5pbmRleE9mKCc/Jywgc3RhcnRJbmRleCk7XHJcbiAgICBjb25zdCBmaWxlUGF0aCA9IGVuZEluZGV4ICE9PSAtMSBcclxuICAgICAgPyBkZWNvZGVkVXJsLnN1YnN0cmluZyhzdGFydEluZGV4LCBlbmRJbmRleCkgXHJcbiAgICAgIDogZGVjb2RlZFVybC5zdWJzdHJpbmcoc3RhcnRJbmRleCk7XHJcbiAgICBcclxuICAgIC8vIENyZWF0ZSBhIHJlZmVyZW5jZSB0byB0aGUgZmlsZVxyXG4gICAgY29uc3QgaW1hZ2VSZWYgPSByZWYoc3RvcmFnZSwgZmlsZVBhdGgpO1xyXG4gICAgXHJcbiAgICAvLyBEZWxldGUgdGhlIGZpbGVcclxuICAgIGF3YWl0IGRlbGV0ZU9iamVjdChpbWFnZVJlZik7XHJcbiAgICBjb25zb2xlLmxvZygnUHJvZHVjdCBpbWFnZSBkZWxldGVkIHN1Y2Nlc3NmdWxseTonLCBmaWxlUGF0aCk7XHJcbiAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGRlbGV0aW5nIHByb2R1Y3QgaW1hZ2U6JywgZXJyb3IpO1xyXG4gICAgLy8gRG9uJ3QgdGhyb3cgZXJyb3IgaGVyZSwgYXMgd2Ugd2FudCB0byBjb250aW51ZSB3aXRoIHByb2R1Y3QgZGVsZXRpb25cclxuICAgIC8vIGV2ZW4gaWYgaW1hZ2UgZGVsZXRpb24gZmFpbHNcclxuICB9XHJcbn07XHJcblxyXG4vLyBBZGQgYSBuZXcgcHJvZHVjdCB3aXRoIHRyYW5zYWN0aW9uIGZvciBjYXRlZ29yeSB0cmFja2luZ1xyXG5leHBvcnQgY29uc3QgYWRkUHJvZHVjdCA9IGFzeW5jIChwcm9kdWN0OiBPbWl0PFByb2R1Y3QsICdpZCc+KTogUHJvbWlzZTxQcm9kdWN0PiA9PiB7XHJcbiAgdHJ5IHtcclxuICAgIGNvbnNvbGUubG9nKCdBZGRpbmcgcHJvZHVjdCB0byBGaXJlc3RvcmU6JywgcHJvZHVjdCk7XHJcbiAgICBcclxuICAgIC8vIFZhbGlkYXRlIHByb2R1Y3QgZGF0YVxyXG4gICAgY29uc3QgdmFsaWRhdGlvbkVycm9yID0gdmFsaWRhdGVQcm9kdWN0KHByb2R1Y3QpO1xyXG4gICAgaWYgKHZhbGlkYXRpb25FcnJvcikge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IodmFsaWRhdGlvbkVycm9yKTtcclxuICAgIH1cclxuICAgIFxyXG4gICAgLy8gQ2xlYW4gdGhlIHByb2R1Y3QgZGF0YSBmb3IgRmlyZXN0b3JlXHJcbiAgICBjb25zdCBjbGVhbmVkUHJvZHVjdCA9IGNsZWFuUHJvZHVjdERhdGEocHJvZHVjdCk7XHJcbiAgICBjb25zb2xlLmxvZygnQ2xlYW5lZCBwcm9kdWN0IGRhdGEgZm9yIEZpcmVzdG9yZTonLCBjbGVhbmVkUHJvZHVjdCk7XHJcbiAgICBcclxuICAgIC8vIFVzZSB0cmFuc2FjdGlvbiB0byBhZGQgcHJvZHVjdCBhbmQgdXBkYXRlIGNhdGVnb3J5IGRhdGFcclxuICAgIGNvbnN0IG5ld1Byb2R1Y3QgPSBhd2FpdCBydW5UcmFuc2FjdGlvbihkYiwgYXN5bmMgKHRyYW5zYWN0aW9uKSA9PiB7XHJcbiAgICAgIC8vIEFkZCB0aGUgcHJvZHVjdCBkb2N1bWVudFxyXG4gICAgICBjb25zdCBkb2NSZWYgPSBhd2FpdCBhZGREb2MocHJvZHVjdHNDb2xsZWN0aW9uLCBjbGVhbmVkUHJvZHVjdCk7XHJcbiAgICAgIGNvbnN0IG5ld1Byb2R1Y3RXaXRoSWQgPSB7IGlkOiBkb2NSZWYuaWQsIC4uLmNsZWFuZWRQcm9kdWN0IH07XHJcbiAgICAgIFxyXG4gICAgICAvLyBVcGRhdGUgb3IgY3JlYXRlIGNhdGVnb3J5IGNvdW50XHJcbiAgICAgIGNvbnN0IGNhdGVnb3J5UmVmID0gZG9jKGNhdGVnb3JpZXNDb2xsZWN0aW9uLCBjbGVhbmVkUHJvZHVjdC5jYXRlZ29yeSk7XHJcbiAgICAgIGNvbnN0IGNhdGVnb3J5RG9jID0gYXdhaXQgdHJhbnNhY3Rpb24uZ2V0KGNhdGVnb3J5UmVmKTtcclxuICAgICAgXHJcbiAgICAgIGlmIChjYXRlZ29yeURvYy5leGlzdHMoKSkge1xyXG4gICAgICAgIC8vIFVwZGF0ZSBleGlzdGluZyBjYXRlZ29yeVxyXG4gICAgICAgIHRyYW5zYWN0aW9uLnVwZGF0ZShjYXRlZ29yeVJlZiwge1xyXG4gICAgICAgICAgY291bnQ6IChjYXRlZ29yeURvYy5kYXRhKCkuY291bnQgfHwgMCkgKyAxLFxyXG4gICAgICAgICAgdXBkYXRlZEF0OiBzZXJ2ZXJUaW1lc3RhbXAoKVxyXG4gICAgICAgIH0pO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIC8vIENyZWF0ZSBuZXcgY2F0ZWdvcnlcclxuICAgICAgICB0cmFuc2FjdGlvbi5zZXQoY2F0ZWdvcnlSZWYsIHtcclxuICAgICAgICAgIGlkOiBjbGVhbmVkUHJvZHVjdC5jYXRlZ29yeSxcclxuICAgICAgICAgIG5hbWU6IGNsZWFuZWRQcm9kdWN0LmNhdGVnb3J5LmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgY2xlYW5lZFByb2R1Y3QuY2F0ZWdvcnkuc2xpY2UoMSksXHJcbiAgICAgICAgICBjb3VudDogMSxcclxuICAgICAgICAgIGNyZWF0ZWRBdDogc2VydmVyVGltZXN0YW1wKCksXHJcbiAgICAgICAgICB1cGRhdGVkQXQ6IHNlcnZlclRpbWVzdGFtcCgpXHJcbiAgICAgICAgfSk7XHJcbiAgICAgIH1cclxuICAgICAgXHJcbiAgICAgIHJldHVybiBuZXdQcm9kdWN0V2l0aElkO1xyXG4gICAgfSk7XHJcbiAgICBcclxuICAgIC8vIFVwZGF0ZSBjYWNoZSB3aXRoIHRoZSBuZXcgcHJvZHVjdFxyXG4gICAgaWYgKHByb2R1Y3RDYWNoZS5hbGwpIHtcclxuICAgICAgcHJvZHVjdENhY2hlLmFsbC51bnNoaWZ0KG5ld1Byb2R1Y3QgYXMgUHJvZHVjdCk7XHJcbiAgICB9XHJcbiAgICBcclxuICAgIHByb2R1Y3RDYWNoZS5ieUlkW25ld1Byb2R1Y3QuaWRdID0gbmV3UHJvZHVjdCBhcyBQcm9kdWN0O1xyXG4gICAgXHJcbiAgICBpZiAobmV3UHJvZHVjdC5jYXRlZ29yeSkge1xyXG4gICAgICBpZiAoIXByb2R1Y3RDYWNoZS5ieUNhdGVnb3J5W25ld1Byb2R1Y3QuY2F0ZWdvcnldKSB7XHJcbiAgICAgICAgcHJvZHVjdENhY2hlLmJ5Q2F0ZWdvcnlbbmV3UHJvZHVjdC5jYXRlZ29yeV0gPSBbXTtcclxuICAgICAgfVxyXG4gICAgICBwcm9kdWN0Q2FjaGUuYnlDYXRlZ29yeVtuZXdQcm9kdWN0LmNhdGVnb3J5XS51bnNoaWZ0KG5ld1Byb2R1Y3QgYXMgUHJvZHVjdCk7XHJcbiAgICB9XHJcbiAgICBcclxuICAgIGNvbnNvbGUubG9nKCdQcm9kdWN0IGFkZGVkIHN1Y2Nlc3NmdWxseSB3aXRoIElEOicsIG5ld1Byb2R1Y3QuaWQpO1xyXG4gICAgcmV0dXJuIG5ld1Byb2R1Y3QgYXMgUHJvZHVjdDtcclxuICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgY29uc29sZS5lcnJvcignRXJyb3IgYWRkaW5nIHByb2R1Y3QgdG8gRmlyZXN0b3JlOicsIGVycm9yKTtcclxuICAgIHRocm93IGVycm9yO1xyXG4gIH1cclxufTtcclxuXHJcbi8vIFVwZGF0ZSBhIHByb2R1Y3RcclxuZXhwb3J0IGNvbnN0IHVwZGF0ZVByb2R1Y3QgPSBhc3luYyAoaWQ6IHN0cmluZywgcHJvZHVjdDogUGFydGlhbDxQcm9kdWN0Pik6IFByb21pc2U8dm9pZD4gPT4ge1xyXG4gIHRyeSB7XHJcbiAgICBjb25zdCBwcm9kdWN0RG9jID0gZG9jKGRiLCAncHJvZHVjdHMnLCBpZCk7XHJcbiAgICBcclxuICAgIC8vIEdldCBleGlzdGluZyBwcm9kdWN0IHRvIGNoZWNrIGlmIGNhdGVnb3J5IGlzIGNoYW5naW5nXHJcbiAgICBjb25zdCBleGlzdGluZ1Byb2R1Y3RTbmFwID0gYXdhaXQgZ2V0RG9jKHByb2R1Y3REb2MpO1xyXG4gICAgaWYgKCFleGlzdGluZ1Byb2R1Y3RTbmFwLmV4aXN0cygpKSB7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcignUHJvZHVjdCBub3QgZm91bmQnKTtcclxuICAgIH1cclxuICAgIFxyXG4gICAgY29uc3QgZXhpc3RpbmdQcm9kdWN0ID0gZXhpc3RpbmdQcm9kdWN0U25hcC5kYXRhKCk7XHJcbiAgICBjb25zdCBjbGVhbmVkVXBkYXRlcyA9IGNsZWFuUHJvZHVjdERhdGEocHJvZHVjdCk7XHJcbiAgICBcclxuICAgIC8vIEFsd2F5cyB1cGRhdGUgdGhlIHRpbWVzdGFtcCB3aGVuIG1vZGlmaWVkXHJcbiAgICBjbGVhbmVkVXBkYXRlcy51cGRhdGVkQXQgPSBzZXJ2ZXJUaW1lc3RhbXAoKTtcclxuICAgIFxyXG4gICAgYXdhaXQgcnVuVHJhbnNhY3Rpb24oZGIsIGFzeW5jICh0cmFuc2FjdGlvbikgPT4ge1xyXG4gICAgICAvLyBVcGRhdGUgcHJvZHVjdCBkb2N1bWVudFxyXG4gICAgICB0cmFuc2FjdGlvbi51cGRhdGUocHJvZHVjdERvYywgY2xlYW5lZFVwZGF0ZXMpO1xyXG4gICAgICBcclxuICAgICAgLy8gSWYgY2F0ZWdvcnkgY2hhbmdlZCwgdXBkYXRlIGJvdGggb2xkIGFuZCBuZXcgY2F0ZWdvcnkgY291bnRzXHJcbiAgICAgIGlmIChwcm9kdWN0LmNhdGVnb3J5ICYmIGV4aXN0aW5nUHJvZHVjdC5jYXRlZ29yeSAhPT0gcHJvZHVjdC5jYXRlZ29yeSkge1xyXG4gICAgICAgIC8vIERlY3JlYXNlIG9sZCBjYXRlZ29yeSBjb3VudFxyXG4gICAgICAgIGNvbnN0IG9sZENhdGVnb3J5UmVmID0gZG9jKGNhdGVnb3JpZXNDb2xsZWN0aW9uLCBleGlzdGluZ1Byb2R1Y3QuY2F0ZWdvcnkpO1xyXG4gICAgICAgIGNvbnN0IG9sZENhdGVnb3J5RG9jID0gYXdhaXQgdHJhbnNhY3Rpb24uZ2V0KG9sZENhdGVnb3J5UmVmKTtcclxuICAgICAgICBcclxuICAgICAgICBpZiAob2xkQ2F0ZWdvcnlEb2MuZXhpc3RzKCkpIHtcclxuICAgICAgICAgIGNvbnN0IG9sZENvdW50ID0gb2xkQ2F0ZWdvcnlEb2MuZGF0YSgpLmNvdW50IHx8IDA7XHJcbiAgICAgICAgICBpZiAob2xkQ291bnQgPiAxKSB7XHJcbiAgICAgICAgICAgIHRyYW5zYWN0aW9uLnVwZGF0ZShvbGRDYXRlZ29yeVJlZiwgeyBcclxuICAgICAgICAgICAgICBjb3VudDogb2xkQ291bnQgLSAxLFxyXG4gICAgICAgICAgICAgIHVwZGF0ZWRBdDogc2VydmVyVGltZXN0YW1wKClcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAvLyBEZWxldGUgY2F0ZWdvcnkgaWYgaXQgd2lsbCBiZSBlbXB0eVxyXG4gICAgICAgICAgICB0cmFuc2FjdGlvbi5kZWxldGUob2xkQ2F0ZWdvcnlSZWYpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBcclxuICAgICAgICAvLyBJbmNyZWFzZSBuZXcgY2F0ZWdvcnkgY291bnRcclxuICAgICAgICBjb25zdCBuZXdDYXRlZ29yeVJlZiA9IGRvYyhjYXRlZ29yaWVzQ29sbGVjdGlvbiwgcHJvZHVjdC5jYXRlZ29yeSk7XHJcbiAgICAgICAgY29uc3QgbmV3Q2F0ZWdvcnlEb2MgPSBhd2FpdCB0cmFuc2FjdGlvbi5nZXQobmV3Q2F0ZWdvcnlSZWYpO1xyXG4gICAgICAgIFxyXG4gICAgICAgIGlmIChuZXdDYXRlZ29yeURvYy5leGlzdHMoKSkge1xyXG4gICAgICAgICAgdHJhbnNhY3Rpb24udXBkYXRlKG5ld0NhdGVnb3J5UmVmLCB7IFxyXG4gICAgICAgICAgICBjb3VudDogKG5ld0NhdGVnb3J5RG9jLmRhdGEoKS5jb3VudCB8fCAwKSArIDEsXHJcbiAgICAgICAgICAgIHVwZGF0ZWRBdDogc2VydmVyVGltZXN0YW1wKClcclxuICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICB0cmFuc2FjdGlvbi5zZXQobmV3Q2F0ZWdvcnlSZWYsIHtcclxuICAgICAgICAgICAgaWQ6IHByb2R1Y3QuY2F0ZWdvcnksXHJcbiAgICAgICAgICAgIG5hbWU6IHByb2R1Y3QuY2F0ZWdvcnkuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBwcm9kdWN0LmNhdGVnb3J5LnNsaWNlKDEpLFxyXG4gICAgICAgICAgICBjb3VudDogMSxcclxuICAgICAgICAgICAgY3JlYXRlZEF0OiBzZXJ2ZXJUaW1lc3RhbXAoKSxcclxuICAgICAgICAgICAgdXBkYXRlZEF0OiBzZXJ2ZXJUaW1lc3RhbXAoKVxyXG4gICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9KTtcclxuICAgIFxyXG4gICAgLy8gVXBkYXRlIGNhY2hlXHJcbiAgICBpZiAocHJvZHVjdENhY2hlLmJ5SWRbaWRdKSB7XHJcbiAgICAgIGNvbnN0IHVwZGF0ZWRQcm9kdWN0ID0geyAuLi5wcm9kdWN0Q2FjaGUuYnlJZFtpZF0sIC4uLnByb2R1Y3QgfTtcclxuICAgICAgcHJvZHVjdENhY2hlLmJ5SWRbaWRdID0gdXBkYXRlZFByb2R1Y3Q7XHJcbiAgICAgIFxyXG4gICAgICAvLyBVcGRhdGUgaW4gYWxsIHByb2R1Y3RzIGNhY2hlIGlmIGl0IGV4aXN0c1xyXG4gICAgICBpZiAocHJvZHVjdENhY2hlLmFsbCkge1xyXG4gICAgICAgIGNvbnN0IGluZGV4ID0gcHJvZHVjdENhY2hlLmFsbC5maW5kSW5kZXgocCA9PiBwLmlkID09PSBpZCk7XHJcbiAgICAgICAgaWYgKGluZGV4ID49IDApIHtcclxuICAgICAgICAgIHByb2R1Y3RDYWNoZS5hbGxbaW5kZXhdID0gdXBkYXRlZFByb2R1Y3Q7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIFxyXG4gICAgICAvLyBIYW5kbGUgY2F0ZWdvcnkgY2hhbmdlIGluIGNhY2hlXHJcbiAgICAgIGlmIChwcm9kdWN0LmNhdGVnb3J5ICYmIGV4aXN0aW5nUHJvZHVjdC5jYXRlZ29yeSAhPT0gcHJvZHVjdC5jYXRlZ29yeSkge1xyXG4gICAgICAgIC8vIFJlbW92ZSBmcm9tIG9sZCBjYXRlZ29yeSBjYWNoZVxyXG4gICAgICAgIGlmIChwcm9kdWN0Q2FjaGUuYnlDYXRlZ29yeVtleGlzdGluZ1Byb2R1Y3QuY2F0ZWdvcnldKSB7XHJcbiAgICAgICAgICBwcm9kdWN0Q2FjaGUuYnlDYXRlZ29yeVtleGlzdGluZ1Byb2R1Y3QuY2F0ZWdvcnldID0gcHJvZHVjdENhY2hlLmJ5Q2F0ZWdvcnlbZXhpc3RpbmdQcm9kdWN0LmNhdGVnb3J5XS5maWx0ZXIoXHJcbiAgICAgICAgICAgIHAgPT4gcC5pZCAhPT0gaWRcclxuICAgICAgICAgICk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIFxyXG4gICAgICAgIC8vIEFkZCB0byBuZXcgY2F0ZWdvcnkgY2FjaGVcclxuICAgICAgICBpZiAoIXByb2R1Y3RDYWNoZS5ieUNhdGVnb3J5W3Byb2R1Y3QuY2F0ZWdvcnldKSB7XHJcbiAgICAgICAgICBwcm9kdWN0Q2FjaGUuYnlDYXRlZ29yeVtwcm9kdWN0LmNhdGVnb3J5XSA9IFtdO1xyXG4gICAgICAgIH1cclxuICAgICAgICBwcm9kdWN0Q2FjaGUuYnlDYXRlZ29yeVtwcm9kdWN0LmNhdGVnb3J5XS5wdXNoKHVwZGF0ZWRQcm9kdWN0KTtcclxuICAgICAgfSBlbHNlIGlmIChwcm9kdWN0LmNhdGVnb3J5KSB7XHJcbiAgICAgICAgLy8gVXBkYXRlIGluIHNhbWUgY2F0ZWdvcnlcclxuICAgICAgICBpZiAocHJvZHVjdENhY2hlLmJ5Q2F0ZWdvcnlbcHJvZHVjdC5jYXRlZ29yeV0pIHtcclxuICAgICAgICAgIGNvbnN0IGNhdEluZGV4ID0gcHJvZHVjdENhY2hlLmJ5Q2F0ZWdvcnlbcHJvZHVjdC5jYXRlZ29yeV0uZmluZEluZGV4KHAgPT4gcC5pZCA9PT0gaWQpO1xyXG4gICAgICAgICAgaWYgKGNhdEluZGV4ID49IDApIHtcclxuICAgICAgICAgICAgcHJvZHVjdENhY2hlLmJ5Q2F0ZWdvcnlbcHJvZHVjdC5jYXRlZ29yeV1bY2F0SW5kZXhdID0gdXBkYXRlZFByb2R1Y3Q7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAvLyBJZiBub3QgaW4gY2FjaGUsIGludmFsaWRhdGUgYWxsIGNhY2hlIHRvIGZvcmNlIHJlZnJlc2hcclxuICAgICAgY2xlYXJQcm9kdWN0Q2FjaGUoKTtcclxuICAgIH1cclxuICAgIFxyXG4gIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICBjb25zb2xlLmVycm9yKCdFcnJvciB1cGRhdGluZyBwcm9kdWN0OicsIGVycm9yKTtcclxuICAgIHRocm93IG5ldyBFcnJvcignRmFpbGVkIHRvIHVwZGF0ZSBwcm9kdWN0Jyk7XHJcbiAgfVxyXG59O1xyXG5cclxuLy8gRGVsZXRlIGEgcHJvZHVjdFxyXG5leHBvcnQgY29uc3QgZGVsZXRlUHJvZHVjdCA9IGFzeW5jIChpZDogc3RyaW5nKTogUHJvbWlzZTx2b2lkPiA9PiB7XHJcbiAgdHJ5IHtcclxuICAgIGNvbnN0IHByb2R1Y3REb2MgPSBkb2MoZGIsICdwcm9kdWN0cycsIGlkKTtcclxuICAgIFxyXG4gICAgLy8gR2V0IHByb2R1Y3QgdG8gZmluZCBpdHMgY2F0ZWdvcnkgYW5kIGltYWdlIFVSTFxyXG4gICAgY29uc3QgcHJvZHVjdFNuYXAgPSBhd2FpdCBnZXREb2MocHJvZHVjdERvYyk7XHJcbiAgICBpZiAoIXByb2R1Y3RTbmFwLmV4aXN0cygpKSB7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcignUHJvZHVjdCBub3QgZm91bmQnKTtcclxuICAgIH1cclxuICAgIFxyXG4gICAgY29uc3QgcHJvZHVjdERhdGEgPSBwcm9kdWN0U25hcC5kYXRhKCk7XHJcbiAgICBcclxuICAgIC8vIFRyeSB0byBkZWxldGUgdGhlIHByb2R1Y3QgaW1hZ2UgZmlyc3RcclxuICAgIGlmIChwcm9kdWN0RGF0YS5pbWFnZSkge1xyXG4gICAgICB0cnkge1xyXG4gICAgICAgIGF3YWl0IGRlbGV0ZVByb2R1Y3RJbWFnZShwcm9kdWN0RGF0YS5pbWFnZSk7XHJcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgZGVsZXRpbmcgcHJvZHVjdCBpbWFnZTonLCBlcnJvcik7XHJcbiAgICAgICAgLy8gQ29udGludWUgd2l0aCBwcm9kdWN0IGRlbGV0aW9uIGV2ZW4gaWYgaW1hZ2UgZGVsZXRpb24gZmFpbHNcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgXHJcbiAgICBhd2FpdCBydW5UcmFuc2FjdGlvbihkYiwgYXN5bmMgKHRyYW5zYWN0aW9uKSA9PiB7XHJcbiAgICAgIC8vIERlbGV0ZSBwcm9kdWN0XHJcbiAgICAgIHRyYW5zYWN0aW9uLmRlbGV0ZShwcm9kdWN0RG9jKTtcclxuICAgICAgXHJcbiAgICAgIC8vIFVwZGF0ZSBjYXRlZ29yeSBjb3VudFxyXG4gICAgICBpZiAocHJvZHVjdERhdGEuY2F0ZWdvcnkpIHtcclxuICAgICAgICBjb25zdCBjYXRlZ29yeVJlZiA9IGRvYyhjYXRlZ29yaWVzQ29sbGVjdGlvbiwgcHJvZHVjdERhdGEuY2F0ZWdvcnkpO1xyXG4gICAgICAgIGNvbnN0IGNhdGVnb3J5RG9jID0gYXdhaXQgdHJhbnNhY3Rpb24uZ2V0KGNhdGVnb3J5UmVmKTtcclxuICAgICAgICBcclxuICAgICAgICBpZiAoY2F0ZWdvcnlEb2MuZXhpc3RzKCkpIHtcclxuICAgICAgICAgIGNvbnN0IGNvdW50ID0gY2F0ZWdvcnlEb2MuZGF0YSgpLmNvdW50IHx8IDA7XHJcbiAgICAgICAgICBpZiAoY291bnQgPiAxKSB7XHJcbiAgICAgICAgICAgIHRyYW5zYWN0aW9uLnVwZGF0ZShjYXRlZ29yeVJlZiwgeyBcclxuICAgICAgICAgICAgICBjb3VudDogY291bnQgLSAxLFxyXG4gICAgICAgICAgICAgIHVwZGF0ZWRBdDogc2VydmVyVGltZXN0YW1wKClcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAvLyBEZWxldGUgY2F0ZWdvcnkgaWYgaXQgd2lsbCBiZSBlbXB0eVxyXG4gICAgICAgICAgICB0cmFuc2FjdGlvbi5kZWxldGUoY2F0ZWdvcnlSZWYpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfSk7XHJcbiAgICBcclxuICAgIC8vIFVwZGF0ZSBjYWNoZVxyXG4gICAgaW52YWxpZGF0ZVByb2R1Y3RDYWNoZShpZCwgcHJvZHVjdERhdGEuY2F0ZWdvcnkpO1xyXG4gICAgXHJcbiAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGRlbGV0aW5nIHByb2R1Y3Q6JywgZXJyb3IpO1xyXG4gICAgdGhyb3cgbmV3IEVycm9yKCdGYWlsZWQgdG8gZGVsZXRlIHByb2R1Y3QnKTtcclxuICB9XHJcbn07XHJcblxyXG4vLyBHZXQgYWxsIGNhdGVnb3JpZXMgd2l0aCBwcm9kdWN0IGNvdW50c1xyXG5leHBvcnQgY29uc3QgZ2V0QWxsQ2F0ZWdvcmllcyA9IGFzeW5jICgpID0+IHtcclxuICB0cnkge1xyXG4gICAgY29uc3Qgc25hcHNob3QgPSBhd2FpdCBnZXREb2NzKGNhdGVnb3JpZXNDb2xsZWN0aW9uKTtcclxuICAgIHJldHVybiBzbmFwc2hvdC5kb2NzLm1hcChkb2MgPT4gZG9jLmRhdGEoKSk7XHJcbiAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGdldHRpbmcgY2F0ZWdvcmllczonLCBlcnJvcik7XHJcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZhaWxlZCB0byBmZXRjaCBjYXRlZ29yaWVzJyk7XHJcbiAgfVxyXG59OyAiXSwibmFtZXMiOlsiYXBwIiwiZ2V0RmlyZXN0b3JlIiwiY29sbGVjdGlvbiIsImdldERvY3MiLCJkb2MiLCJnZXREb2MiLCJhZGREb2MiLCJxdWVyeSIsIndoZXJlIiwicnVuVHJhbnNhY3Rpb24iLCJzZXJ2ZXJUaW1lc3RhbXAiLCJsaW1pdCIsIm9yZGVyQnkiLCJzdGFydEFmdGVyIiwiZ2V0U3RvcmFnZSIsInJlZiIsInVwbG9hZEJ5dGVzIiwiZ2V0RG93bmxvYWRVUkwiLCJkZWxldGVPYmplY3QiLCJkYiIsInN0b3JhZ2UiLCJwcm9kdWN0c0NvbGxlY3Rpb24iLCJjYXRlZ29yaWVzQ29sbGVjdGlvbiIsInByb2R1Y3RDYWNoZSIsImFsbCIsImJ5SWQiLCJieUNhdGVnb3J5IiwibGFzdEZldGNoZWQiLCJDQUNIRV9FWFBJUkFUSU9OIiwidmFsaWRhdGVQcm9kdWN0IiwicHJvZHVjdCIsIm5hbWUiLCJwcmljZSIsImlzTmFOIiwiTnVtYmVyIiwiY2F0ZWdvcnkiLCJpbWFnZSIsImNsZWFuUHJvZHVjdERhdGEiLCJjbGVhbmVkUHJvZHVjdCIsIk9iamVjdCIsImVudHJpZXMiLCJmb3JFYWNoIiwia2V5IiwidmFsdWUiLCJ1bmRlZmluZWQiLCJzcGxpdCIsIm1hcCIsInMiLCJ0cmltIiwiZmlsdGVyIiwiQm9vbGVhbiIsImNyZWF0ZWRBdCIsInVwZGF0ZWRBdCIsImlzQ2FjaGVWYWxpZCIsIkRhdGUiLCJub3ciLCJnZXRBbGxQcm9kdWN0cyIsInBhZ2VTaXplIiwiY29uc29sZSIsImxvZyIsInByb2R1Y3RzUXVlcnkiLCJzbmFwc2hvdCIsInByb2R1Y3RzIiwiZG9jcyIsImlkIiwiZGF0YSIsInB1c2giLCJsZW5ndGgiLCJlcnJvciIsIkVycm9yIiwiZ2V0TmV4dFByb2R1Y3RzUGFnZSIsImxhc3RWaXNpYmxlIiwiZXhpc3RpbmdJbmRleCIsImZpbmRJbmRleCIsInAiLCJnZXRQcm9kdWN0c0J5Q2F0ZWdvcnkiLCJxIiwiZ2V0RmVhdHVyZWRQcm9kdWN0cyIsImZlYXR1cmVkIiwic2xpY2UiLCJnZXROZXdBcnJpdmFscyIsIm5ld0Fycml2YWxzIiwibmV3IiwiZ2V0UHJvZHVjdEJ5SWQiLCJwcm9kdWN0RG9jIiwiZXhpc3RzIiwiaW52YWxpZGF0ZVByb2R1Y3RDYWNoZSIsInByb2R1Y3RJZCIsImNhdGVnb3J5SWQiLCJjbGVhclByb2R1Y3RDYWNoZSIsInVwbG9hZFByb2R1Y3RJbWFnZSIsImZpbGUiLCJ0aW1lc3RhbXAiLCJnZXRUaW1lIiwiZmlsZU5hbWUiLCJyZXBsYWNlIiwic3RvcmFnZVJlZiIsImRvd25sb2FkVVJMIiwiZGVsZXRlUHJvZHVjdEltYWdlIiwiaW1hZ2VVcmwiLCJkZWNvZGVkVXJsIiwiZGVjb2RlVVJJQ29tcG9uZW50Iiwic3RhcnRJbmRleCIsImluZGV4T2YiLCJ3YXJuIiwiZW5kSW5kZXgiLCJmaWxlUGF0aCIsInN1YnN0cmluZyIsImltYWdlUmVmIiwiYWRkUHJvZHVjdCIsInZhbGlkYXRpb25FcnJvciIsIm5ld1Byb2R1Y3QiLCJ0cmFuc2FjdGlvbiIsImRvY1JlZiIsIm5ld1Byb2R1Y3RXaXRoSWQiLCJjYXRlZ29yeVJlZiIsImNhdGVnb3J5RG9jIiwiZ2V0IiwidXBkYXRlIiwiY291bnQiLCJzZXQiLCJjaGFyQXQiLCJ0b1VwcGVyQ2FzZSIsInVuc2hpZnQiLCJ1cGRhdGVQcm9kdWN0IiwiZXhpc3RpbmdQcm9kdWN0U25hcCIsImV4aXN0aW5nUHJvZHVjdCIsImNsZWFuZWRVcGRhdGVzIiwib2xkQ2F0ZWdvcnlSZWYiLCJvbGRDYXRlZ29yeURvYyIsIm9sZENvdW50IiwiZGVsZXRlIiwibmV3Q2F0ZWdvcnlSZWYiLCJuZXdDYXRlZ29yeURvYyIsInVwZGF0ZWRQcm9kdWN0IiwiaW5kZXgiLCJjYXRJbmRleCIsImRlbGV0ZVByb2R1Y3QiLCJwcm9kdWN0U25hcCIsInByb2R1Y3REYXRhIiwiZ2V0QWxsQ2F0ZWdvcmllcyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./utils/firestore.ts\n"));

/***/ })

});