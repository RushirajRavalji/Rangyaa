"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("pages/_app",{

/***/ "./utils/firestore.ts":
/*!****************************!*\
  !*** ./utils/firestore.ts ***!
  \****************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   addProduct: function() { return /* binding */ addProduct; },\n/* harmony export */   clearProductCache: function() { return /* binding */ clearProductCache; },\n/* harmony export */   db: function() { return /* binding */ db; },\n/* harmony export */   deleteProduct: function() { return /* binding */ deleteProduct; },\n/* harmony export */   deleteProductImage: function() { return /* binding */ deleteProductImage; },\n/* harmony export */   getAllCategories: function() { return /* binding */ getAllCategories; },\n/* harmony export */   getAllProducts: function() { return /* binding */ getAllProducts; },\n/* harmony export */   getFeaturedProducts: function() { return /* binding */ getFeaturedProducts; },\n/* harmony export */   getNewArrivals: function() { return /* binding */ getNewArrivals; },\n/* harmony export */   getNextProductsPage: function() { return /* binding */ getNextProductsPage; },\n/* harmony export */   getProductById: function() { return /* binding */ getProductById; },\n/* harmony export */   getProductsByCategory: function() { return /* binding */ getProductsByCategory; },\n/* harmony export */   storage: function() { return /* binding */ storage; },\n/* harmony export */   updateProduct: function() { return /* binding */ updateProduct; },\n/* harmony export */   uploadProductImage: function() { return /* binding */ uploadProductImage; }\n/* harmony export */ });\n/* harmony import */ var _firebase__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./firebase */ \"./utils/firebase.ts\");\n/* harmony import */ var firebase_firestore__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! firebase/firestore */ \"./node_modules/firebase/firestore/dist/esm/index.esm.js\");\n/* harmony import */ var firebase_storage__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! firebase/storage */ \"./node_modules/firebase/storage/dist/esm/index.esm.js\");\n\n\n\n// Initialize Firestore\nconst db = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.getFirestore)(_firebase__WEBPACK_IMPORTED_MODULE_0__.app);\n// Initialize Storage\nconst storage = (0,firebase_storage__WEBPACK_IMPORTED_MODULE_2__.getStorage)(_firebase__WEBPACK_IMPORTED_MODULE_0__.app);\n// Collection references\nconst productsCollection = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.collection)(db, \"products\");\nconst categoriesCollection = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.collection)(db, \"categories\");\n// Cache for products\nconst productCache = {\n    all: null,\n    byId: {},\n    byCategory: {},\n    lastFetched: 0\n};\n// Cache expiration time (5 minutes)\nconst CACHE_EXPIRATION = 5 * 60 * 1000;\n// Validate product data before saving\nconst validateProduct = (product)=>{\n    if (!product.name || typeof product.name !== \"string\") {\n        return \"Product name is required\";\n    }\n    if (!product.price || isNaN(Number(product.price))) {\n        return \"Valid product price is required\";\n    }\n    if (!product.category || typeof product.category !== \"string\") {\n        return \"Product category is required\";\n    }\n    if (!product.image || typeof product.image !== \"string\") {\n        return \"Product image is required\";\n    }\n    return null; // No errors\n};\n// Clean product data for Firestore\nconst cleanProductData = (product)=>{\n    const cleanedProduct = {};\n    Object.entries(product).forEach((param)=>{\n        let [key, value] = param;\n        if (value !== undefined && value !== null) {\n            // Handle specific field types\n            if (key === \"price\" || key === \"originalPrice\" || key === \"stock\") {\n                cleanedProduct[key] = Number(value);\n            } else if (key === \"sizes\" && typeof value === \"string\") {\n                cleanedProduct[key] = value.split(\",\").map((s)=>s.trim()).filter(Boolean);\n            } else if (key === \"featured\" && typeof value === \"string\") {\n                cleanedProduct[key] = value === \"true\";\n            } else {\n                cleanedProduct[key] = value;\n            }\n        }\n    });\n    // Add timestamps\n    if (!cleanedProduct.createdAt) {\n        cleanedProduct.createdAt = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.serverTimestamp)();\n    }\n    cleanedProduct.updatedAt = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.serverTimestamp)();\n    return cleanedProduct;\n};\n// Check if cache is valid\nconst isCacheValid = ()=>{\n    return productCache.all !== null && Date.now() - productCache.lastFetched < CACHE_EXPIRATION;\n};\n// Get all products with pagination and caching\nconst getAllProducts = async function() {\n    let pageSize = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;\n    try {\n        // If cache is valid and we're not paginating, return cached products\n        if (isCacheValid() && pageSize === 0 && productCache.all) {\n            console.log(\"Returning products from cache\");\n            return productCache.all;\n        }\n        console.log(\"Fetching products from Firestore\");\n        let productsQuery = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.query)(productsCollection, (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.orderBy)(\"createdAt\", \"desc\"));\n        // Apply pagination if pageSize is specified\n        if (pageSize > 0) {\n            productsQuery = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.query)(productsQuery, (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.limit)(pageSize));\n        }\n        const snapshot = await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.getDocs)(productsQuery);\n        const products = snapshot.docs.map((doc)=>({\n                id: doc.id,\n                ...doc.data()\n            }));\n        // Update cache if we're getting all products\n        if (pageSize === 0) {\n            productCache.all = products;\n            // Update byId and byCategory caches\n            products.forEach((product)=>{\n                productCache.byId[product.id] = product;\n                if (product.category) {\n                    if (!productCache.byCategory[product.category]) {\n                        productCache.byCategory[product.category] = [];\n                    }\n                    productCache.byCategory[product.category].push(product);\n                }\n            });\n            productCache.lastFetched = Date.now();\n        }\n        console.log(\"Retrieved \".concat(products.length, \" products from Firestore\"));\n        return products;\n    } catch (error) {\n        console.error(\"Error getting products from Firestore:\", error);\n        throw new Error(\"Failed to fetch products\");\n    }\n};\n// Get next page of products\nconst getNextProductsPage = async function(lastVisible) {\n    let pageSize = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 20;\n    try {\n        const productsQuery = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.query)(productsCollection, (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.orderBy)(\"createdAt\", \"desc\"), (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.startAfter)(lastVisible), (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.limit)(pageSize));\n        const snapshot = await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.getDocs)(productsQuery);\n        const products = snapshot.docs.map((doc)=>({\n                id: doc.id,\n                ...doc.data()\n            }));\n        // Update cache for these products\n        products.forEach((product)=>{\n            productCache.byId[product.id] = product;\n            if (product.category) {\n                if (!productCache.byCategory[product.category]) {\n                    productCache.byCategory[product.category] = [];\n                }\n                // Check if product already exists in category cache\n                const existingIndex = productCache.byCategory[product.category].findIndex((p)=>p.id === product.id);\n                if (existingIndex >= 0) {\n                    productCache.byCategory[product.category][existingIndex] = product;\n                } else {\n                    productCache.byCategory[product.category].push(product);\n                }\n            }\n        });\n        return products;\n    } catch (error) {\n        console.error(\"Error getting next page of products:\", error);\n        throw new Error(\"Failed to fetch more products\");\n    }\n};\n// Get products by category with caching\nconst getProductsByCategory = async (category)=>{\n    try {\n        // Check if we have this category in cache and it's still valid\n        if (isCacheValid() && productCache.byCategory[category] && productCache.byCategory[category].length > 0) {\n            console.log(\"Returning \".concat(category, \" products from cache\"));\n            return productCache.byCategory[category];\n        }\n        console.log(\"Fetching \".concat(category, \" products from Firestore\"));\n        const q = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.query)(productsCollection, (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.where)(\"category\", \"==\", category));\n        const snapshot = await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.getDocs)(q);\n        const products = snapshot.docs.map((doc)=>({\n                id: doc.id,\n                ...doc.data()\n            }));\n        // Update cache\n        productCache.byCategory[category] = products;\n        // Also update byId cache\n        products.forEach((product)=>{\n            productCache.byId[product.id] = product;\n        });\n        return products;\n    } catch (error) {\n        console.error(\"Error getting \".concat(category, \" products:\"), error);\n        throw new Error(\"Failed to fetch \".concat(category, \" products\"));\n    }\n};\n// Get featured products with caching\nconst getFeaturedProducts = async function() {\n    let limitCount = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 8;\n    try {\n        // If we have all products cached, filter them\n        if (isCacheValid() && productCache.all) {\n            const featured = productCache.all.filter((p)=>p.featured).slice(0, limitCount);\n            if (featured.length > 0) {\n                console.log(\"Returning featured products from cache\");\n                return featured;\n            }\n        }\n        console.log(\"Fetching featured products from Firestore\");\n        const q = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.query)(productsCollection, (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.where)(\"featured\", \"==\", true), (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.orderBy)(\"createdAt\", \"desc\"), (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.limit)(limitCount));\n        const snapshot = await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.getDocs)(q);\n        const products = snapshot.docs.map((doc)=>({\n                id: doc.id,\n                ...doc.data()\n            }));\n        // Update byId cache\n        products.forEach((product)=>{\n            productCache.byId[product.id] = product;\n            // Update category cache if needed\n            if (product.category) {\n                if (!productCache.byCategory[product.category]) {\n                    productCache.byCategory[product.category] = [];\n                }\n                // Check if product already exists in category cache\n                const existingIndex = productCache.byCategory[product.category].findIndex((p)=>p.id === product.id);\n                if (existingIndex >= 0) {\n                    productCache.byCategory[product.category][existingIndex] = product;\n                } else {\n                    productCache.byCategory[product.category].push(product);\n                }\n            }\n        });\n        return products;\n    } catch (error) {\n        console.error(\"Error getting featured products:\", error);\n        throw new Error(\"Failed to fetch featured products\");\n    }\n};\n// Get new arrivals with caching\nconst getNewArrivals = async function() {\n    let limitCount = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 8;\n    try {\n        // If we have all products cached, filter them\n        if (isCacheValid() && productCache.all) {\n            const newArrivals = productCache.all.filter((p)=>p.new).slice(0, limitCount);\n            if (newArrivals.length > 0) {\n                console.log(\"Returning new arrivals from cache\");\n                return newArrivals;\n            }\n        }\n        console.log(\"Fetching new arrivals from Firestore\");\n        const q = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.query)(productsCollection, (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.where)(\"new\", \"==\", true), (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.orderBy)(\"createdAt\", \"desc\"), (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.limit)(limitCount));\n        const snapshot = await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.getDocs)(q);\n        const products = snapshot.docs.map((doc)=>({\n                id: doc.id,\n                ...doc.data()\n            }));\n        // Update byId cache\n        products.forEach((product)=>{\n            productCache.byId[product.id] = product;\n            // Update category cache if needed\n            if (product.category) {\n                if (!productCache.byCategory[product.category]) {\n                    productCache.byCategory[product.category] = [];\n                }\n                // Check if product already exists in category cache\n                const existingIndex = productCache.byCategory[product.category].findIndex((p)=>p.id === product.id);\n                if (existingIndex >= 0) {\n                    productCache.byCategory[product.category][existingIndex] = product;\n                } else {\n                    productCache.byCategory[product.category].push(product);\n                }\n            }\n        });\n        return products;\n    } catch (error) {\n        console.error(\"Error getting new arrivals:\", error);\n        throw new Error(\"Failed to fetch new arrivals\");\n    }\n};\n// Get product by ID with caching\nconst getProductById = async (id)=>{\n    try {\n        // Check if product is in cache\n        if (productCache.byId[id]) {\n            console.log(\"Returning product \".concat(id, \" from cache\"));\n            return productCache.byId[id];\n        }\n        console.log(\"Fetching product \".concat(id, \" from Firestore\"));\n        const productDoc = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.doc)(db, \"products\", id);\n        const snapshot = await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.getDoc)(productDoc);\n        if (snapshot.exists()) {\n            const product = {\n                id: snapshot.id,\n                ...snapshot.data()\n            };\n            // Update cache\n            productCache.byId[id] = product;\n            return product;\n        }\n        return null;\n    } catch (error) {\n        console.error(\"Error getting product:\", error);\n        throw new Error(\"Failed to fetch product details\");\n    }\n};\n// Clear cache for a specific product\nconst invalidateProductCache = (productId, categoryId)=>{\n    // Remove from byId cache\n    if (productCache.byId[productId]) {\n        delete productCache.byId[productId];\n    }\n    // Remove from category cache if category is provided\n    if (categoryId && productCache.byCategory[categoryId]) {\n        productCache.byCategory[categoryId] = productCache.byCategory[categoryId].filter((p)=>p.id !== productId);\n    }\n    // Set all cache to null to force refresh on next fetch\n    productCache.all = null;\n};\n// Clear entire cache\nconst clearProductCache = ()=>{\n    productCache.all = null;\n    productCache.byId = {};\n    productCache.byCategory = {};\n    productCache.lastFetched = 0;\n};\n// Upload image to Firebase Storage\nconst uploadProductImage = async (file)=>{\n    try {\n        // Create a unique filename\n        const timestamp = new Date().getTime();\n        const fileName = \"product_\".concat(timestamp, \"_\").concat(file.name.replace(/[^a-zA-Z0-9.]/g, \"_\"));\n        // Create a reference to the file in storage\n        const storageRef = (0,firebase_storage__WEBPACK_IMPORTED_MODULE_2__.ref)(storage, \"product_images/\".concat(fileName));\n        // Upload the file\n        await (0,firebase_storage__WEBPACK_IMPORTED_MODULE_2__.uploadBytes)(storageRef, file);\n        // Get the download URL\n        const downloadURL = await (0,firebase_storage__WEBPACK_IMPORTED_MODULE_2__.getDownloadURL)(storageRef);\n        return downloadURL;\n    } catch (error) {\n        console.error(\"Error uploading image:\", error);\n        throw new Error(\"Failed to upload product image\");\n    }\n};\n// Delete product image from Firebase Storage\nconst deleteProductImage = async (imageUrl)=>{\n    try {\n        // Extract the file path from the URL\n        const decodedUrl = decodeURIComponent(imageUrl);\n        const startIndex = decodedUrl.indexOf(\"product_images\");\n        if (startIndex === -1) {\n            console.warn(\"Not a Firebase Storage URL or not in product_images folder:\", imageUrl);\n            return;\n        }\n        const endIndex = decodedUrl.indexOf(\"?\", startIndex);\n        const filePath = endIndex !== -1 ? decodedUrl.substring(startIndex, endIndex) : decodedUrl.substring(startIndex);\n        // Create a reference to the file\n        const imageRef = (0,firebase_storage__WEBPACK_IMPORTED_MODULE_2__.ref)(storage, filePath);\n        // Delete the file\n        await (0,firebase_storage__WEBPACK_IMPORTED_MODULE_2__.deleteObject)(imageRef);\n        console.log(\"Product image deleted successfully:\", filePath);\n    } catch (error) {\n        console.error(\"Error deleting product image:\", error);\n    // Don't throw error here, as we want to continue with product deletion\n    // even if image deletion fails\n    }\n};\n// Add a new product with transaction for category tracking\nconst addProduct = async (product)=>{\n    try {\n        console.log(\"Adding product to Firestore:\", product);\n        // Validate product data\n        const validationError = validateProduct(product);\n        if (validationError) {\n            throw new Error(validationError);\n        }\n        // Clean the product data for Firestore\n        const cleanedProduct = cleanProductData(product);\n        console.log(\"Cleaned product data for Firestore:\", cleanedProduct);\n        // Use transaction to add product and update category data\n        const newProduct = await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.runTransaction)(db, async (transaction)=>{\n            // Add the product document\n            const docRef = await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.addDoc)(productsCollection, cleanedProduct);\n            const newProductWithId = {\n                id: docRef.id,\n                ...cleanedProduct\n            };\n            // Update or create category count\n            const categoryRef = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.doc)(categoriesCollection, cleanedProduct.category);\n            const categoryDoc = await transaction.get(categoryRef);\n            if (categoryDoc.exists()) {\n                // Update existing category\n                transaction.update(categoryRef, {\n                    count: (categoryDoc.data().count || 0) + 1,\n                    updatedAt: (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.serverTimestamp)()\n                });\n            } else {\n                // Create new category\n                transaction.set(categoryRef, {\n                    id: cleanedProduct.category,\n                    name: cleanedProduct.category.charAt(0).toUpperCase() + cleanedProduct.category.slice(1),\n                    count: 1,\n                    createdAt: (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.serverTimestamp)(),\n                    updatedAt: (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.serverTimestamp)()\n                });\n            }\n            return newProductWithId;\n        });\n        // Update cache with the new product\n        if (productCache.all) {\n            productCache.all.unshift(newProduct);\n        }\n        productCache.byId[newProduct.id] = newProduct;\n        if (newProduct.category) {\n            if (!productCache.byCategory[newProduct.category]) {\n                productCache.byCategory[newProduct.category] = [];\n            }\n            productCache.byCategory[newProduct.category].unshift(newProduct);\n        }\n        console.log(\"Product added successfully with ID:\", newProduct.id);\n        return newProduct;\n    } catch (error) {\n        console.error(\"Error adding product to Firestore:\", error);\n        throw error;\n    }\n};\n// Update a product\nconst updateProduct = async (id, product)=>{\n    try {\n        const productDoc = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.doc)(db, \"products\", id);\n        // Get existing product to check if category is changing\n        const existingProductSnap = await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.getDoc)(productDoc);\n        if (!existingProductSnap.exists()) {\n            throw new Error(\"Product not found\");\n        }\n        const existingProduct = existingProductSnap.data();\n        const cleanedUpdates = cleanProductData(product);\n        // Always update the timestamp when modified\n        cleanedUpdates.updatedAt = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.serverTimestamp)();\n        await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.runTransaction)(db, async (transaction)=>{\n            // Update product document\n            transaction.update(productDoc, cleanedUpdates);\n            // If category changed, update both old and new category counts\n            if (product.category && existingProduct.category !== product.category) {\n                // Decrease old category count\n                const oldCategoryRef = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.doc)(categoriesCollection, existingProduct.category);\n                const oldCategoryDoc = await transaction.get(oldCategoryRef);\n                if (oldCategoryDoc.exists()) {\n                    const oldCount = oldCategoryDoc.data().count || 0;\n                    if (oldCount > 1) {\n                        transaction.update(oldCategoryRef, {\n                            count: oldCount - 1,\n                            updatedAt: (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.serverTimestamp)()\n                        });\n                    } else {\n                        // Delete category if it will be empty\n                        transaction.delete(oldCategoryRef);\n                    }\n                }\n                // Increase new category count\n                const newCategoryRef = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.doc)(categoriesCollection, product.category);\n                const newCategoryDoc = await transaction.get(newCategoryRef);\n                if (newCategoryDoc.exists()) {\n                    transaction.update(newCategoryRef, {\n                        count: (newCategoryDoc.data().count || 0) + 1,\n                        updatedAt: (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.serverTimestamp)()\n                    });\n                } else {\n                    transaction.set(newCategoryRef, {\n                        id: product.category,\n                        name: product.category.charAt(0).toUpperCase() + product.category.slice(1),\n                        count: 1,\n                        createdAt: (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.serverTimestamp)(),\n                        updatedAt: (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.serverTimestamp)()\n                    });\n                }\n            }\n        });\n        // Update cache\n        if (productCache.byId[id]) {\n            const updatedProduct = {\n                ...productCache.byId[id],\n                ...product\n            };\n            productCache.byId[id] = updatedProduct;\n            // Update in all products cache if it exists\n            if (productCache.all) {\n                const index = productCache.all.findIndex((p)=>p.id === id);\n                if (index >= 0) {\n                    productCache.all[index] = updatedProduct;\n                }\n            }\n            // Handle category change in cache\n            if (product.category && existingProduct.category !== product.category) {\n                // Remove from old category cache\n                if (productCache.byCategory[existingProduct.category]) {\n                    productCache.byCategory[existingProduct.category] = productCache.byCategory[existingProduct.category].filter((p)=>p.id !== id);\n                }\n                // Add to new category cache\n                if (!productCache.byCategory[product.category]) {\n                    productCache.byCategory[product.category] = [];\n                }\n                productCache.byCategory[product.category].push(updatedProduct);\n            } else if (product.category) {\n                // Update in same category\n                if (productCache.byCategory[product.category]) {\n                    const catIndex = productCache.byCategory[product.category].findIndex((p)=>p.id === id);\n                    if (catIndex >= 0) {\n                        productCache.byCategory[product.category][catIndex] = updatedProduct;\n                    }\n                }\n            }\n        } else {\n            // If not in cache, invalidate all cache to force refresh\n            clearProductCache();\n        }\n    } catch (error) {\n        console.error(\"Error updating product:\", error);\n        throw new Error(\"Failed to update product\");\n    }\n};\n// Delete a product\nconst deleteProduct = async (id)=>{\n    try {\n        const productDoc = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.doc)(db, \"products\", id);\n        // Get product to find its category and image URL\n        const productSnap = await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.getDoc)(productDoc);\n        if (!productSnap.exists()) {\n            throw new Error(\"Product not found\");\n        }\n        const productData = productSnap.data();\n        // Try to delete the product image first\n        if (productData.image) {\n            try {\n                await deleteProductImage(productData.image);\n            } catch (error) {\n                console.error(\"Error deleting product image:\", error);\n            // Continue with product deletion even if image deletion fails\n            }\n        }\n        await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.runTransaction)(db, async (transaction)=>{\n            // Delete product\n            transaction.delete(productDoc);\n            // Update category count\n            if (productData.category) {\n                const categoryRef = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.doc)(categoriesCollection, productData.category);\n                const categoryDoc = await transaction.get(categoryRef);\n                if (categoryDoc.exists()) {\n                    const count = categoryDoc.data().count || 0;\n                    if (count > 1) {\n                        transaction.update(categoryRef, {\n                            count: count - 1,\n                            updatedAt: (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.serverTimestamp)()\n                        });\n                    } else {\n                        // Delete category if it will be empty\n                        transaction.delete(categoryRef);\n                    }\n                }\n            }\n        });\n        // Update cache\n        invalidateProductCache(id, productData.category);\n    } catch (error) {\n        console.error(\"Error deleting product:\", error);\n        throw new Error(\"Failed to delete product\");\n    }\n};\n// Get all categories with product counts\nconst getAllCategories = async ()=>{\n    try {\n        const snapshot = await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.getDocs)(categoriesCollection);\n        return snapshot.docs.map((doc)=>doc.data());\n    } catch (error) {\n        console.error(\"Error getting categories:\", error);\n        throw new Error(\"Failed to fetch categories\");\n    }\n};\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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c0JzSCxZQUFZekcsUUFBUTtnQkFDbEUsTUFBTWtGLGNBQWMsTUFBTUosWUFBWUssR0FBRyxDQUFDRjtnQkFFMUMsSUFBSUMsWUFBWS9CLE1BQU0sSUFBSTtvQkFDeEIsTUFBTWtDLFFBQVFILFlBQVlwRCxJQUFJLEdBQUd1RCxLQUFLLElBQUk7b0JBQzFDLElBQUlBLFFBQVEsR0FBRzt3QkFDYlAsWUFBWU0sTUFBTSxDQUFDSCxhQUFhOzRCQUM5QkksT0FBT0EsUUFBUTs0QkFDZnBFLFdBQVcxQyxtRUFBZUE7d0JBQzVCO29CQUNGLE9BQU87d0JBQ0wsc0NBQXNDO3dCQUN0Q3VHLFlBQVltQixNQUFNLENBQUNoQjtvQkFDckI7Z0JBQ0Y7WUFDRjtRQUNGO1FBRUEsZUFBZTtRQUNmN0IsdUJBQXVCdkIsSUFBSTRFLFlBQVl6RyxRQUFRO0lBRWpELEVBQUUsT0FBT2lDLE9BQU87UUFDZFYsUUFBUVUsS0FBSyxDQUFDLDJCQUEyQkE7UUFDekMsTUFBTSxJQUFJQyxNQUFNO0lBQ2xCO0FBQ0YsRUFBRTtBQUVGLHlDQUF5QztBQUNsQyxNQUFNd0UsbUJBQW1CO0lBQzlCLElBQUk7UUFDRixNQUFNaEYsV0FBVyxNQUFNMUQsMkRBQU9BLENBQUNtQjtRQUMvQixPQUFPdUMsU0FBU0UsSUFBSSxDQUFDakIsR0FBRyxDQUFDMUMsQ0FBQUEsTUFBT0EsSUFBSTZELElBQUk7SUFDMUMsRUFBRSxPQUFPRyxPQUFPO1FBQ2RWLFFBQVFVLEtBQUssQ0FBQyw2QkFBNkJBO1FBQzNDLE1BQU0sSUFBSUMsTUFBTTtJQUNsQjtBQUNGLEVBQUUiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vdXRpbHMvZmlyZXN0b3JlLnRzP2FhMDAiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgYXBwIH0gZnJvbSAnLi9maXJlYmFzZSc7XHJcbmltcG9ydCB7IGdldEZpcmVzdG9yZSwgY29sbGVjdGlvbiwgZ2V0RG9jcywgZG9jLCBnZXREb2MsIGFkZERvYywgdXBkYXRlRG9jLCBkZWxldGVEb2MsIHF1ZXJ5LCB3aGVyZSwgcnVuVHJhbnNhY3Rpb24sIHNlcnZlclRpbWVzdGFtcCwgRG9jdW1lbnRSZWZlcmVuY2UsIGxpbWl0LCBvcmRlckJ5LCBzdGFydEFmdGVyLCBRdWVyeURvY3VtZW50U25hcHNob3QsIFF1ZXJ5U25hcHNob3QgfSBmcm9tICdmaXJlYmFzZS9maXJlc3RvcmUnO1xyXG5pbXBvcnQgeyBnZXRTdG9yYWdlLCByZWYsIHVwbG9hZEJ5dGVzLCBnZXREb3dubG9hZFVSTCwgZGVsZXRlT2JqZWN0IH0gZnJvbSAnZmlyZWJhc2Uvc3RvcmFnZSc7XHJcbmltcG9ydCB7IFByb2R1Y3QgfSBmcm9tICcuLi9kYXRhL3Byb2R1Y3RzJztcclxuXHJcbi8vIEluaXRpYWxpemUgRmlyZXN0b3JlXHJcbmV4cG9ydCBjb25zdCBkYiA9IGdldEZpcmVzdG9yZShhcHApO1xyXG5cclxuLy8gSW5pdGlhbGl6ZSBTdG9yYWdlXHJcbmV4cG9ydCBjb25zdCBzdG9yYWdlID0gZ2V0U3RvcmFnZShhcHApO1xyXG5cclxuLy8gQ29sbGVjdGlvbiByZWZlcmVuY2VzXHJcbmNvbnN0IHByb2R1Y3RzQ29sbGVjdGlvbiA9IGNvbGxlY3Rpb24oZGIsICdwcm9kdWN0cycpO1xyXG5jb25zdCBjYXRlZ29yaWVzQ29sbGVjdGlvbiA9IGNvbGxlY3Rpb24oZGIsICdjYXRlZ29yaWVzJyk7XHJcblxyXG4vLyBDYWNoZSBmb3IgcHJvZHVjdHNcclxuY29uc3QgcHJvZHVjdENhY2hlOiB7XHJcbiAgYWxsOiBQcm9kdWN0W10gfCBudWxsO1xyXG4gIGJ5SWQ6IFJlY29yZDxzdHJpbmcsIFByb2R1Y3Q+O1xyXG4gIGJ5Q2F0ZWdvcnk6IFJlY29yZDxzdHJpbmcsIFByb2R1Y3RbXT47XHJcbiAgbGFzdEZldGNoZWQ6IG51bWJlcjtcclxufSA9IHtcclxuICBhbGw6IG51bGwsXHJcbiAgYnlJZDoge30sXHJcbiAgYnlDYXRlZ29yeToge30sXHJcbiAgbGFzdEZldGNoZWQ6IDBcclxufTtcclxuXHJcbi8vIENhY2hlIGV4cGlyYXRpb24gdGltZSAoNSBtaW51dGVzKVxyXG5jb25zdCBDQUNIRV9FWFBJUkFUSU9OID0gNSAqIDYwICogMTAwMDtcclxuXHJcbi8vIFZhbGlkYXRlIHByb2R1Y3QgZGF0YSBiZWZvcmUgc2F2aW5nXHJcbmNvbnN0IHZhbGlkYXRlUHJvZHVjdCA9IChwcm9kdWN0OiBQYXJ0aWFsPFByb2R1Y3Q+KTogc3RyaW5nIHwgbnVsbCA9PiB7XHJcbiAgaWYgKCFwcm9kdWN0Lm5hbWUgfHwgdHlwZW9mIHByb2R1Y3QubmFtZSAhPT0gJ3N0cmluZycpIHtcclxuICAgIHJldHVybiAnUHJvZHVjdCBuYW1lIGlzIHJlcXVpcmVkJztcclxuICB9XHJcbiAgXHJcbiAgaWYgKCFwcm9kdWN0LnByaWNlIHx8IGlzTmFOKE51bWJlcihwcm9kdWN0LnByaWNlKSkpIHtcclxuICAgIHJldHVybiAnVmFsaWQgcHJvZHVjdCBwcmljZSBpcyByZXF1aXJlZCc7XHJcbiAgfVxyXG4gIFxyXG4gIGlmICghcHJvZHVjdC5jYXRlZ29yeSB8fCB0eXBlb2YgcHJvZHVjdC5jYXRlZ29yeSAhPT0gJ3N0cmluZycpIHtcclxuICAgIHJldHVybiAnUHJvZHVjdCBjYXRlZ29yeSBpcyByZXF1aXJlZCc7XHJcbiAgfVxyXG4gIFxyXG4gIGlmICghcHJvZHVjdC5pbWFnZSB8fCB0eXBlb2YgcHJvZHVjdC5pbWFnZSAhPT0gJ3N0cmluZycpIHtcclxuICAgIHJldHVybiAnUHJvZHVjdCBpbWFnZSBpcyByZXF1aXJlZCc7XHJcbiAgfVxyXG4gIFxyXG4gIHJldHVybiBudWxsOyAvLyBObyBlcnJvcnNcclxufTtcclxuXHJcbi8vIENsZWFuIHByb2R1Y3QgZGF0YSBmb3IgRmlyZXN0b3JlXHJcbmNvbnN0IGNsZWFuUHJvZHVjdERhdGEgPSAocHJvZHVjdDogUmVjb3JkPHN0cmluZywgYW55Pik6IFJlY29yZDxzdHJpbmcsIGFueT4gPT4ge1xyXG4gIGNvbnN0IGNsZWFuZWRQcm9kdWN0OiBSZWNvcmQ8c3RyaW5nLCBhbnk+ID0ge307XHJcbiAgXHJcbiAgT2JqZWN0LmVudHJpZXMocHJvZHVjdCkuZm9yRWFjaCgoW2tleSwgdmFsdWVdKSA9PiB7XHJcbiAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZCAmJiB2YWx1ZSAhPT0gbnVsbCkge1xyXG4gICAgICAvLyBIYW5kbGUgc3BlY2lmaWMgZmllbGQgdHlwZXNcclxuICAgICAgaWYgKGtleSA9PT0gJ3ByaWNlJyB8fCBrZXkgPT09ICdvcmlnaW5hbFByaWNlJyB8fCBrZXkgPT09ICdzdG9jaycpIHtcclxuICAgICAgICBjbGVhbmVkUHJvZHVjdFtrZXldID0gTnVtYmVyKHZhbHVlKTtcclxuICAgICAgfSBlbHNlIGlmIChrZXkgPT09ICdzaXplcycgJiYgdHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xyXG4gICAgICAgIGNsZWFuZWRQcm9kdWN0W2tleV0gPSB2YWx1ZS5zcGxpdCgnLCcpLm1hcCgoczogc3RyaW5nKSA9PiBzLnRyaW0oKSkuZmlsdGVyKEJvb2xlYW4pO1xyXG4gICAgICB9IGVsc2UgaWYgKGtleSA9PT0gJ2ZlYXR1cmVkJyAmJiB0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgY2xlYW5lZFByb2R1Y3Rba2V5XSA9IHZhbHVlID09PSAndHJ1ZSc7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgY2xlYW5lZFByb2R1Y3Rba2V5XSA9IHZhbHVlO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfSk7XHJcbiAgXHJcbiAgLy8gQWRkIHRpbWVzdGFtcHNcclxuICBpZiAoIWNsZWFuZWRQcm9kdWN0LmNyZWF0ZWRBdCkge1xyXG4gICAgY2xlYW5lZFByb2R1Y3QuY3JlYXRlZEF0ID0gc2VydmVyVGltZXN0YW1wKCk7XHJcbiAgfVxyXG4gIGNsZWFuZWRQcm9kdWN0LnVwZGF0ZWRBdCA9IHNlcnZlclRpbWVzdGFtcCgpO1xyXG4gIFxyXG4gIHJldHVybiBjbGVhbmVkUHJvZHVjdDtcclxufTtcclxuXHJcbi8vIENoZWNrIGlmIGNhY2hlIGlzIHZhbGlkXHJcbmNvbnN0IGlzQ2FjaGVWYWxpZCA9ICgpOiBib29sZWFuID0+IHtcclxuICByZXR1cm4gKFxyXG4gICAgcHJvZHVjdENhY2hlLmFsbCAhPT0gbnVsbCAmJlxyXG4gICAgRGF0ZS5ub3coKSAtIHByb2R1Y3RDYWNoZS5sYXN0RmV0Y2hlZCA8IENBQ0hFX0VYUElSQVRJT05cclxuICApO1xyXG59O1xyXG5cclxuLy8gR2V0IGFsbCBwcm9kdWN0cyB3aXRoIHBhZ2luYXRpb24gYW5kIGNhY2hpbmdcclxuZXhwb3J0IGNvbnN0IGdldEFsbFByb2R1Y3RzID0gYXN5bmMgKHBhZ2VTaXplOiBudW1iZXIgPSAwKTogUHJvbWlzZTxQcm9kdWN0W10+ID0+IHtcclxuICB0cnkge1xyXG4gICAgLy8gSWYgY2FjaGUgaXMgdmFsaWQgYW5kIHdlJ3JlIG5vdCBwYWdpbmF0aW5nLCByZXR1cm4gY2FjaGVkIHByb2R1Y3RzXHJcbiAgICBpZiAoaXNDYWNoZVZhbGlkKCkgJiYgcGFnZVNpemUgPT09IDAgJiYgcHJvZHVjdENhY2hlLmFsbCkge1xyXG4gICAgICBjb25zb2xlLmxvZygnUmV0dXJuaW5nIHByb2R1Y3RzIGZyb20gY2FjaGUnKTtcclxuICAgICAgcmV0dXJuIHByb2R1Y3RDYWNoZS5hbGw7XHJcbiAgICB9XHJcbiAgICBcclxuICAgIGNvbnNvbGUubG9nKCdGZXRjaGluZyBwcm9kdWN0cyBmcm9tIEZpcmVzdG9yZScpO1xyXG4gICAgXHJcbiAgICBsZXQgcHJvZHVjdHNRdWVyeSA9IHF1ZXJ5KHByb2R1Y3RzQ29sbGVjdGlvbiwgb3JkZXJCeSgnY3JlYXRlZEF0JywgJ2Rlc2MnKSk7XHJcbiAgICBcclxuICAgIC8vIEFwcGx5IHBhZ2luYXRpb24gaWYgcGFnZVNpemUgaXMgc3BlY2lmaWVkXHJcbiAgICBpZiAocGFnZVNpemUgPiAwKSB7XHJcbiAgICAgIHByb2R1Y3RzUXVlcnkgPSBxdWVyeShwcm9kdWN0c1F1ZXJ5LCBsaW1pdChwYWdlU2l6ZSkpO1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICBjb25zdCBzbmFwc2hvdCA9IGF3YWl0IGdldERvY3MocHJvZHVjdHNRdWVyeSk7XHJcbiAgICBjb25zdCBwcm9kdWN0cyA9IHNuYXBzaG90LmRvY3MubWFwKGRvYyA9PiAoe1xyXG4gICAgICBpZDogZG9jLmlkLFxyXG4gICAgICAuLi5kb2MuZGF0YSgpXHJcbiAgICB9IGFzIFByb2R1Y3QpKTtcclxuICAgIFxyXG4gICAgLy8gVXBkYXRlIGNhY2hlIGlmIHdlJ3JlIGdldHRpbmcgYWxsIHByb2R1Y3RzXHJcbiAgICBpZiAocGFnZVNpemUgPT09IDApIHtcclxuICAgICAgcHJvZHVjdENhY2hlLmFsbCA9IHByb2R1Y3RzO1xyXG4gICAgICBcclxuICAgICAgLy8gVXBkYXRlIGJ5SWQgYW5kIGJ5Q2F0ZWdvcnkgY2FjaGVzXHJcbiAgICAgIHByb2R1Y3RzLmZvckVhY2gocHJvZHVjdCA9PiB7XHJcbiAgICAgICAgcHJvZHVjdENhY2hlLmJ5SWRbcHJvZHVjdC5pZF0gPSBwcm9kdWN0O1xyXG4gICAgICAgIFxyXG4gICAgICAgIGlmIChwcm9kdWN0LmNhdGVnb3J5KSB7XHJcbiAgICAgICAgICBpZiAoIXByb2R1Y3RDYWNoZS5ieUNhdGVnb3J5W3Byb2R1Y3QuY2F0ZWdvcnldKSB7XHJcbiAgICAgICAgICAgIHByb2R1Y3RDYWNoZS5ieUNhdGVnb3J5W3Byb2R1Y3QuY2F0ZWdvcnldID0gW107XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBwcm9kdWN0Q2FjaGUuYnlDYXRlZ29yeVtwcm9kdWN0LmNhdGVnb3J5XS5wdXNoKHByb2R1Y3QpO1xyXG4gICAgICAgIH1cclxuICAgICAgfSk7XHJcbiAgICAgIFxyXG4gICAgICBwcm9kdWN0Q2FjaGUubGFzdEZldGNoZWQgPSBEYXRlLm5vdygpO1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICBjb25zb2xlLmxvZyhgUmV0cmlldmVkICR7cHJvZHVjdHMubGVuZ3RofSBwcm9kdWN0cyBmcm9tIEZpcmVzdG9yZWApO1xyXG4gICAgcmV0dXJuIHByb2R1Y3RzO1xyXG4gIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICBjb25zb2xlLmVycm9yKCdFcnJvciBnZXR0aW5nIHByb2R1Y3RzIGZyb20gRmlyZXN0b3JlOicsIGVycm9yKTtcclxuICAgIHRocm93IG5ldyBFcnJvcignRmFpbGVkIHRvIGZldGNoIHByb2R1Y3RzJyk7XHJcbiAgfVxyXG59O1xyXG5cclxuLy8gR2V0IG5leHQgcGFnZSBvZiBwcm9kdWN0c1xyXG5leHBvcnQgY29uc3QgZ2V0TmV4dFByb2R1Y3RzUGFnZSA9IGFzeW5jIChcclxuICBsYXN0VmlzaWJsZTogUXVlcnlEb2N1bWVudFNuYXBzaG90LFxyXG4gIHBhZ2VTaXplOiBudW1iZXIgPSAyMFxyXG4pOiBQcm9taXNlPFByb2R1Y3RbXT4gPT4ge1xyXG4gIHRyeSB7XHJcbiAgICBjb25zdCBwcm9kdWN0c1F1ZXJ5ID0gcXVlcnkoXHJcbiAgICAgIHByb2R1Y3RzQ29sbGVjdGlvbixcclxuICAgICAgb3JkZXJCeSgnY3JlYXRlZEF0JywgJ2Rlc2MnKSxcclxuICAgICAgc3RhcnRBZnRlcihsYXN0VmlzaWJsZSksXHJcbiAgICAgIGxpbWl0KHBhZ2VTaXplKVxyXG4gICAgKTtcclxuICAgIFxyXG4gICAgY29uc3Qgc25hcHNob3QgPSBhd2FpdCBnZXREb2NzKHByb2R1Y3RzUXVlcnkpO1xyXG4gICAgY29uc3QgcHJvZHVjdHMgPSBzbmFwc2hvdC5kb2NzLm1hcChkb2MgPT4gKHtcclxuICAgICAgaWQ6IGRvYy5pZCxcclxuICAgICAgLi4uZG9jLmRhdGEoKVxyXG4gICAgfSBhcyBQcm9kdWN0KSk7XHJcbiAgICBcclxuICAgIC8vIFVwZGF0ZSBjYWNoZSBmb3IgdGhlc2UgcHJvZHVjdHNcclxuICAgIHByb2R1Y3RzLmZvckVhY2gocHJvZHVjdCA9PiB7XHJcbiAgICAgIHByb2R1Y3RDYWNoZS5ieUlkW3Byb2R1Y3QuaWRdID0gcHJvZHVjdDtcclxuICAgICAgXHJcbiAgICAgIGlmIChwcm9kdWN0LmNhdGVnb3J5KSB7XHJcbiAgICAgICAgaWYgKCFwcm9kdWN0Q2FjaGUuYnlDYXRlZ29yeVtwcm9kdWN0LmNhdGVnb3J5XSkge1xyXG4gICAgICAgICAgcHJvZHVjdENhY2hlLmJ5Q2F0ZWdvcnlbcHJvZHVjdC5jYXRlZ29yeV0gPSBbXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgXHJcbiAgICAgICAgLy8gQ2hlY2sgaWYgcHJvZHVjdCBhbHJlYWR5IGV4aXN0cyBpbiBjYXRlZ29yeSBjYWNoZVxyXG4gICAgICAgIGNvbnN0IGV4aXN0aW5nSW5kZXggPSBwcm9kdWN0Q2FjaGUuYnlDYXRlZ29yeVtwcm9kdWN0LmNhdGVnb3J5XS5maW5kSW5kZXgoXHJcbiAgICAgICAgICBwID0+IHAuaWQgPT09IHByb2R1Y3QuaWRcclxuICAgICAgICApO1xyXG4gICAgICAgIFxyXG4gICAgICAgIGlmIChleGlzdGluZ0luZGV4ID49IDApIHtcclxuICAgICAgICAgIHByb2R1Y3RDYWNoZS5ieUNhdGVnb3J5W3Byb2R1Y3QuY2F0ZWdvcnldW2V4aXN0aW5nSW5kZXhdID0gcHJvZHVjdDtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgcHJvZHVjdENhY2hlLmJ5Q2F0ZWdvcnlbcHJvZHVjdC5jYXRlZ29yeV0ucHVzaChwcm9kdWN0KTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG4gICAgXHJcbiAgICByZXR1cm4gcHJvZHVjdHM7XHJcbiAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGdldHRpbmcgbmV4dCBwYWdlIG9mIHByb2R1Y3RzOicsIGVycm9yKTtcclxuICAgIHRocm93IG5ldyBFcnJvcignRmFpbGVkIHRvIGZldGNoIG1vcmUgcHJvZHVjdHMnKTtcclxuICB9XHJcbn07XHJcblxyXG4vLyBHZXQgcHJvZHVjdHMgYnkgY2F0ZWdvcnkgd2l0aCBjYWNoaW5nXHJcbmV4cG9ydCBjb25zdCBnZXRQcm9kdWN0c0J5Q2F0ZWdvcnkgPSBhc3luYyAoY2F0ZWdvcnk6IHN0cmluZyk6IFByb21pc2U8UHJvZHVjdFtdPiA9PiB7XHJcbiAgdHJ5IHtcclxuICAgIC8vIENoZWNrIGlmIHdlIGhhdmUgdGhpcyBjYXRlZ29yeSBpbiBjYWNoZSBhbmQgaXQncyBzdGlsbCB2YWxpZFxyXG4gICAgaWYgKFxyXG4gICAgICBpc0NhY2hlVmFsaWQoKSAmJlxyXG4gICAgICBwcm9kdWN0Q2FjaGUuYnlDYXRlZ29yeVtjYXRlZ29yeV0gJiZcclxuICAgICAgcHJvZHVjdENhY2hlLmJ5Q2F0ZWdvcnlbY2F0ZWdvcnldLmxlbmd0aCA+IDBcclxuICAgICkge1xyXG4gICAgICBjb25zb2xlLmxvZyhgUmV0dXJuaW5nICR7Y2F0ZWdvcnl9IHByb2R1Y3RzIGZyb20gY2FjaGVgKTtcclxuICAgICAgcmV0dXJuIHByb2R1Y3RDYWNoZS5ieUNhdGVnb3J5W2NhdGVnb3J5XTtcclxuICAgIH1cclxuICAgIFxyXG4gICAgY29uc29sZS5sb2coYEZldGNoaW5nICR7Y2F0ZWdvcnl9IHByb2R1Y3RzIGZyb20gRmlyZXN0b3JlYCk7XHJcbiAgICBjb25zdCBxID0gcXVlcnkocHJvZHVjdHNDb2xsZWN0aW9uLCB3aGVyZSgnY2F0ZWdvcnknLCAnPT0nLCBjYXRlZ29yeSkpO1xyXG4gICAgY29uc3Qgc25hcHNob3QgPSBhd2FpdCBnZXREb2NzKHEpO1xyXG4gICAgY29uc3QgcHJvZHVjdHMgPSBzbmFwc2hvdC5kb2NzLm1hcChkb2MgPT4gKHtcclxuICAgICAgaWQ6IGRvYy5pZCxcclxuICAgICAgLi4uZG9jLmRhdGEoKVxyXG4gICAgfSBhcyBQcm9kdWN0KSk7XHJcbiAgICBcclxuICAgIC8vIFVwZGF0ZSBjYWNoZVxyXG4gICAgcHJvZHVjdENhY2hlLmJ5Q2F0ZWdvcnlbY2F0ZWdvcnldID0gcHJvZHVjdHM7XHJcbiAgICBcclxuICAgIC8vIEFsc28gdXBkYXRlIGJ5SWQgY2FjaGVcclxuICAgIHByb2R1Y3RzLmZvckVhY2gocHJvZHVjdCA9PiB7XHJcbiAgICAgIHByb2R1Y3RDYWNoZS5ieUlkW3Byb2R1Y3QuaWRdID0gcHJvZHVjdDtcclxuICAgIH0pO1xyXG4gICAgXHJcbiAgICByZXR1cm4gcHJvZHVjdHM7XHJcbiAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgIGNvbnNvbGUuZXJyb3IoYEVycm9yIGdldHRpbmcgJHtjYXRlZ29yeX0gcHJvZHVjdHM6YCwgZXJyb3IpO1xyXG4gICAgdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gZmV0Y2ggJHtjYXRlZ29yeX0gcHJvZHVjdHNgKTtcclxuICB9XHJcbn07XHJcblxyXG4vLyBHZXQgZmVhdHVyZWQgcHJvZHVjdHMgd2l0aCBjYWNoaW5nXHJcbmV4cG9ydCBjb25zdCBnZXRGZWF0dXJlZFByb2R1Y3RzID0gYXN5bmMgKGxpbWl0Q291bnQ6IG51bWJlciA9IDgpOiBQcm9taXNlPFByb2R1Y3RbXT4gPT4ge1xyXG4gIHRyeSB7XHJcbiAgICAvLyBJZiB3ZSBoYXZlIGFsbCBwcm9kdWN0cyBjYWNoZWQsIGZpbHRlciB0aGVtXHJcbiAgICBpZiAoaXNDYWNoZVZhbGlkKCkgJiYgcHJvZHVjdENhY2hlLmFsbCkge1xyXG4gICAgICBjb25zdCBmZWF0dXJlZCA9IHByb2R1Y3RDYWNoZS5hbGwuZmlsdGVyKHAgPT4gcC5mZWF0dXJlZCkuc2xpY2UoMCwgbGltaXRDb3VudCk7XHJcbiAgICAgIGlmIChmZWF0dXJlZC5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgY29uc29sZS5sb2coJ1JldHVybmluZyBmZWF0dXJlZCBwcm9kdWN0cyBmcm9tIGNhY2hlJyk7XHJcbiAgICAgICAgcmV0dXJuIGZlYXR1cmVkO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICBcclxuICAgIGNvbnNvbGUubG9nKCdGZXRjaGluZyBmZWF0dXJlZCBwcm9kdWN0cyBmcm9tIEZpcmVzdG9yZScpO1xyXG4gICAgY29uc3QgcSA9IHF1ZXJ5KFxyXG4gICAgICBwcm9kdWN0c0NvbGxlY3Rpb24sXHJcbiAgICAgIHdoZXJlKCdmZWF0dXJlZCcsICc9PScsIHRydWUpLFxyXG4gICAgICBvcmRlckJ5KCdjcmVhdGVkQXQnLCAnZGVzYycpLFxyXG4gICAgICBsaW1pdChsaW1pdENvdW50KVxyXG4gICAgKTtcclxuICAgIFxyXG4gICAgY29uc3Qgc25hcHNob3QgPSBhd2FpdCBnZXREb2NzKHEpO1xyXG4gICAgY29uc3QgcHJvZHVjdHMgPSBzbmFwc2hvdC5kb2NzLm1hcChkb2MgPT4gKHtcclxuICAgICAgaWQ6IGRvYy5pZCxcclxuICAgICAgLi4uZG9jLmRhdGEoKVxyXG4gICAgfSBhcyBQcm9kdWN0KSk7XHJcbiAgICBcclxuICAgIC8vIFVwZGF0ZSBieUlkIGNhY2hlXHJcbiAgICBwcm9kdWN0cy5mb3JFYWNoKHByb2R1Y3QgPT4ge1xyXG4gICAgICBwcm9kdWN0Q2FjaGUuYnlJZFtwcm9kdWN0LmlkXSA9IHByb2R1Y3Q7XHJcbiAgICAgIFxyXG4gICAgICAvLyBVcGRhdGUgY2F0ZWdvcnkgY2FjaGUgaWYgbmVlZGVkXHJcbiAgICAgIGlmIChwcm9kdWN0LmNhdGVnb3J5KSB7XHJcbiAgICAgICAgaWYgKCFwcm9kdWN0Q2FjaGUuYnlDYXRlZ29yeVtwcm9kdWN0LmNhdGVnb3J5XSkge1xyXG4gICAgICAgICAgcHJvZHVjdENhY2hlLmJ5Q2F0ZWdvcnlbcHJvZHVjdC5jYXRlZ29yeV0gPSBbXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgXHJcbiAgICAgICAgLy8gQ2hlY2sgaWYgcHJvZHVjdCBhbHJlYWR5IGV4aXN0cyBpbiBjYXRlZ29yeSBjYWNoZVxyXG4gICAgICAgIGNvbnN0IGV4aXN0aW5nSW5kZXggPSBwcm9kdWN0Q2FjaGUuYnlDYXRlZ29yeVtwcm9kdWN0LmNhdGVnb3J5XS5maW5kSW5kZXgoXHJcbiAgICAgICAgICBwID0+IHAuaWQgPT09IHByb2R1Y3QuaWRcclxuICAgICAgICApO1xyXG4gICAgICAgIFxyXG4gICAgICAgIGlmIChleGlzdGluZ0luZGV4ID49IDApIHtcclxuICAgICAgICAgIHByb2R1Y3RDYWNoZS5ieUNhdGVnb3J5W3Byb2R1Y3QuY2F0ZWdvcnldW2V4aXN0aW5nSW5kZXhdID0gcHJvZHVjdDtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgcHJvZHVjdENhY2hlLmJ5Q2F0ZWdvcnlbcHJvZHVjdC5jYXRlZ29yeV0ucHVzaChwcm9kdWN0KTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG4gICAgXHJcbiAgICByZXR1cm4gcHJvZHVjdHM7XHJcbiAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGdldHRpbmcgZmVhdHVyZWQgcHJvZHVjdHM6JywgZXJyb3IpO1xyXG4gICAgdGhyb3cgbmV3IEVycm9yKCdGYWlsZWQgdG8gZmV0Y2ggZmVhdHVyZWQgcHJvZHVjdHMnKTtcclxuICB9XHJcbn07XHJcblxyXG4vLyBHZXQgbmV3IGFycml2YWxzIHdpdGggY2FjaGluZ1xyXG5leHBvcnQgY29uc3QgZ2V0TmV3QXJyaXZhbHMgPSBhc3luYyAobGltaXRDb3VudDogbnVtYmVyID0gOCk6IFByb21pc2U8UHJvZHVjdFtdPiA9PiB7XHJcbiAgdHJ5IHtcclxuICAgIC8vIElmIHdlIGhhdmUgYWxsIHByb2R1Y3RzIGNhY2hlZCwgZmlsdGVyIHRoZW1cclxuICAgIGlmIChpc0NhY2hlVmFsaWQoKSAmJiBwcm9kdWN0Q2FjaGUuYWxsKSB7XHJcbiAgICAgIGNvbnN0IG5ld0Fycml2YWxzID0gcHJvZHVjdENhY2hlLmFsbFxyXG4gICAgICAgIC5maWx0ZXIocCA9PiBwLm5ldylcclxuICAgICAgICAuc2xpY2UoMCwgbGltaXRDb3VudCk7XHJcbiAgICAgICAgXHJcbiAgICAgIGlmIChuZXdBcnJpdmFscy5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgY29uc29sZS5sb2coJ1JldHVybmluZyBuZXcgYXJyaXZhbHMgZnJvbSBjYWNoZScpO1xyXG4gICAgICAgIHJldHVybiBuZXdBcnJpdmFscztcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgXHJcbiAgICBjb25zb2xlLmxvZygnRmV0Y2hpbmcgbmV3IGFycml2YWxzIGZyb20gRmlyZXN0b3JlJyk7XHJcbiAgICBjb25zdCBxID0gcXVlcnkoXHJcbiAgICAgIHByb2R1Y3RzQ29sbGVjdGlvbixcclxuICAgICAgd2hlcmUoJ25ldycsICc9PScsIHRydWUpLFxyXG4gICAgICBvcmRlckJ5KCdjcmVhdGVkQXQnLCAnZGVzYycpLFxyXG4gICAgICBsaW1pdChsaW1pdENvdW50KVxyXG4gICAgKTtcclxuICAgIFxyXG4gICAgY29uc3Qgc25hcHNob3QgPSBhd2FpdCBnZXREb2NzKHEpO1xyXG4gICAgY29uc3QgcHJvZHVjdHMgPSBzbmFwc2hvdC5kb2NzLm1hcChkb2MgPT4gKHtcclxuICAgICAgaWQ6IGRvYy5pZCxcclxuICAgICAgLi4uZG9jLmRhdGEoKVxyXG4gICAgfSBhcyBQcm9kdWN0KSk7XHJcbiAgICBcclxuICAgIC8vIFVwZGF0ZSBieUlkIGNhY2hlXHJcbiAgICBwcm9kdWN0cy5mb3JFYWNoKHByb2R1Y3QgPT4ge1xyXG4gICAgICBwcm9kdWN0Q2FjaGUuYnlJZFtwcm9kdWN0LmlkXSA9IHByb2R1Y3Q7XHJcbiAgICAgIFxyXG4gICAgICAvLyBVcGRhdGUgY2F0ZWdvcnkgY2FjaGUgaWYgbmVlZGVkXHJcbiAgICAgIGlmIChwcm9kdWN0LmNhdGVnb3J5KSB7XHJcbiAgICAgICAgaWYgKCFwcm9kdWN0Q2FjaGUuYnlDYXRlZ29yeVtwcm9kdWN0LmNhdGVnb3J5XSkge1xyXG4gICAgICAgICAgcHJvZHVjdENhY2hlLmJ5Q2F0ZWdvcnlbcHJvZHVjdC5jYXRlZ29yeV0gPSBbXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgXHJcbiAgICAgICAgLy8gQ2hlY2sgaWYgcHJvZHVjdCBhbHJlYWR5IGV4aXN0cyBpbiBjYXRlZ29yeSBjYWNoZVxyXG4gICAgICAgIGNvbnN0IGV4aXN0aW5nSW5kZXggPSBwcm9kdWN0Q2FjaGUuYnlDYXRlZ29yeVtwcm9kdWN0LmNhdGVnb3J5XS5maW5kSW5kZXgoXHJcbiAgICAgICAgICBwID0+IHAuaWQgPT09IHByb2R1Y3QuaWRcclxuICAgICAgICApO1xyXG4gICAgICAgIFxyXG4gICAgICAgIGlmIChleGlzdGluZ0luZGV4ID49IDApIHtcclxuICAgICAgICAgIHByb2R1Y3RDYWNoZS5ieUNhdGVnb3J5W3Byb2R1Y3QuY2F0ZWdvcnldW2V4aXN0aW5nSW5kZXhdID0gcHJvZHVjdDtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgcHJvZHVjdENhY2hlLmJ5Q2F0ZWdvcnlbcHJvZHVjdC5jYXRlZ29yeV0ucHVzaChwcm9kdWN0KTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG4gICAgXHJcbiAgICByZXR1cm4gcHJvZHVjdHM7XHJcbiAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGdldHRpbmcgbmV3IGFycml2YWxzOicsIGVycm9yKTtcclxuICAgIHRocm93IG5ldyBFcnJvcignRmFpbGVkIHRvIGZldGNoIG5ldyBhcnJpdmFscycpO1xyXG4gIH1cclxufTtcclxuXHJcbi8vIEdldCBwcm9kdWN0IGJ5IElEIHdpdGggY2FjaGluZ1xyXG5leHBvcnQgY29uc3QgZ2V0UHJvZHVjdEJ5SWQgPSBhc3luYyAoaWQ6IHN0cmluZyk6IFByb21pc2U8UHJvZHVjdCB8IG51bGw+ID0+IHtcclxuICB0cnkge1xyXG4gICAgLy8gQ2hlY2sgaWYgcHJvZHVjdCBpcyBpbiBjYWNoZVxyXG4gICAgaWYgKHByb2R1Y3RDYWNoZS5ieUlkW2lkXSkge1xyXG4gICAgICBjb25zb2xlLmxvZyhgUmV0dXJuaW5nIHByb2R1Y3QgJHtpZH0gZnJvbSBjYWNoZWApO1xyXG4gICAgICByZXR1cm4gcHJvZHVjdENhY2hlLmJ5SWRbaWRdO1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICBjb25zb2xlLmxvZyhgRmV0Y2hpbmcgcHJvZHVjdCAke2lkfSBmcm9tIEZpcmVzdG9yZWApO1xyXG4gICAgY29uc3QgcHJvZHVjdERvYyA9IGRvYyhkYiwgJ3Byb2R1Y3RzJywgaWQpO1xyXG4gICAgY29uc3Qgc25hcHNob3QgPSBhd2FpdCBnZXREb2MocHJvZHVjdERvYyk7XHJcbiAgICBcclxuICAgIGlmIChzbmFwc2hvdC5leGlzdHMoKSkge1xyXG4gICAgICBjb25zdCBwcm9kdWN0ID0ge1xyXG4gICAgICAgIGlkOiBzbmFwc2hvdC5pZCxcclxuICAgICAgICAuLi5zbmFwc2hvdC5kYXRhKClcclxuICAgICAgfSBhcyBQcm9kdWN0O1xyXG4gICAgICBcclxuICAgICAgLy8gVXBkYXRlIGNhY2hlXHJcbiAgICAgIHByb2R1Y3RDYWNoZS5ieUlkW2lkXSA9IHByb2R1Y3Q7XHJcbiAgICAgIFxyXG4gICAgICByZXR1cm4gcHJvZHVjdDtcclxuICAgIH1cclxuICAgIHJldHVybiBudWxsO1xyXG4gIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICBjb25zb2xlLmVycm9yKCdFcnJvciBnZXR0aW5nIHByb2R1Y3Q6JywgZXJyb3IpO1xyXG4gICAgdGhyb3cgbmV3IEVycm9yKCdGYWlsZWQgdG8gZmV0Y2ggcHJvZHVjdCBkZXRhaWxzJyk7XHJcbiAgfVxyXG59O1xyXG5cclxuLy8gQ2xlYXIgY2FjaGUgZm9yIGEgc3BlY2lmaWMgcHJvZHVjdFxyXG5jb25zdCBpbnZhbGlkYXRlUHJvZHVjdENhY2hlID0gKHByb2R1Y3RJZDogc3RyaW5nLCBjYXRlZ29yeUlkPzogc3RyaW5nKSA9PiB7XHJcbiAgLy8gUmVtb3ZlIGZyb20gYnlJZCBjYWNoZVxyXG4gIGlmIChwcm9kdWN0Q2FjaGUuYnlJZFtwcm9kdWN0SWRdKSB7XHJcbiAgICBkZWxldGUgcHJvZHVjdENhY2hlLmJ5SWRbcHJvZHVjdElkXTtcclxuICB9XHJcbiAgXHJcbiAgLy8gUmVtb3ZlIGZyb20gY2F0ZWdvcnkgY2FjaGUgaWYgY2F0ZWdvcnkgaXMgcHJvdmlkZWRcclxuICBpZiAoY2F0ZWdvcnlJZCAmJiBwcm9kdWN0Q2FjaGUuYnlDYXRlZ29yeVtjYXRlZ29yeUlkXSkge1xyXG4gICAgcHJvZHVjdENhY2hlLmJ5Q2F0ZWdvcnlbY2F0ZWdvcnlJZF0gPSBwcm9kdWN0Q2FjaGUuYnlDYXRlZ29yeVtjYXRlZ29yeUlkXS5maWx0ZXIoXHJcbiAgICAgIHAgPT4gcC5pZCAhPT0gcHJvZHVjdElkXHJcbiAgICApO1xyXG4gIH1cclxuICBcclxuICAvLyBTZXQgYWxsIGNhY2hlIHRvIG51bGwgdG8gZm9yY2UgcmVmcmVzaCBvbiBuZXh0IGZldGNoXHJcbiAgcHJvZHVjdENhY2hlLmFsbCA9IG51bGw7XHJcbn07XHJcblxyXG4vLyBDbGVhciBlbnRpcmUgY2FjaGVcclxuZXhwb3J0IGNvbnN0IGNsZWFyUHJvZHVjdENhY2hlID0gKCkgPT4ge1xyXG4gIHByb2R1Y3RDYWNoZS5hbGwgPSBudWxsO1xyXG4gIHByb2R1Y3RDYWNoZS5ieUlkID0ge307XHJcbiAgcHJvZHVjdENhY2hlLmJ5Q2F0ZWdvcnkgPSB7fTtcclxuICBwcm9kdWN0Q2FjaGUubGFzdEZldGNoZWQgPSAwO1xyXG59O1xyXG5cclxuLy8gVXBsb2FkIGltYWdlIHRvIEZpcmViYXNlIFN0b3JhZ2VcclxuZXhwb3J0IGNvbnN0IHVwbG9hZFByb2R1Y3RJbWFnZSA9IGFzeW5jIChmaWxlOiBGaWxlKTogUHJvbWlzZTxzdHJpbmc+ID0+IHtcclxuICB0cnkge1xyXG4gICAgLy8gQ3JlYXRlIGEgdW5pcXVlIGZpbGVuYW1lXHJcbiAgICBjb25zdCB0aW1lc3RhbXAgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcclxuICAgIGNvbnN0IGZpbGVOYW1lID0gYHByb2R1Y3RfJHt0aW1lc3RhbXB9XyR7ZmlsZS5uYW1lLnJlcGxhY2UoL1teYS16QS1aMC05Ll0vZywgJ18nKX1gO1xyXG4gICAgXHJcbiAgICAvLyBDcmVhdGUgYSByZWZlcmVuY2UgdG8gdGhlIGZpbGUgaW4gc3RvcmFnZVxyXG4gICAgY29uc3Qgc3RvcmFnZVJlZiA9IHJlZihzdG9yYWdlLCBgcHJvZHVjdF9pbWFnZXMvJHtmaWxlTmFtZX1gKTtcclxuICAgIFxyXG4gICAgLy8gVXBsb2FkIHRoZSBmaWxlXHJcbiAgICBhd2FpdCB1cGxvYWRCeXRlcyhzdG9yYWdlUmVmLCBmaWxlKTtcclxuICAgIFxyXG4gICAgLy8gR2V0IHRoZSBkb3dubG9hZCBVUkxcclxuICAgIGNvbnN0IGRvd25sb2FkVVJMID0gYXdhaXQgZ2V0RG93bmxvYWRVUkwoc3RvcmFnZVJlZik7XHJcbiAgICByZXR1cm4gZG93bmxvYWRVUkw7XHJcbiAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIHVwbG9hZGluZyBpbWFnZTonLCBlcnJvcik7XHJcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZhaWxlZCB0byB1cGxvYWQgcHJvZHVjdCBpbWFnZScpO1xyXG4gIH1cclxufTtcclxuXHJcbi8vIERlbGV0ZSBwcm9kdWN0IGltYWdlIGZyb20gRmlyZWJhc2UgU3RvcmFnZVxyXG5leHBvcnQgY29uc3QgZGVsZXRlUHJvZHVjdEltYWdlID0gYXN5bmMgKGltYWdlVXJsOiBzdHJpbmcpOiBQcm9taXNlPHZvaWQ+ID0+IHtcclxuICB0cnkge1xyXG4gICAgLy8gRXh0cmFjdCB0aGUgZmlsZSBwYXRoIGZyb20gdGhlIFVSTFxyXG4gICAgY29uc3QgZGVjb2RlZFVybCA9IGRlY29kZVVSSUNvbXBvbmVudChpbWFnZVVybCk7XHJcbiAgICBjb25zdCBzdGFydEluZGV4ID0gZGVjb2RlZFVybC5pbmRleE9mKCdwcm9kdWN0X2ltYWdlcycpO1xyXG4gICAgXHJcbiAgICBpZiAoc3RhcnRJbmRleCA9PT0gLTEpIHtcclxuICAgICAgY29uc29sZS53YXJuKCdOb3QgYSBGaXJlYmFzZSBTdG9yYWdlIFVSTCBvciBub3QgaW4gcHJvZHVjdF9pbWFnZXMgZm9sZGVyOicsIGltYWdlVXJsKTtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICBjb25zdCBlbmRJbmRleCA9IGRlY29kZWRVcmwuaW5kZXhPZignPycsIHN0YXJ0SW5kZXgpO1xyXG4gICAgY29uc3QgZmlsZVBhdGggPSBlbmRJbmRleCAhPT0gLTEgXHJcbiAgICAgID8gZGVjb2RlZFVybC5zdWJzdHJpbmcoc3RhcnRJbmRleCwgZW5kSW5kZXgpIFxyXG4gICAgICA6IGRlY29kZWRVcmwuc3Vic3RyaW5nKHN0YXJ0SW5kZXgpO1xyXG4gICAgXHJcbiAgICAvLyBDcmVhdGUgYSByZWZlcmVuY2UgdG8gdGhlIGZpbGVcclxuICAgIGNvbnN0IGltYWdlUmVmID0gcmVmKHN0b3JhZ2UsIGZpbGVQYXRoKTtcclxuICAgIFxyXG4gICAgLy8gRGVsZXRlIHRoZSBmaWxlXHJcbiAgICBhd2FpdCBkZWxldGVPYmplY3QoaW1hZ2VSZWYpO1xyXG4gICAgY29uc29sZS5sb2coJ1Byb2R1Y3QgaW1hZ2UgZGVsZXRlZCBzdWNjZXNzZnVsbHk6JywgZmlsZVBhdGgpO1xyXG4gIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICBjb25zb2xlLmVycm9yKCdFcnJvciBkZWxldGluZyBwcm9kdWN0IGltYWdlOicsIGVycm9yKTtcclxuICAgIC8vIERvbid0IHRocm93IGVycm9yIGhlcmUsIGFzIHdlIHdhbnQgdG8gY29udGludWUgd2l0aCBwcm9kdWN0IGRlbGV0aW9uXHJcbiAgICAvLyBldmVuIGlmIGltYWdlIGRlbGV0aW9uIGZhaWxzXHJcbiAgfVxyXG59O1xyXG5cclxuLy8gQWRkIGEgbmV3IHByb2R1Y3Qgd2l0aCB0cmFuc2FjdGlvbiBmb3IgY2F0ZWdvcnkgdHJhY2tpbmdcclxuZXhwb3J0IGNvbnN0IGFkZFByb2R1Y3QgPSBhc3luYyAocHJvZHVjdDogT21pdDxQcm9kdWN0LCAnaWQnPik6IFByb21pc2U8UHJvZHVjdD4gPT4ge1xyXG4gIHRyeSB7XHJcbiAgICBjb25zb2xlLmxvZygnQWRkaW5nIHByb2R1Y3QgdG8gRmlyZXN0b3JlOicsIHByb2R1Y3QpO1xyXG4gICAgXHJcbiAgICAvLyBWYWxpZGF0ZSBwcm9kdWN0IGRhdGFcclxuICAgIGNvbnN0IHZhbGlkYXRpb25FcnJvciA9IHZhbGlkYXRlUHJvZHVjdChwcm9kdWN0KTtcclxuICAgIGlmICh2YWxpZGF0aW9uRXJyb3IpIHtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKHZhbGlkYXRpb25FcnJvcik7XHJcbiAgICB9XHJcbiAgICBcclxuICAgIC8vIENsZWFuIHRoZSBwcm9kdWN0IGRhdGEgZm9yIEZpcmVzdG9yZVxyXG4gICAgY29uc3QgY2xlYW5lZFByb2R1Y3QgPSBjbGVhblByb2R1Y3REYXRhKHByb2R1Y3QpO1xyXG4gICAgY29uc29sZS5sb2coJ0NsZWFuZWQgcHJvZHVjdCBkYXRhIGZvciBGaXJlc3RvcmU6JywgY2xlYW5lZFByb2R1Y3QpO1xyXG4gICAgXHJcbiAgICAvLyBVc2UgdHJhbnNhY3Rpb24gdG8gYWRkIHByb2R1Y3QgYW5kIHVwZGF0ZSBjYXRlZ29yeSBkYXRhXHJcbiAgICBjb25zdCBuZXdQcm9kdWN0ID0gYXdhaXQgcnVuVHJhbnNhY3Rpb24oZGIsIGFzeW5jICh0cmFuc2FjdGlvbikgPT4ge1xyXG4gICAgICAvLyBBZGQgdGhlIHByb2R1Y3QgZG9jdW1lbnRcclxuICAgICAgY29uc3QgZG9jUmVmID0gYXdhaXQgYWRkRG9jKHByb2R1Y3RzQ29sbGVjdGlvbiwgY2xlYW5lZFByb2R1Y3QpO1xyXG4gICAgICBjb25zdCBuZXdQcm9kdWN0V2l0aElkID0geyBcclxuICAgICAgICBpZDogZG9jUmVmLmlkLCBcclxuICAgICAgICAuLi5jbGVhbmVkUHJvZHVjdCBcclxuICAgICAgfSBhcyB1bmtub3duIGFzIFByb2R1Y3Q7XHJcbiAgICAgIFxyXG4gICAgICAvLyBVcGRhdGUgb3IgY3JlYXRlIGNhdGVnb3J5IGNvdW50XHJcbiAgICAgIGNvbnN0IGNhdGVnb3J5UmVmID0gZG9jKGNhdGVnb3JpZXNDb2xsZWN0aW9uLCBjbGVhbmVkUHJvZHVjdC5jYXRlZ29yeSk7XHJcbiAgICAgIGNvbnN0IGNhdGVnb3J5RG9jID0gYXdhaXQgdHJhbnNhY3Rpb24uZ2V0KGNhdGVnb3J5UmVmKTtcclxuICAgICAgXHJcbiAgICAgIGlmIChjYXRlZ29yeURvYy5leGlzdHMoKSkge1xyXG4gICAgICAgIC8vIFVwZGF0ZSBleGlzdGluZyBjYXRlZ29yeVxyXG4gICAgICAgIHRyYW5zYWN0aW9uLnVwZGF0ZShjYXRlZ29yeVJlZiwge1xyXG4gICAgICAgICAgY291bnQ6IChjYXRlZ29yeURvYy5kYXRhKCkuY291bnQgfHwgMCkgKyAxLFxyXG4gICAgICAgICAgdXBkYXRlZEF0OiBzZXJ2ZXJUaW1lc3RhbXAoKVxyXG4gICAgICAgIH0pO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIC8vIENyZWF0ZSBuZXcgY2F0ZWdvcnlcclxuICAgICAgICB0cmFuc2FjdGlvbi5zZXQoY2F0ZWdvcnlSZWYsIHtcclxuICAgICAgICAgIGlkOiBjbGVhbmVkUHJvZHVjdC5jYXRlZ29yeSxcclxuICAgICAgICAgIG5hbWU6IGNsZWFuZWRQcm9kdWN0LmNhdGVnb3J5LmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgY2xlYW5lZFByb2R1Y3QuY2F0ZWdvcnkuc2xpY2UoMSksXHJcbiAgICAgICAgICBjb3VudDogMSxcclxuICAgICAgICAgIGNyZWF0ZWRBdDogc2VydmVyVGltZXN0YW1wKCksXHJcbiAgICAgICAgICB1cGRhdGVkQXQ6IHNlcnZlclRpbWVzdGFtcCgpXHJcbiAgICAgICAgfSk7XHJcbiAgICAgIH1cclxuICAgICAgXHJcbiAgICAgIHJldHVybiBuZXdQcm9kdWN0V2l0aElkO1xyXG4gICAgfSk7XHJcbiAgICBcclxuICAgIC8vIFVwZGF0ZSBjYWNoZSB3aXRoIHRoZSBuZXcgcHJvZHVjdFxyXG4gICAgaWYgKHByb2R1Y3RDYWNoZS5hbGwpIHtcclxuICAgICAgcHJvZHVjdENhY2hlLmFsbC51bnNoaWZ0KG5ld1Byb2R1Y3QgYXMgUHJvZHVjdCk7XHJcbiAgICB9XHJcbiAgICBcclxuICAgIHByb2R1Y3RDYWNoZS5ieUlkW25ld1Byb2R1Y3QuaWRdID0gbmV3UHJvZHVjdCBhcyBQcm9kdWN0O1xyXG4gICAgXHJcbiAgICBpZiAobmV3UHJvZHVjdC5jYXRlZ29yeSkge1xyXG4gICAgICBpZiAoIXByb2R1Y3RDYWNoZS5ieUNhdGVnb3J5W25ld1Byb2R1Y3QuY2F0ZWdvcnldKSB7XHJcbiAgICAgICAgcHJvZHVjdENhY2hlLmJ5Q2F0ZWdvcnlbbmV3UHJvZHVjdC5jYXRlZ29yeV0gPSBbXTtcclxuICAgICAgfVxyXG4gICAgICBwcm9kdWN0Q2FjaGUuYnlDYXRlZ29yeVtuZXdQcm9kdWN0LmNhdGVnb3J5XS51bnNoaWZ0KG5ld1Byb2R1Y3QgYXMgUHJvZHVjdCk7XHJcbiAgICB9XHJcbiAgICBcclxuICAgIGNvbnNvbGUubG9nKCdQcm9kdWN0IGFkZGVkIHN1Y2Nlc3NmdWxseSB3aXRoIElEOicsIG5ld1Byb2R1Y3QuaWQpO1xyXG4gICAgcmV0dXJuIG5ld1Byb2R1Y3QgYXMgUHJvZHVjdDtcclxuICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgY29uc29sZS5lcnJvcignRXJyb3IgYWRkaW5nIHByb2R1Y3QgdG8gRmlyZXN0b3JlOicsIGVycm9yKTtcclxuICAgIHRocm93IGVycm9yO1xyXG4gIH1cclxufTtcclxuXHJcbi8vIFVwZGF0ZSBhIHByb2R1Y3RcclxuZXhwb3J0IGNvbnN0IHVwZGF0ZVByb2R1Y3QgPSBhc3luYyAoaWQ6IHN0cmluZywgcHJvZHVjdDogUGFydGlhbDxQcm9kdWN0Pik6IFByb21pc2U8dm9pZD4gPT4ge1xyXG4gIHRyeSB7XHJcbiAgICBjb25zdCBwcm9kdWN0RG9jID0gZG9jKGRiLCAncHJvZHVjdHMnLCBpZCk7XHJcbiAgICBcclxuICAgIC8vIEdldCBleGlzdGluZyBwcm9kdWN0IHRvIGNoZWNrIGlmIGNhdGVnb3J5IGlzIGNoYW5naW5nXHJcbiAgICBjb25zdCBleGlzdGluZ1Byb2R1Y3RTbmFwID0gYXdhaXQgZ2V0RG9jKHByb2R1Y3REb2MpO1xyXG4gICAgaWYgKCFleGlzdGluZ1Byb2R1Y3RTbmFwLmV4aXN0cygpKSB7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcignUHJvZHVjdCBub3QgZm91bmQnKTtcclxuICAgIH1cclxuICAgIFxyXG4gICAgY29uc3QgZXhpc3RpbmdQcm9kdWN0ID0gZXhpc3RpbmdQcm9kdWN0U25hcC5kYXRhKCk7XHJcbiAgICBjb25zdCBjbGVhbmVkVXBkYXRlcyA9IGNsZWFuUHJvZHVjdERhdGEocHJvZHVjdCk7XHJcbiAgICBcclxuICAgIC8vIEFsd2F5cyB1cGRhdGUgdGhlIHRpbWVzdGFtcCB3aGVuIG1vZGlmaWVkXHJcbiAgICBjbGVhbmVkVXBkYXRlcy51cGRhdGVkQXQgPSBzZXJ2ZXJUaW1lc3RhbXAoKTtcclxuICAgIFxyXG4gICAgYXdhaXQgcnVuVHJhbnNhY3Rpb24oZGIsIGFzeW5jICh0cmFuc2FjdGlvbikgPT4ge1xyXG4gICAgICAvLyBVcGRhdGUgcHJvZHVjdCBkb2N1bWVudFxyXG4gICAgICB0cmFuc2FjdGlvbi51cGRhdGUocHJvZHVjdERvYywgY2xlYW5lZFVwZGF0ZXMpO1xyXG4gICAgICBcclxuICAgICAgLy8gSWYgY2F0ZWdvcnkgY2hhbmdlZCwgdXBkYXRlIGJvdGggb2xkIGFuZCBuZXcgY2F0ZWdvcnkgY291bnRzXHJcbiAgICAgIGlmIChwcm9kdWN0LmNhdGVnb3J5ICYmIGV4aXN0aW5nUHJvZHVjdC5jYXRlZ29yeSAhPT0gcHJvZHVjdC5jYXRlZ29yeSkge1xyXG4gICAgICAgIC8vIERlY3JlYXNlIG9sZCBjYXRlZ29yeSBjb3VudFxyXG4gICAgICAgIGNvbnN0IG9sZENhdGVnb3J5UmVmID0gZG9jKGNhdGVnb3JpZXNDb2xsZWN0aW9uLCBleGlzdGluZ1Byb2R1Y3QuY2F0ZWdvcnkpO1xyXG4gICAgICAgIGNvbnN0IG9sZENhdGVnb3J5RG9jID0gYXdhaXQgdHJhbnNhY3Rpb24uZ2V0KG9sZENhdGVnb3J5UmVmKTtcclxuICAgICAgICBcclxuICAgICAgICBpZiAob2xkQ2F0ZWdvcnlEb2MuZXhpc3RzKCkpIHtcclxuICAgICAgICAgIGNvbnN0IG9sZENvdW50ID0gb2xkQ2F0ZWdvcnlEb2MuZGF0YSgpLmNvdW50IHx8IDA7XHJcbiAgICAgICAgICBpZiAob2xkQ291bnQgPiAxKSB7XHJcbiAgICAgICAgICAgIHRyYW5zYWN0aW9uLnVwZGF0ZShvbGRDYXRlZ29yeVJlZiwgeyBcclxuICAgICAgICAgICAgICBjb3VudDogb2xkQ291bnQgLSAxLFxyXG4gICAgICAgICAgICAgIHVwZGF0ZWRBdDogc2VydmVyVGltZXN0YW1wKClcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAvLyBEZWxldGUgY2F0ZWdvcnkgaWYgaXQgd2lsbCBiZSBlbXB0eVxyXG4gICAgICAgICAgICB0cmFuc2FjdGlvbi5kZWxldGUob2xkQ2F0ZWdvcnlSZWYpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBcclxuICAgICAgICAvLyBJbmNyZWFzZSBuZXcgY2F0ZWdvcnkgY291bnRcclxuICAgICAgICBjb25zdCBuZXdDYXRlZ29yeVJlZiA9IGRvYyhjYXRlZ29yaWVzQ29sbGVjdGlvbiwgcHJvZHVjdC5jYXRlZ29yeSk7XHJcbiAgICAgICAgY29uc3QgbmV3Q2F0ZWdvcnlEb2MgPSBhd2FpdCB0cmFuc2FjdGlvbi5nZXQobmV3Q2F0ZWdvcnlSZWYpO1xyXG4gICAgICAgIFxyXG4gICAgICAgIGlmIChuZXdDYXRlZ29yeURvYy5leGlzdHMoKSkge1xyXG4gICAgICAgICAgdHJhbnNhY3Rpb24udXBkYXRlKG5ld0NhdGVnb3J5UmVmLCB7IFxyXG4gICAgICAgICAgICBjb3VudDogKG5ld0NhdGVnb3J5RG9jLmRhdGEoKS5jb3VudCB8fCAwKSArIDEsXHJcbiAgICAgICAgICAgIHVwZGF0ZWRBdDogc2VydmVyVGltZXN0YW1wKClcclxuICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICB0cmFuc2FjdGlvbi5zZXQobmV3Q2F0ZWdvcnlSZWYsIHtcclxuICAgICAgICAgICAgaWQ6IHByb2R1Y3QuY2F0ZWdvcnksXHJcbiAgICAgICAgICAgIG5hbWU6IHByb2R1Y3QuY2F0ZWdvcnkuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBwcm9kdWN0LmNhdGVnb3J5LnNsaWNlKDEpLFxyXG4gICAgICAgICAgICBjb3VudDogMSxcclxuICAgICAgICAgICAgY3JlYXRlZEF0OiBzZXJ2ZXJUaW1lc3RhbXAoKSxcclxuICAgICAgICAgICAgdXBkYXRlZEF0OiBzZXJ2ZXJUaW1lc3RhbXAoKVxyXG4gICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9KTtcclxuICAgIFxyXG4gICAgLy8gVXBkYXRlIGNhY2hlXHJcbiAgICBpZiAocHJvZHVjdENhY2hlLmJ5SWRbaWRdKSB7XHJcbiAgICAgIGNvbnN0IHVwZGF0ZWRQcm9kdWN0ID0geyAuLi5wcm9kdWN0Q2FjaGUuYnlJZFtpZF0sIC4uLnByb2R1Y3QgfTtcclxuICAgICAgcHJvZHVjdENhY2hlLmJ5SWRbaWRdID0gdXBkYXRlZFByb2R1Y3Q7XHJcbiAgICAgIFxyXG4gICAgICAvLyBVcGRhdGUgaW4gYWxsIHByb2R1Y3RzIGNhY2hlIGlmIGl0IGV4aXN0c1xyXG4gICAgICBpZiAocHJvZHVjdENhY2hlLmFsbCkge1xyXG4gICAgICAgIGNvbnN0IGluZGV4ID0gcHJvZHVjdENhY2hlLmFsbC5maW5kSW5kZXgocCA9PiBwLmlkID09PSBpZCk7XHJcbiAgICAgICAgaWYgKGluZGV4ID49IDApIHtcclxuICAgICAgICAgIHByb2R1Y3RDYWNoZS5hbGxbaW5kZXhdID0gdXBkYXRlZFByb2R1Y3Q7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIFxyXG4gICAgICAvLyBIYW5kbGUgY2F0ZWdvcnkgY2hhbmdlIGluIGNhY2hlXHJcbiAgICAgIGlmIChwcm9kdWN0LmNhdGVnb3J5ICYmIGV4aXN0aW5nUHJvZHVjdC5jYXRlZ29yeSAhPT0gcHJvZHVjdC5jYXRlZ29yeSkge1xyXG4gICAgICAgIC8vIFJlbW92ZSBmcm9tIG9sZCBjYXRlZ29yeSBjYWNoZVxyXG4gICAgICAgIGlmIChwcm9kdWN0Q2FjaGUuYnlDYXRlZ29yeVtleGlzdGluZ1Byb2R1Y3QuY2F0ZWdvcnldKSB7XHJcbiAgICAgICAgICBwcm9kdWN0Q2FjaGUuYnlDYXRlZ29yeVtleGlzdGluZ1Byb2R1Y3QuY2F0ZWdvcnldID0gcHJvZHVjdENhY2hlLmJ5Q2F0ZWdvcnlbZXhpc3RpbmdQcm9kdWN0LmNhdGVnb3J5XS5maWx0ZXIoXHJcbiAgICAgICAgICAgIHAgPT4gcC5pZCAhPT0gaWRcclxuICAgICAgICAgICk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIFxyXG4gICAgICAgIC8vIEFkZCB0byBuZXcgY2F0ZWdvcnkgY2FjaGVcclxuICAgICAgICBpZiAoIXByb2R1Y3RDYWNoZS5ieUNhdGVnb3J5W3Byb2R1Y3QuY2F0ZWdvcnldKSB7XHJcbiAgICAgICAgICBwcm9kdWN0Q2FjaGUuYnlDYXRlZ29yeVtwcm9kdWN0LmNhdGVnb3J5XSA9IFtdO1xyXG4gICAgICAgIH1cclxuICAgICAgICBwcm9kdWN0Q2FjaGUuYnlDYXRlZ29yeVtwcm9kdWN0LmNhdGVnb3J5XS5wdXNoKHVwZGF0ZWRQcm9kdWN0KTtcclxuICAgICAgfSBlbHNlIGlmIChwcm9kdWN0LmNhdGVnb3J5KSB7XHJcbiAgICAgICAgLy8gVXBkYXRlIGluIHNhbWUgY2F0ZWdvcnlcclxuICAgICAgICBpZiAocHJvZHVjdENhY2hlLmJ5Q2F0ZWdvcnlbcHJvZHVjdC5jYXRlZ29yeV0pIHtcclxuICAgICAgICAgIGNvbnN0IGNhdEluZGV4ID0gcHJvZHVjdENhY2hlLmJ5Q2F0ZWdvcnlbcHJvZHVjdC5jYXRlZ29yeV0uZmluZEluZGV4KHAgPT4gcC5pZCA9PT0gaWQpO1xyXG4gICAgICAgICAgaWYgKGNhdEluZGV4ID49IDApIHtcclxuICAgICAgICAgICAgcHJvZHVjdENhY2hlLmJ5Q2F0ZWdvcnlbcHJvZHVjdC5jYXRlZ29yeV1bY2F0SW5kZXhdID0gdXBkYXRlZFByb2R1Y3Q7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAvLyBJZiBub3QgaW4gY2FjaGUsIGludmFsaWRhdGUgYWxsIGNhY2hlIHRvIGZvcmNlIHJlZnJlc2hcclxuICAgICAgY2xlYXJQcm9kdWN0Q2FjaGUoKTtcclxuICAgIH1cclxuICAgIFxyXG4gIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICBjb25zb2xlLmVycm9yKCdFcnJvciB1cGRhdGluZyBwcm9kdWN0OicsIGVycm9yKTtcclxuICAgIHRocm93IG5ldyBFcnJvcignRmFpbGVkIHRvIHVwZGF0ZSBwcm9kdWN0Jyk7XHJcbiAgfVxyXG59O1xyXG5cclxuLy8gRGVsZXRlIGEgcHJvZHVjdFxyXG5leHBvcnQgY29uc3QgZGVsZXRlUHJvZHVjdCA9IGFzeW5jIChpZDogc3RyaW5nKTogUHJvbWlzZTx2b2lkPiA9PiB7XHJcbiAgdHJ5IHtcclxuICAgIGNvbnN0IHByb2R1Y3REb2MgPSBkb2MoZGIsICdwcm9kdWN0cycsIGlkKTtcclxuICAgIFxyXG4gICAgLy8gR2V0IHByb2R1Y3QgdG8gZmluZCBpdHMgY2F0ZWdvcnkgYW5kIGltYWdlIFVSTFxyXG4gICAgY29uc3QgcHJvZHVjdFNuYXAgPSBhd2FpdCBnZXREb2MocHJvZHVjdERvYyk7XHJcbiAgICBpZiAoIXByb2R1Y3RTbmFwLmV4aXN0cygpKSB7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcignUHJvZHVjdCBub3QgZm91bmQnKTtcclxuICAgIH1cclxuICAgIFxyXG4gICAgY29uc3QgcHJvZHVjdERhdGEgPSBwcm9kdWN0U25hcC5kYXRhKCkgYXMgUHJvZHVjdDtcclxuICAgIFxyXG4gICAgLy8gVHJ5IHRvIGRlbGV0ZSB0aGUgcHJvZHVjdCBpbWFnZSBmaXJzdFxyXG4gICAgaWYgKHByb2R1Y3REYXRhLmltYWdlKSB7XHJcbiAgICAgIHRyeSB7XHJcbiAgICAgICAgYXdhaXQgZGVsZXRlUHJvZHVjdEltYWdlKHByb2R1Y3REYXRhLmltYWdlKTtcclxuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBkZWxldGluZyBwcm9kdWN0IGltYWdlOicsIGVycm9yKTtcclxuICAgICAgICAvLyBDb250aW51ZSB3aXRoIHByb2R1Y3QgZGVsZXRpb24gZXZlbiBpZiBpbWFnZSBkZWxldGlvbiBmYWlsc1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICBcclxuICAgIGF3YWl0IHJ1blRyYW5zYWN0aW9uKGRiLCBhc3luYyAodHJhbnNhY3Rpb24pID0+IHtcclxuICAgICAgLy8gRGVsZXRlIHByb2R1Y3RcclxuICAgICAgdHJhbnNhY3Rpb24uZGVsZXRlKHByb2R1Y3REb2MpO1xyXG4gICAgICBcclxuICAgICAgLy8gVXBkYXRlIGNhdGVnb3J5IGNvdW50XHJcbiAgICAgIGlmIChwcm9kdWN0RGF0YS5jYXRlZ29yeSkge1xyXG4gICAgICAgIGNvbnN0IGNhdGVnb3J5UmVmID0gZG9jKGNhdGVnb3JpZXNDb2xsZWN0aW9uLCBwcm9kdWN0RGF0YS5jYXRlZ29yeSk7XHJcbiAgICAgICAgY29uc3QgY2F0ZWdvcnlEb2MgPSBhd2FpdCB0cmFuc2FjdGlvbi5nZXQoY2F0ZWdvcnlSZWYpO1xyXG4gICAgICAgIFxyXG4gICAgICAgIGlmIChjYXRlZ29yeURvYy5leGlzdHMoKSkge1xyXG4gICAgICAgICAgY29uc3QgY291bnQgPSBjYXRlZ29yeURvYy5kYXRhKCkuY291bnQgfHwgMDtcclxuICAgICAgICAgIGlmIChjb3VudCA+IDEpIHtcclxuICAgICAgICAgICAgdHJhbnNhY3Rpb24udXBkYXRlKGNhdGVnb3J5UmVmLCB7IFxyXG4gICAgICAgICAgICAgIGNvdW50OiBjb3VudCAtIDEsXHJcbiAgICAgICAgICAgICAgdXBkYXRlZEF0OiBzZXJ2ZXJUaW1lc3RhbXAoKVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIC8vIERlbGV0ZSBjYXRlZ29yeSBpZiBpdCB3aWxsIGJlIGVtcHR5XHJcbiAgICAgICAgICAgIHRyYW5zYWN0aW9uLmRlbGV0ZShjYXRlZ29yeVJlZik7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9KTtcclxuICAgIFxyXG4gICAgLy8gVXBkYXRlIGNhY2hlXHJcbiAgICBpbnZhbGlkYXRlUHJvZHVjdENhY2hlKGlkLCBwcm9kdWN0RGF0YS5jYXRlZ29yeSk7XHJcbiAgICBcclxuICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgY29uc29sZS5lcnJvcignRXJyb3IgZGVsZXRpbmcgcHJvZHVjdDonLCBlcnJvcik7XHJcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZhaWxlZCB0byBkZWxldGUgcHJvZHVjdCcpO1xyXG4gIH1cclxufTtcclxuXHJcbi8vIEdldCBhbGwgY2F0ZWdvcmllcyB3aXRoIHByb2R1Y3QgY291bnRzXHJcbmV4cG9ydCBjb25zdCBnZXRBbGxDYXRlZ29yaWVzID0gYXN5bmMgKCkgPT4ge1xyXG4gIHRyeSB7XHJcbiAgICBjb25zdCBzbmFwc2hvdCA9IGF3YWl0IGdldERvY3MoY2F0ZWdvcmllc0NvbGxlY3Rpb24pO1xyXG4gICAgcmV0dXJuIHNuYXBzaG90LmRvY3MubWFwKGRvYyA9PiBkb2MuZGF0YSgpKTtcclxuICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgY29uc29sZS5lcnJvcignRXJyb3IgZ2V0dGluZyBjYXRlZ29yaWVzOicsIGVycm9yKTtcclxuICAgIHRocm93IG5ldyBFcnJvcignRmFpbGVkIHRvIGZldGNoIGNhdGVnb3JpZXMnKTtcclxuICB9XHJcbn07ICJdLCJuYW1lcyI6WyJhcHAiLCJnZXRGaXJlc3RvcmUiLCJjb2xsZWN0aW9uIiwiZ2V0RG9jcyIsImRvYyIsImdldERvYyIsImFkZERvYyIsInF1ZXJ5Iiwid2hlcmUiLCJydW5UcmFuc2FjdGlvbiIsInNlcnZlclRpbWVzdGFtcCIsImxpbWl0Iiwib3JkZXJCeSIsInN0YXJ0QWZ0ZXIiLCJnZXRTdG9yYWdlIiwicmVmIiwidXBsb2FkQnl0ZXMiLCJnZXREb3dubG9hZFVSTCIsImRlbGV0ZU9iamVjdCIsImRiIiwic3RvcmFnZSIsInByb2R1Y3RzQ29sbGVjdGlvbiIsImNhdGVnb3JpZXNDb2xsZWN0aW9uIiwicHJvZHVjdENhY2hlIiwiYWxsIiwiYnlJZCIsImJ5Q2F0ZWdvcnkiLCJsYXN0RmV0Y2hlZCIsIkNBQ0hFX0VYUElSQVRJT04iLCJ2YWxpZGF0ZVByb2R1Y3QiLCJwcm9kdWN0IiwibmFtZSIsInByaWNlIiwiaXNOYU4iLCJOdW1iZXIiLCJjYXRlZ29yeSIsImltYWdlIiwiY2xlYW5Qcm9kdWN0RGF0YSIsImNsZWFuZWRQcm9kdWN0IiwiT2JqZWN0IiwiZW50cmllcyIsImZvckVhY2giLCJrZXkiLCJ2YWx1ZSIsInVuZGVmaW5lZCIsInNwbGl0IiwibWFwIiwicyIsInRyaW0iLCJmaWx0ZXIiLCJCb29sZWFuIiwiY3JlYXRlZEF0IiwidXBkYXRlZEF0IiwiaXNDYWNoZVZhbGlkIiwiRGF0ZSIsIm5vdyIsImdldEFsbFByb2R1Y3RzIiwicGFnZVNpemUiLCJjb25zb2xlIiwibG9nIiwicHJvZHVjdHNRdWVyeSIsInNuYXBzaG90IiwicHJvZHVjdHMiLCJkb2NzIiwiaWQiLCJkYXRhIiwicHVzaCIsImxlbmd0aCIsImVycm9yIiwiRXJyb3IiLCJnZXROZXh0UHJvZHVjdHNQYWdlIiwibGFzdFZpc2libGUiLCJleGlzdGluZ0luZGV4IiwiZmluZEluZGV4IiwicCIsImdldFByb2R1Y3RzQnlDYXRlZ29yeSIsInEiLCJnZXRGZWF0dXJlZFByb2R1Y3RzIiwibGltaXRDb3VudCIsImZlYXR1cmVkIiwic2xpY2UiLCJnZXROZXdBcnJpdmFscyIsIm5ld0Fycml2YWxzIiwibmV3IiwiZ2V0UHJvZHVjdEJ5SWQiLCJwcm9kdWN0RG9jIiwiZXhpc3RzIiwiaW52YWxpZGF0ZVByb2R1Y3RDYWNoZSIsInByb2R1Y3RJZCIsImNhdGVnb3J5SWQiLCJjbGVhclByb2R1Y3RDYWNoZSIsInVwbG9hZFByb2R1Y3RJbWFnZSIsImZpbGUiLCJ0aW1lc3RhbXAiLCJnZXRUaW1lIiwiZmlsZU5hbWUiLCJyZXBsYWNlIiwic3RvcmFnZVJlZiIsImRvd25sb2FkVVJMIiwiZGVsZXRlUHJvZHVjdEltYWdlIiwiaW1hZ2VVcmwiLCJkZWNvZGVkVXJsIiwiZGVjb2RlVVJJQ29tcG9uZW50Iiwic3RhcnRJbmRleCIsImluZGV4T2YiLCJ3YXJuIiwiZW5kSW5kZXgiLCJmaWxlUGF0aCIsInN1YnN0cmluZyIsImltYWdlUmVmIiwiYWRkUHJvZHVjdCIsInZhbGlkYXRpb25FcnJvciIsIm5ld1Byb2R1Y3QiLCJ0cmFuc2FjdGlvbiIsImRvY1JlZiIsIm5ld1Byb2R1Y3RXaXRoSWQiLCJjYXRlZ29yeVJlZiIsImNhdGVnb3J5RG9jIiwiZ2V0IiwidXBkYXRlIiwiY291bnQiLCJzZXQiLCJjaGFyQXQiLCJ0b1VwcGVyQ2FzZSIsInVuc2hpZnQiLCJ1cGRhdGVQcm9kdWN0IiwiZXhpc3RpbmdQcm9kdWN0U25hcCIsImV4aXN0aW5nUHJvZHVjdCIsImNsZWFuZWRVcGRhdGVzIiwib2xkQ2F0ZWdvcnlSZWYiLCJvbGRDYXRlZ29yeURvYyIsIm9sZENvdW50IiwiZGVsZXRlIiwibmV3Q2F0ZWdvcnlSZWYiLCJuZXdDYXRlZ29yeURvYyIsInVwZGF0ZWRQcm9kdWN0IiwiaW5kZXgiLCJjYXRJbmRleCIsImRlbGV0ZVByb2R1Y3QiLCJwcm9kdWN0U25hcCIsInByb2R1Y3REYXRhIiwiZ2V0QWxsQ2F0ZWdvcmllcyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./utils/firestore.ts\n"));

/***/ })

});