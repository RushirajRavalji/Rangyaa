"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("pages/_app",{

/***/ "./utils/firestore.ts":
/*!****************************!*\
  !*** ./utils/firestore.ts ***!
  \****************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   addProduct: function() { return /* binding */ addProduct; },\n/* harmony export */   clearProductCache: function() { return /* binding */ clearProductCache; },\n/* harmony export */   db: function() { return /* binding */ db; },\n/* harmony export */   deleteProduct: function() { return /* binding */ deleteProduct; },\n/* harmony export */   deleteProductImage: function() { return /* binding */ deleteProductImage; },\n/* harmony export */   getAllCategories: function() { return /* binding */ getAllCategories; },\n/* harmony export */   getAllProducts: function() { return /* binding */ getAllProducts; },\n/* harmony export */   getFeaturedProducts: function() { return /* binding */ getFeaturedProducts; },\n/* harmony export */   getNewArrivals: function() { return /* binding */ getNewArrivals; },\n/* harmony export */   getNextProductsPage: function() { return /* binding */ getNextProductsPage; },\n/* harmony export */   getProductById: function() { return /* binding */ getProductById; },\n/* harmony export */   getProductsByCategory: function() { return /* binding */ getProductsByCategory; },\n/* harmony export */   storage: function() { return /* binding */ storage; },\n/* harmony export */   updateProduct: function() { return /* binding */ updateProduct; },\n/* harmony export */   uploadProductImage: function() { return /* binding */ uploadProductImage; }\n/* harmony export */ });\n/* harmony import */ var _firebase__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./firebase */ \"./utils/firebase.ts\");\n/* harmony import */ var firebase_firestore__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! firebase/firestore */ \"./node_modules/firebase/firestore/dist/esm/index.esm.js\");\n/* harmony import */ var firebase_storage__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! firebase/storage */ \"./node_modules/firebase/storage/dist/esm/index.esm.js\");\n\n\n\n// Initialize Firestore\nconst db = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.getFirestore)(_firebase__WEBPACK_IMPORTED_MODULE_0__.app);\n// Initialize Storage\nconst storage = (0,firebase_storage__WEBPACK_IMPORTED_MODULE_2__.getStorage)(_firebase__WEBPACK_IMPORTED_MODULE_0__.app);\n// Collection references\nconst productsCollection = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.collection)(db, \"products\");\nconst categoriesCollection = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.collection)(db, \"categories\");\n// Cache for products\nconst productCache = {\n    all: null,\n    byId: {},\n    byCategory: {},\n    lastFetched: 0\n};\n// Cache expiration time (5 minutes)\nconst CACHE_EXPIRATION = 5 * 60 * 1000;\n// Validate product data before saving\nconst validateProduct = (product)=>{\n    if (!product.name || typeof product.name !== \"string\") {\n        return \"Product name is required\";\n    }\n    if (!product.price || isNaN(Number(product.price))) {\n        return \"Valid product price is required\";\n    }\n    if (!product.category || typeof product.category !== \"string\") {\n        return \"Product category is required\";\n    }\n    if (!product.image || typeof product.image !== \"string\") {\n        return \"Product image is required\";\n    }\n    return null; // No errors\n};\n// Clean product data for Firestore\nconst cleanProductData = (product)=>{\n    const cleanedProduct = {};\n    Object.entries(product).forEach((param)=>{\n        let [key, value] = param;\n        if (value !== undefined && value !== null) {\n            // Handle specific field types\n            if (key === \"price\" || key === \"originalPrice\" || key === \"stock\") {\n                cleanedProduct[key] = Number(value);\n            } else if (key === \"sizes\" && typeof value === \"string\") {\n                cleanedProduct[key] = value.split(\",\").map((s)=>s.trim()).filter(Boolean);\n            } else if (key === \"featured\" && typeof value === \"string\") {\n                cleanedProduct[key] = value === \"true\";\n            } else {\n                cleanedProduct[key] = value;\n            }\n        }\n    });\n    // Add timestamps\n    if (!cleanedProduct.createdAt) {\n        cleanedProduct.createdAt = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.serverTimestamp)();\n    }\n    cleanedProduct.updatedAt = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.serverTimestamp)();\n    return cleanedProduct;\n};\n// Check if cache is valid\nconst isCacheValid = ()=>{\n    return productCache.all !== null && Date.now() - productCache.lastFetched < CACHE_EXPIRATION;\n};\n// Get all products with pagination and caching\nconst getAllProducts = async function() {\n    let pageSize = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;\n    try {\n        // If cache is valid and we're not paginating, return cached products\n        if (isCacheValid() && pageSize === 0 && productCache.all) {\n            console.log(\"Returning products from cache\");\n            return productCache.all;\n        }\n        console.log(\"Fetching products from Firestore\");\n        let productsQuery = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.query)(productsCollection, (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.orderBy)(\"createdAt\", \"desc\"));\n        // Apply pagination if pageSize is specified\n        if (pageSize > 0) {\n            productsQuery = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.query)(productsQuery, (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.limit)(pageSize));\n        }\n        const snapshot = await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.getDocs)(productsQuery);\n        const products = snapshot.docs.map((doc)=>({\n                id: doc.id,\n                ...doc.data()\n            }));\n        // Update cache if we're getting all products\n        if (pageSize === 0) {\n            productCache.all = products;\n            // Update byId and byCategory caches\n            products.forEach((product)=>{\n                productCache.byId[product.id] = product;\n                if (product.category) {\n                    if (!productCache.byCategory[product.category]) {\n                        productCache.byCategory[product.category] = [];\n                    }\n                    productCache.byCategory[product.category].push(product);\n                }\n            });\n            productCache.lastFetched = Date.now();\n        }\n        console.log(\"Retrieved \".concat(products.length, \" products from Firestore\"));\n        return products;\n    } catch (error) {\n        console.error(\"Error getting products from Firestore:\", error);\n        throw new Error(\"Failed to fetch products\");\n    }\n};\n// Get next page of products\nconst getNextProductsPage = async function(lastVisible) {\n    let pageSize = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 20;\n    try {\n        const productsQuery = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.query)(productsCollection, (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.orderBy)(\"createdAt\", \"desc\"), (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.startAfter)(lastVisible), (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.limit)(pageSize));\n        const snapshot = await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.getDocs)(productsQuery);\n        const products = snapshot.docs.map((doc)=>({\n                id: doc.id,\n                ...doc.data()\n            }));\n        // Update cache for these products\n        products.forEach((product)=>{\n            productCache.byId[product.id] = product;\n            if (product.category) {\n                if (!productCache.byCategory[product.category]) {\n                    productCache.byCategory[product.category] = [];\n                }\n                // Check if product already exists in category cache\n                const existingIndex = productCache.byCategory[product.category].findIndex((p)=>p.id === product.id);\n                if (existingIndex >= 0) {\n                    productCache.byCategory[product.category][existingIndex] = product;\n                } else {\n                    productCache.byCategory[product.category].push(product);\n                }\n            }\n        });\n        return products;\n    } catch (error) {\n        console.error(\"Error getting next page of products:\", error);\n        throw new Error(\"Failed to fetch more products\");\n    }\n};\n// Get products by category with caching\nconst getProductsByCategory = async (category)=>{\n    try {\n        // Check if we have this category in cache and it's still valid\n        if (isCacheValid() && productCache.byCategory[category] && productCache.byCategory[category].length > 0) {\n            console.log(\"Returning \".concat(category, \" products from cache\"));\n            return productCache.byCategory[category];\n        }\n        console.log(\"Fetching \".concat(category, \" products from Firestore\"));\n        const q = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.query)(productsCollection, (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.where)(\"category\", \"==\", category));\n        const snapshot = await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.getDocs)(q);\n        const products = snapshot.docs.map((doc)=>({\n                id: doc.id,\n                ...doc.data()\n            }));\n        // Update cache\n        productCache.byCategory[category] = products;\n        // Also update byId cache\n        products.forEach((product)=>{\n            productCache.byId[product.id] = product;\n        });\n        return products;\n    } catch (error) {\n        console.error(\"Error getting \".concat(category, \" products:\"), error);\n        throw new Error(\"Failed to fetch \".concat(category, \" products\"));\n    }\n};\n// Get featured products with caching\nconst getFeaturedProducts = async function() {\n    let limitCount = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 8;\n    try {\n        // If we have all products cached, filter them\n        if (isCacheValid() && productCache.all) {\n            const featured = productCache.all.filter((p)=>p.featured).slice(0, limitCount);\n            if (featured.length > 0) {\n                console.log(\"Returning featured products from cache\");\n                return featured;\n            }\n        }\n        console.log(\"Fetching featured products from Firestore\");\n        const q = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.query)(productsCollection, (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.where)(\"featured\", \"==\", true), (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.orderBy)(\"createdAt\", \"desc\"), (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.limit)(limitCount));\n        const snapshot = await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.getDocs)(q);\n        const products = snapshot.docs.map((doc)=>({\n                id: doc.id,\n                ...doc.data()\n            }));\n        // Update byId cache\n        products.forEach((product)=>{\n            productCache.byId[product.id] = product;\n            // Update category cache if needed\n            if (product.category) {\n                if (!productCache.byCategory[product.category]) {\n                    productCache.byCategory[product.category] = [];\n                }\n                // Check if product already exists in category cache\n                const existingIndex = productCache.byCategory[product.category].findIndex((p)=>p.id === product.id);\n                if (existingIndex >= 0) {\n                    productCache.byCategory[product.category][existingIndex] = product;\n                } else {\n                    productCache.byCategory[product.category].push(product);\n                }\n            }\n        });\n        return products;\n    } catch (error) {\n        console.error(\"Error getting featured products:\", error);\n        throw new Error(\"Failed to fetch featured products\");\n    }\n};\n// Get new arrivals with caching\nconst getNewArrivals = async function() {\n    let limitCount = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 8;\n    try {\n        // If we have all products cached, filter them\n        if (isCacheValid() && productCache.all) {\n            const newArrivals = productCache.all.filter((p)=>p.new).slice(0, limitCount);\n            if (newArrivals.length > 0) {\n                console.log(\"Returning new arrivals from cache\");\n                return newArrivals;\n            }\n        }\n        console.log(\"Fetching new arrivals from Firestore\");\n        const q = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.query)(productsCollection, (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.where)(\"new\", \"==\", true), (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.orderBy)(\"createdAt\", \"desc\"), (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.limit)(limitCount));\n        const snapshot = await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.getDocs)(q);\n        const products = snapshot.docs.map((doc)=>({\n                id: doc.id,\n                ...doc.data()\n            }));\n        // Update byId cache\n        products.forEach((product)=>{\n            productCache.byId[product.id] = product;\n            // Update category cache if needed\n            if (product.category) {\n                if (!productCache.byCategory[product.category]) {\n                    productCache.byCategory[product.category] = [];\n                }\n                // Check if product already exists in category cache\n                const existingIndex = productCache.byCategory[product.category].findIndex((p)=>p.id === product.id);\n                if (existingIndex >= 0) {\n                    productCache.byCategory[product.category][existingIndex] = product;\n                } else {\n                    productCache.byCategory[product.category].push(product);\n                }\n            }\n        });\n        return products;\n    } catch (error) {\n        console.error(\"Error getting new arrivals:\", error);\n        throw new Error(\"Failed to fetch new arrivals\");\n    }\n};\n// Get product by ID with caching\nconst getProductById = async (id)=>{\n    try {\n        // Check if product is in cache\n        if (productCache.byId[id]) {\n            console.log(\"Returning product \".concat(id, \" from cache\"));\n            return productCache.byId[id];\n        }\n        console.log(\"Fetching product \".concat(id, \" from Firestore\"));\n        const productDoc = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.doc)(db, \"products\", id);\n        const snapshot = await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.getDoc)(productDoc);\n        if (snapshot.exists()) {\n            const product = {\n                id: snapshot.id,\n                ...snapshot.data()\n            };\n            // Update cache\n            productCache.byId[id] = product;\n            return product;\n        }\n        return null;\n    } catch (error) {\n        console.error(\"Error getting product:\", error);\n        throw new Error(\"Failed to fetch product details\");\n    }\n};\n// Clear cache for a specific product\nconst invalidateProductCache = (productId, categoryId)=>{\n    // Remove from byId cache\n    if (productCache.byId[productId]) {\n        delete productCache.byId[productId];\n    }\n    // Remove from category cache if category is provided\n    if (categoryId && productCache.byCategory[categoryId]) {\n        productCache.byCategory[categoryId] = productCache.byCategory[categoryId].filter((p)=>p.id !== productId);\n    }\n    // Set all cache to null to force refresh on next fetch\n    productCache.all = null;\n};\n// Clear entire cache\nconst clearProductCache = ()=>{\n    productCache.all = null;\n    productCache.byId = {};\n    productCache.byCategory = {};\n    productCache.lastFetched = 0;\n};\n// Upload image to Firebase Storage\nconst uploadProductImage = async (file)=>{\n    try {\n        // Create a unique filename\n        const timestamp = new Date().getTime();\n        const fileName = \"product_\".concat(timestamp, \"_\").concat(file.name.replace(/[^a-zA-Z0-9.]/g, \"_\"));\n        // Create a reference to the file in storage\n        const storageRef = (0,firebase_storage__WEBPACK_IMPORTED_MODULE_2__.ref)(storage, \"product_images/\".concat(fileName));\n        // Upload the file\n        await (0,firebase_storage__WEBPACK_IMPORTED_MODULE_2__.uploadBytes)(storageRef, file);\n        // Get the download URL\n        const downloadURL = await (0,firebase_storage__WEBPACK_IMPORTED_MODULE_2__.getDownloadURL)(storageRef);\n        return downloadURL;\n    } catch (error) {\n        console.error(\"Error uploading image:\", error);\n        throw new Error(\"Failed to upload product image\");\n    }\n};\n// Delete product image from Firebase Storage\nconst deleteProductImage = async (imageUrl)=>{\n    try {\n        // Extract the file path from the URL\n        const decodedUrl = decodeURIComponent(imageUrl);\n        const startIndex = decodedUrl.indexOf(\"product_images\");\n        if (startIndex === -1) {\n            console.warn(\"Not a Firebase Storage URL or not in product_images folder:\", imageUrl);\n            return;\n        }\n        const endIndex = decodedUrl.indexOf(\"?\", startIndex);\n        const filePath = endIndex !== -1 ? decodedUrl.substring(startIndex, endIndex) : decodedUrl.substring(startIndex);\n        // Create a reference to the file\n        const imageRef = (0,firebase_storage__WEBPACK_IMPORTED_MODULE_2__.ref)(storage, filePath);\n        // Delete the file\n        await (0,firebase_storage__WEBPACK_IMPORTED_MODULE_2__.deleteObject)(imageRef);\n        console.log(\"Product image deleted successfully:\", filePath);\n    } catch (error) {\n        console.error(\"Error deleting product image:\", error);\n    // Don't throw error here, as we want to continue with product deletion\n    // even if image deletion fails\n    }\n};\n// Add a new product with transaction for category tracking\nconst addProduct = async (product)=>{\n    try {\n        console.log(\"Adding product to Firestore:\", product);\n        // Validate product data\n        const validationError = validateProduct(product);\n        if (validationError) {\n            throw new Error(validationError);\n        }\n        // Clean the product data for Firestore\n        const cleanedProduct = cleanProductData(product);\n        console.log(\"Cleaned product data for Firestore:\", cleanedProduct);\n        // Use transaction to add product and update category data\n        const newProduct = await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.runTransaction)(db, async (transaction)=>{\n            // Add the product document\n            const docRef = await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.addDoc)(productsCollection, cleanedProduct);\n            const newProductWithId = {\n                id: docRef.id,\n                ...cleanedProduct\n            };\n            // Update or create category count\n            const categoryRef = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.doc)(categoriesCollection, cleanedProduct.category);\n            const categoryDoc = await transaction.get(categoryRef);\n            if (categoryDoc.exists()) {\n                // Update existing category\n                transaction.update(categoryRef, {\n                    count: (categoryDoc.data().count || 0) + 1,\n                    updatedAt: (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.serverTimestamp)()\n                });\n            } else {\n                // Create new category\n                transaction.set(categoryRef, {\n                    id: cleanedProduct.category,\n                    name: cleanedProduct.category.charAt(0).toUpperCase() + cleanedProduct.category.slice(1),\n                    count: 1,\n                    createdAt: (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.serverTimestamp)(),\n                    updatedAt: (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.serverTimestamp)()\n                });\n            }\n            return newProductWithId;\n        });\n        // Update cache with the new product\n        if (productCache.all) {\n            productCache.all.unshift(newProduct);\n        }\n        productCache.byId[newProduct.id] = newProduct;\n        if (newProduct.category) {\n            if (!productCache.byCategory[newProduct.category]) {\n                productCache.byCategory[newProduct.category] = [];\n            }\n            productCache.byCategory[newProduct.category].unshift(newProduct);\n        }\n        console.log(\"Product added successfully with ID:\", newProduct.id);\n        return newProduct;\n    } catch (error) {\n        console.error(\"Error adding product to Firestore:\", error);\n        throw error;\n    }\n};\n// Update a product\nconst updateProduct = async (id, product)=>{\n    try {\n        const productDoc = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.doc)(db, \"products\", id);\n        // Get existing product to check if category is changing\n        const existingProductSnap = await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.getDoc)(productDoc);\n        if (!existingProductSnap.exists()) {\n            throw new Error(\"Product not found\");\n        }\n        const existingProduct = existingProductSnap.data();\n        const cleanedUpdates = cleanProductData(product);\n        // Always update the timestamp when modified\n        cleanedUpdates.updatedAt = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.serverTimestamp)();\n        await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.runTransaction)(db, async (transaction)=>{\n            // Update product document\n            transaction.update(productDoc, cleanedUpdates);\n            // If category changed, update both old and new category counts\n            if (product.category && existingProduct.category !== product.category) {\n                // Decrease old category count\n                const oldCategoryRef = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.doc)(categoriesCollection, existingProduct.category);\n                const oldCategoryDoc = await transaction.get(oldCategoryRef);\n                if (oldCategoryDoc.exists()) {\n                    const oldCount = oldCategoryDoc.data().count || 0;\n                    if (oldCount > 1) {\n                        transaction.update(oldCategoryRef, {\n                            count: oldCount - 1,\n                            updatedAt: (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.serverTimestamp)()\n                        });\n                    } else {\n                        // Delete category if it will be empty\n                        transaction.delete(oldCategoryRef);\n                    }\n                }\n                // Increase new category count\n                const newCategoryRef = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.doc)(categoriesCollection, product.category);\n                const newCategoryDoc = await transaction.get(newCategoryRef);\n                if (newCategoryDoc.exists()) {\n                    transaction.update(newCategoryRef, {\n                        count: (newCategoryDoc.data().count || 0) + 1,\n                        updatedAt: (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.serverTimestamp)()\n                    });\n                } else {\n                    transaction.set(newCategoryRef, {\n                        id: product.category,\n                        name: product.category.charAt(0).toUpperCase() + product.category.slice(1),\n                        count: 1,\n                        createdAt: (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.serverTimestamp)(),\n                        updatedAt: (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.serverTimestamp)()\n                    });\n                }\n            }\n        });\n        // Update cache\n        if (productCache.byId[id]) {\n            const updatedProduct = {\n                ...productCache.byId[id],\n                ...product\n            };\n            productCache.byId[id] = updatedProduct;\n            // Update in all products cache if it exists\n            if (productCache.all) {\n                const index = productCache.all.findIndex((p)=>p.id === id);\n                if (index >= 0) {\n                    productCache.all[index] = updatedProduct;\n                }\n            }\n            // Handle category change in cache\n            if (product.category && existingProduct.category !== product.category) {\n                // Remove from old category cache\n                if (productCache.byCategory[existingProduct.category]) {\n                    productCache.byCategory[existingProduct.category] = productCache.byCategory[existingProduct.category].filter((p)=>p.id !== id);\n                }\n                // Add to new category cache\n                if (!productCache.byCategory[product.category]) {\n                    productCache.byCategory[product.category] = [];\n                }\n                productCache.byCategory[product.category].push(updatedProduct);\n            } else if (product.category) {\n                // Update in same category\n                if (productCache.byCategory[product.category]) {\n                    const catIndex = productCache.byCategory[product.category].findIndex((p)=>p.id === id);\n                    if (catIndex >= 0) {\n                        productCache.byCategory[product.category][catIndex] = updatedProduct;\n                    }\n                }\n            }\n        } else {\n            // If not in cache, invalidate all cache to force refresh\n            clearProductCache();\n        }\n    } catch (error) {\n        console.error(\"Error updating product:\", error);\n        throw new Error(\"Failed to update product\");\n    }\n};\n// Delete a product\nconst deleteProduct = async (id)=>{\n    try {\n        const productDoc = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.doc)(db, \"products\", id);\n        // Get product to find its category and image URL\n        const productSnap = await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.getDoc)(productDoc);\n        if (!productSnap.exists()) {\n            throw new Error(\"Product not found\");\n        }\n        const productData = productSnap.data();\n        // Try to delete the product image first\n        if (productData.image) {\n            try {\n                await deleteProductImage(productData.image);\n            } catch (error) {\n                console.error(\"Error deleting product image:\", error);\n            // Continue with product deletion even if image deletion fails\n            }\n        }\n        await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.runTransaction)(db, async (transaction)=>{\n            // Delete product\n            transaction.delete(productDoc);\n            // Update category count\n            if (productData.category) {\n                const categoryRef = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.doc)(categoriesCollection, productData.category);\n                const categoryDoc = await transaction.get(categoryRef);\n                if (categoryDoc.exists()) {\n                    const count = categoryDoc.data().count || 0;\n                    if (count > 1) {\n                        transaction.update(categoryRef, {\n                            count: count - 1,\n                            updatedAt: (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.serverTimestamp)()\n                        });\n                    } else {\n                        // Delete category if it will be empty\n                        transaction.delete(categoryRef);\n                    }\n                }\n            }\n        });\n        // Update cache\n        invalidateProductCache(id, productData.category);\n    } catch (error) {\n        console.error(\"Error deleting product:\", error);\n        throw new Error(\"Failed to delete product\");\n    }\n};\n// Get all categories with product counts\nconst getAllCategories = async ()=>{\n    try {\n        const snapshot = await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.getDocs)(categoriesCollection);\n        return snapshot.docs.map((doc)=>doc.data());\n    } catch (error) {\n        console.error(\"Error getting categories:\", error);\n        throw new Error(\"Failed to fetch categories\");\n    }\n};\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QnNILFlBQVl6RyxRQUFRO2dCQUNsRSxNQUFNa0YsY0FBYyxNQUFNSixZQUFZSyxHQUFHLENBQUNGO2dCQUUxQyxJQUFJQyxZQUFZL0IsTUFBTSxJQUFJO29CQUN4QixNQUFNa0MsUUFBUUgsWUFBWXBELElBQUksR0FBR3VELEtBQUssSUFBSTtvQkFDMUMsSUFBSUEsUUFBUSxHQUFHO3dCQUNiUCxZQUFZTSxNQUFNLENBQUNILGFBQWE7NEJBQzlCSSxPQUFPQSxRQUFROzRCQUNmcEUsV0FBVzFDLG1FQUFlQTt3QkFDNUI7b0JBQ0YsT0FBTzt3QkFDTCxzQ0FBc0M7d0JBQ3RDdUcsWUFBWW1CLE1BQU0sQ0FBQ2hCO29CQUNyQjtnQkFDRjtZQUNGO1FBQ0Y7UUFFQSxlQUFlO1FBQ2Y3Qix1QkFBdUJ2QixJQUFJNEUsWUFBWXpHLFFBQVE7SUFFakQsRUFBRSxPQUFPaUMsT0FBTztRQUNkVixRQUFRVSxLQUFLLENBQUMsMkJBQTJCQTtRQUN6QyxNQUFNLElBQUlDLE1BQU07SUFDbEI7QUFDRixFQUFFO0FBRUYseUNBQXlDO0FBQ2xDLE1BQU13RSxtQkFBbUI7SUFDOUIsSUFBSTtRQUNGLE1BQU1oRixXQUFXLE1BQU0xRCwyREFBT0EsQ0FBQ21CO1FBQy9CLE9BQU91QyxTQUFTRSxJQUFJLENBQUNqQixHQUFHLENBQUMxQyxDQUFBQSxNQUFPQSxJQUFJNkQsSUFBSTtJQUMxQyxFQUFFLE9BQU9HLE9BQU87UUFDZFYsUUFBUVUsS0FBSyxDQUFDLDZCQUE2QkE7UUFDM0MsTUFBTSxJQUFJQyxNQUFNO0lBQ2xCO0FBQ0YsRUFBRSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi91dGlscy9maXJlc3RvcmUudHM/YWEwMCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBhcHAgfSBmcm9tICcuL2ZpcmViYXNlJztcclxuaW1wb3J0IHsgZ2V0RmlyZXN0b3JlLCBjb2xsZWN0aW9uLCBnZXREb2NzLCBkb2MsIGdldERvYywgYWRkRG9jLCB1cGRhdGVEb2MsIGRlbGV0ZURvYywgcXVlcnksIHdoZXJlLCBydW5UcmFuc2FjdGlvbiwgc2VydmVyVGltZXN0YW1wLCBEb2N1bWVudFJlZmVyZW5jZSwgbGltaXQsIG9yZGVyQnksIHN0YXJ0QWZ0ZXIsIFF1ZXJ5RG9jdW1lbnRTbmFwc2hvdCwgUXVlcnlTbmFwc2hvdCB9IGZyb20gJ2ZpcmViYXNlL2ZpcmVzdG9yZSc7XHJcbmltcG9ydCB7IGdldFN0b3JhZ2UsIHJlZiwgdXBsb2FkQnl0ZXMsIGdldERvd25sb2FkVVJMLCBkZWxldGVPYmplY3QgfSBmcm9tICdmaXJlYmFzZS9zdG9yYWdlJztcclxuaW1wb3J0IHsgUHJvZHVjdCB9IGZyb20gJy4uL2RhdGEvcHJvZHVjdHMnO1xyXG5cclxuLy8gSW5pdGlhbGl6ZSBGaXJlc3RvcmVcclxuZXhwb3J0IGNvbnN0IGRiID0gZ2V0RmlyZXN0b3JlKGFwcCk7XHJcblxyXG4vLyBJbml0aWFsaXplIFN0b3JhZ2VcclxuZXhwb3J0IGNvbnN0IHN0b3JhZ2UgPSBnZXRTdG9yYWdlKGFwcCk7XHJcblxyXG4vLyBDb2xsZWN0aW9uIHJlZmVyZW5jZXNcclxuY29uc3QgcHJvZHVjdHNDb2xsZWN0aW9uID0gY29sbGVjdGlvbihkYiwgJ3Byb2R1Y3RzJyk7XHJcbmNvbnN0IGNhdGVnb3JpZXNDb2xsZWN0aW9uID0gY29sbGVjdGlvbihkYiwgJ2NhdGVnb3JpZXMnKTtcclxuXHJcbi8vIENhY2hlIGZvciBwcm9kdWN0c1xyXG5jb25zdCBwcm9kdWN0Q2FjaGU6IHtcclxuICBhbGw6IFByb2R1Y3RbXSB8IG51bGw7XHJcbiAgYnlJZDogUmVjb3JkPHN0cmluZywgUHJvZHVjdD47XHJcbiAgYnlDYXRlZ29yeTogUmVjb3JkPHN0cmluZywgUHJvZHVjdFtdPjtcclxuICBsYXN0RmV0Y2hlZDogbnVtYmVyO1xyXG59ID0ge1xyXG4gIGFsbDogbnVsbCxcclxuICBieUlkOiB7fSxcclxuICBieUNhdGVnb3J5OiB7fSxcclxuICBsYXN0RmV0Y2hlZDogMFxyXG59O1xyXG5cclxuLy8gQ2FjaGUgZXhwaXJhdGlvbiB0aW1lICg1IG1pbnV0ZXMpXHJcbmNvbnN0IENBQ0hFX0VYUElSQVRJT04gPSA1ICogNjAgKiAxMDAwO1xyXG5cclxuLy8gVmFsaWRhdGUgcHJvZHVjdCBkYXRhIGJlZm9yZSBzYXZpbmdcclxuY29uc3QgdmFsaWRhdGVQcm9kdWN0ID0gKHByb2R1Y3Q6IFBhcnRpYWw8UHJvZHVjdD4pOiBzdHJpbmcgfCBudWxsID0+IHtcclxuICBpZiAoIXByb2R1Y3QubmFtZSB8fCB0eXBlb2YgcHJvZHVjdC5uYW1lICE9PSAnc3RyaW5nJykge1xyXG4gICAgcmV0dXJuICdQcm9kdWN0IG5hbWUgaXMgcmVxdWlyZWQnO1xyXG4gIH1cclxuICBcclxuICBpZiAoIXByb2R1Y3QucHJpY2UgfHwgaXNOYU4oTnVtYmVyKHByb2R1Y3QucHJpY2UpKSkge1xyXG4gICAgcmV0dXJuICdWYWxpZCBwcm9kdWN0IHByaWNlIGlzIHJlcXVpcmVkJztcclxuICB9XHJcbiAgXHJcbiAgaWYgKCFwcm9kdWN0LmNhdGVnb3J5IHx8IHR5cGVvZiBwcm9kdWN0LmNhdGVnb3J5ICE9PSAnc3RyaW5nJykge1xyXG4gICAgcmV0dXJuICdQcm9kdWN0IGNhdGVnb3J5IGlzIHJlcXVpcmVkJztcclxuICB9XHJcbiAgXHJcbiAgaWYgKCFwcm9kdWN0LmltYWdlIHx8IHR5cGVvZiBwcm9kdWN0LmltYWdlICE9PSAnc3RyaW5nJykge1xyXG4gICAgcmV0dXJuICdQcm9kdWN0IGltYWdlIGlzIHJlcXVpcmVkJztcclxuICB9XHJcbiAgXHJcbiAgcmV0dXJuIG51bGw7IC8vIE5vIGVycm9yc1xyXG59O1xyXG5cclxuLy8gQ2xlYW4gcHJvZHVjdCBkYXRhIGZvciBGaXJlc3RvcmVcclxuY29uc3QgY2xlYW5Qcm9kdWN0RGF0YSA9IChwcm9kdWN0OiBSZWNvcmQ8c3RyaW5nLCBhbnk+KTogUmVjb3JkPHN0cmluZywgYW55PiA9PiB7XHJcbiAgY29uc3QgY2xlYW5lZFByb2R1Y3Q6IFJlY29yZDxzdHJpbmcsIGFueT4gPSB7fTtcclxuICBcclxuICBPYmplY3QuZW50cmllcyhwcm9kdWN0KS5mb3JFYWNoKChba2V5LCB2YWx1ZV0pID0+IHtcclxuICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkICYmIHZhbHVlICE9PSBudWxsKSB7XHJcbiAgICAgIC8vIEhhbmRsZSBzcGVjaWZpYyBmaWVsZCB0eXBlc1xyXG4gICAgICBpZiAoa2V5ID09PSAncHJpY2UnIHx8IGtleSA9PT0gJ29yaWdpbmFsUHJpY2UnIHx8IGtleSA9PT0gJ3N0b2NrJykge1xyXG4gICAgICAgIGNsZWFuZWRQcm9kdWN0W2tleV0gPSBOdW1iZXIodmFsdWUpO1xyXG4gICAgICB9IGVsc2UgaWYgKGtleSA9PT0gJ3NpemVzJyAmJiB0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgY2xlYW5lZFByb2R1Y3Rba2V5XSA9IHZhbHVlLnNwbGl0KCcsJykubWFwKChzOiBzdHJpbmcpID0+IHMudHJpbSgpKS5maWx0ZXIoQm9vbGVhbik7XHJcbiAgICAgIH0gZWxzZSBpZiAoa2V5ID09PSAnZmVhdHVyZWQnICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcclxuICAgICAgICBjbGVhbmVkUHJvZHVjdFtrZXldID0gdmFsdWUgPT09ICd0cnVlJztcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBjbGVhbmVkUHJvZHVjdFtrZXldID0gdmFsdWU7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9KTtcclxuICBcclxuICAvLyBBZGQgdGltZXN0YW1wc1xyXG4gIGlmICghY2xlYW5lZFByb2R1Y3QuY3JlYXRlZEF0KSB7XHJcbiAgICBjbGVhbmVkUHJvZHVjdC5jcmVhdGVkQXQgPSBzZXJ2ZXJUaW1lc3RhbXAoKTtcclxuICB9XHJcbiAgY2xlYW5lZFByb2R1Y3QudXBkYXRlZEF0ID0gc2VydmVyVGltZXN0YW1wKCk7XHJcbiAgXHJcbiAgcmV0dXJuIGNsZWFuZWRQcm9kdWN0O1xyXG59O1xyXG5cclxuLy8gQ2hlY2sgaWYgY2FjaGUgaXMgdmFsaWRcclxuY29uc3QgaXNDYWNoZVZhbGlkID0gKCk6IGJvb2xlYW4gPT4ge1xyXG4gIHJldHVybiAoXHJcbiAgICBwcm9kdWN0Q2FjaGUuYWxsICE9PSBudWxsICYmXHJcbiAgICBEYXRlLm5vdygpIC0gcHJvZHVjdENhY2hlLmxhc3RGZXRjaGVkIDwgQ0FDSEVfRVhQSVJBVElPTlxyXG4gICk7XHJcbn07XHJcblxyXG4vLyBHZXQgYWxsIHByb2R1Y3RzIHdpdGggcGFnaW5hdGlvbiBhbmQgY2FjaGluZ1xyXG5leHBvcnQgY29uc3QgZ2V0QWxsUHJvZHVjdHMgPSBhc3luYyAocGFnZVNpemU6IG51bWJlciA9IDApOiBQcm9taXNlPFByb2R1Y3RbXT4gPT4ge1xyXG4gIHRyeSB7XHJcbiAgICAvLyBJZiBjYWNoZSBpcyB2YWxpZCBhbmQgd2UncmUgbm90IHBhZ2luYXRpbmcsIHJldHVybiBjYWNoZWQgcHJvZHVjdHNcclxuICAgIGlmIChpc0NhY2hlVmFsaWQoKSAmJiBwYWdlU2l6ZSA9PT0gMCAmJiBwcm9kdWN0Q2FjaGUuYWxsKSB7XHJcbiAgICAgIGNvbnNvbGUubG9nKCdSZXR1cm5pbmcgcHJvZHVjdHMgZnJvbSBjYWNoZScpO1xyXG4gICAgICByZXR1cm4gcHJvZHVjdENhY2hlLmFsbDtcclxuICAgIH1cclxuICAgIFxyXG4gICAgY29uc29sZS5sb2coJ0ZldGNoaW5nIHByb2R1Y3RzIGZyb20gRmlyZXN0b3JlJyk7XHJcbiAgICBcclxuICAgIGxldCBwcm9kdWN0c1F1ZXJ5ID0gcXVlcnkocHJvZHVjdHNDb2xsZWN0aW9uLCBvcmRlckJ5KCdjcmVhdGVkQXQnLCAnZGVzYycpKTtcclxuICAgIFxyXG4gICAgLy8gQXBwbHkgcGFnaW5hdGlvbiBpZiBwYWdlU2l6ZSBpcyBzcGVjaWZpZWRcclxuICAgIGlmIChwYWdlU2l6ZSA+IDApIHtcclxuICAgICAgcHJvZHVjdHNRdWVyeSA9IHF1ZXJ5KHByb2R1Y3RzUXVlcnksIGxpbWl0KHBhZ2VTaXplKSk7XHJcbiAgICB9XHJcbiAgICBcclxuICAgIGNvbnN0IHNuYXBzaG90ID0gYXdhaXQgZ2V0RG9jcyhwcm9kdWN0c1F1ZXJ5KTtcclxuICAgIGNvbnN0IHByb2R1Y3RzID0gc25hcHNob3QuZG9jcy5tYXAoZG9jID0+ICh7XHJcbiAgICAgIGlkOiBkb2MuaWQsXHJcbiAgICAgIC4uLmRvYy5kYXRhKClcclxuICAgIH0gYXMgUHJvZHVjdCkpO1xyXG4gICAgXHJcbiAgICAvLyBVcGRhdGUgY2FjaGUgaWYgd2UncmUgZ2V0dGluZyBhbGwgcHJvZHVjdHNcclxuICAgIGlmIChwYWdlU2l6ZSA9PT0gMCkge1xyXG4gICAgICBwcm9kdWN0Q2FjaGUuYWxsID0gcHJvZHVjdHM7XHJcbiAgICAgIFxyXG4gICAgICAvLyBVcGRhdGUgYnlJZCBhbmQgYnlDYXRlZ29yeSBjYWNoZXNcclxuICAgICAgcHJvZHVjdHMuZm9yRWFjaChwcm9kdWN0ID0+IHtcclxuICAgICAgICBwcm9kdWN0Q2FjaGUuYnlJZFtwcm9kdWN0LmlkXSA9IHByb2R1Y3Q7XHJcbiAgICAgICAgXHJcbiAgICAgICAgaWYgKHByb2R1Y3QuY2F0ZWdvcnkpIHtcclxuICAgICAgICAgIGlmICghcHJvZHVjdENhY2hlLmJ5Q2F0ZWdvcnlbcHJvZHVjdC5jYXRlZ29yeV0pIHtcclxuICAgICAgICAgICAgcHJvZHVjdENhY2hlLmJ5Q2F0ZWdvcnlbcHJvZHVjdC5jYXRlZ29yeV0gPSBbXTtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIHByb2R1Y3RDYWNoZS5ieUNhdGVnb3J5W3Byb2R1Y3QuY2F0ZWdvcnldLnB1c2gocHJvZHVjdCk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9KTtcclxuICAgICAgXHJcbiAgICAgIHByb2R1Y3RDYWNoZS5sYXN0RmV0Y2hlZCA9IERhdGUubm93KCk7XHJcbiAgICB9XHJcbiAgICBcclxuICAgIGNvbnNvbGUubG9nKGBSZXRyaWV2ZWQgJHtwcm9kdWN0cy5sZW5ndGh9IHByb2R1Y3RzIGZyb20gRmlyZXN0b3JlYCk7XHJcbiAgICByZXR1cm4gcHJvZHVjdHM7XHJcbiAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGdldHRpbmcgcHJvZHVjdHMgZnJvbSBGaXJlc3RvcmU6JywgZXJyb3IpO1xyXG4gICAgdGhyb3cgbmV3IEVycm9yKCdGYWlsZWQgdG8gZmV0Y2ggcHJvZHVjdHMnKTtcclxuICB9XHJcbn07XHJcblxyXG4vLyBHZXQgbmV4dCBwYWdlIG9mIHByb2R1Y3RzXHJcbmV4cG9ydCBjb25zdCBnZXROZXh0UHJvZHVjdHNQYWdlID0gYXN5bmMgKFxyXG4gIGxhc3RWaXNpYmxlOiBRdWVyeURvY3VtZW50U25hcHNob3QsXHJcbiAgcGFnZVNpemU6IG51bWJlciA9IDIwXHJcbik6IFByb21pc2U8UHJvZHVjdFtdPiA9PiB7XHJcbiAgdHJ5IHtcclxuICAgIGNvbnN0IHByb2R1Y3RzUXVlcnkgPSBxdWVyeShcclxuICAgICAgcHJvZHVjdHNDb2xsZWN0aW9uLFxyXG4gICAgICBvcmRlckJ5KCdjcmVhdGVkQXQnLCAnZGVzYycpLFxyXG4gICAgICBzdGFydEFmdGVyKGxhc3RWaXNpYmxlKSxcclxuICAgICAgbGltaXQocGFnZVNpemUpXHJcbiAgICApO1xyXG4gICAgXHJcbiAgICBjb25zdCBzbmFwc2hvdCA9IGF3YWl0IGdldERvY3MocHJvZHVjdHNRdWVyeSk7XHJcbiAgICBjb25zdCBwcm9kdWN0cyA9IHNuYXBzaG90LmRvY3MubWFwKGRvYyA9PiAoe1xyXG4gICAgICBpZDogZG9jLmlkLFxyXG4gICAgICAuLi5kb2MuZGF0YSgpXHJcbiAgICB9IGFzIFByb2R1Y3QpKTtcclxuICAgIFxyXG4gICAgLy8gVXBkYXRlIGNhY2hlIGZvciB0aGVzZSBwcm9kdWN0c1xyXG4gICAgcHJvZHVjdHMuZm9yRWFjaChwcm9kdWN0ID0+IHtcclxuICAgICAgcHJvZHVjdENhY2hlLmJ5SWRbcHJvZHVjdC5pZF0gPSBwcm9kdWN0O1xyXG4gICAgICBcclxuICAgICAgaWYgKHByb2R1Y3QuY2F0ZWdvcnkpIHtcclxuICAgICAgICBpZiAoIXByb2R1Y3RDYWNoZS5ieUNhdGVnb3J5W3Byb2R1Y3QuY2F0ZWdvcnldKSB7XHJcbiAgICAgICAgICBwcm9kdWN0Q2FjaGUuYnlDYXRlZ29yeVtwcm9kdWN0LmNhdGVnb3J5XSA9IFtdO1xyXG4gICAgICAgIH1cclxuICAgICAgICBcclxuICAgICAgICAvLyBDaGVjayBpZiBwcm9kdWN0IGFscmVhZHkgZXhpc3RzIGluIGNhdGVnb3J5IGNhY2hlXHJcbiAgICAgICAgY29uc3QgZXhpc3RpbmdJbmRleCA9IHByb2R1Y3RDYWNoZS5ieUNhdGVnb3J5W3Byb2R1Y3QuY2F0ZWdvcnldLmZpbmRJbmRleChcclxuICAgICAgICAgIHAgPT4gcC5pZCA9PT0gcHJvZHVjdC5pZFxyXG4gICAgICAgICk7XHJcbiAgICAgICAgXHJcbiAgICAgICAgaWYgKGV4aXN0aW5nSW5kZXggPj0gMCkge1xyXG4gICAgICAgICAgcHJvZHVjdENhY2hlLmJ5Q2F0ZWdvcnlbcHJvZHVjdC5jYXRlZ29yeV1bZXhpc3RpbmdJbmRleF0gPSBwcm9kdWN0O1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBwcm9kdWN0Q2FjaGUuYnlDYXRlZ29yeVtwcm9kdWN0LmNhdGVnb3J5XS5wdXNoKHByb2R1Y3QpO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfSk7XHJcbiAgICBcclxuICAgIHJldHVybiBwcm9kdWN0cztcclxuICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgY29uc29sZS5lcnJvcignRXJyb3IgZ2V0dGluZyBuZXh0IHBhZ2Ugb2YgcHJvZHVjdHM6JywgZXJyb3IpO1xyXG4gICAgdGhyb3cgbmV3IEVycm9yKCdGYWlsZWQgdG8gZmV0Y2ggbW9yZSBwcm9kdWN0cycpO1xyXG4gIH1cclxufTtcclxuXHJcbi8vIEdldCBwcm9kdWN0cyBieSBjYXRlZ29yeSB3aXRoIGNhY2hpbmdcclxuZXhwb3J0IGNvbnN0IGdldFByb2R1Y3RzQnlDYXRlZ29yeSA9IGFzeW5jIChjYXRlZ29yeTogc3RyaW5nKTogUHJvbWlzZTxQcm9kdWN0W10+ID0+IHtcclxuICB0cnkge1xyXG4gICAgLy8gQ2hlY2sgaWYgd2UgaGF2ZSB0aGlzIGNhdGVnb3J5IGluIGNhY2hlIGFuZCBpdCdzIHN0aWxsIHZhbGlkXHJcbiAgICBpZiAoXHJcbiAgICAgIGlzQ2FjaGVWYWxpZCgpICYmXHJcbiAgICAgIHByb2R1Y3RDYWNoZS5ieUNhdGVnb3J5W2NhdGVnb3J5XSAmJlxyXG4gICAgICBwcm9kdWN0Q2FjaGUuYnlDYXRlZ29yeVtjYXRlZ29yeV0ubGVuZ3RoID4gMFxyXG4gICAgKSB7XHJcbiAgICAgIGNvbnNvbGUubG9nKGBSZXR1cm5pbmcgJHtjYXRlZ29yeX0gcHJvZHVjdHMgZnJvbSBjYWNoZWApO1xyXG4gICAgICByZXR1cm4gcHJvZHVjdENhY2hlLmJ5Q2F0ZWdvcnlbY2F0ZWdvcnldO1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICBjb25zb2xlLmxvZyhgRmV0Y2hpbmcgJHtjYXRlZ29yeX0gcHJvZHVjdHMgZnJvbSBGaXJlc3RvcmVgKTtcclxuICAgIGNvbnN0IHEgPSBxdWVyeShwcm9kdWN0c0NvbGxlY3Rpb24sIHdoZXJlKCdjYXRlZ29yeScsICc9PScsIGNhdGVnb3J5KSk7XHJcbiAgICBjb25zdCBzbmFwc2hvdCA9IGF3YWl0IGdldERvY3MocSk7XHJcbiAgICBjb25zdCBwcm9kdWN0cyA9IHNuYXBzaG90LmRvY3MubWFwKGRvYyA9PiAoe1xyXG4gICAgICBpZDogZG9jLmlkLFxyXG4gICAgICAuLi5kb2MuZGF0YSgpXHJcbiAgICB9IGFzIFByb2R1Y3QpKTtcclxuICAgIFxyXG4gICAgLy8gVXBkYXRlIGNhY2hlXHJcbiAgICBwcm9kdWN0Q2FjaGUuYnlDYXRlZ29yeVtjYXRlZ29yeV0gPSBwcm9kdWN0cztcclxuICAgIFxyXG4gICAgLy8gQWxzbyB1cGRhdGUgYnlJZCBjYWNoZVxyXG4gICAgcHJvZHVjdHMuZm9yRWFjaChwcm9kdWN0ID0+IHtcclxuICAgICAgcHJvZHVjdENhY2hlLmJ5SWRbcHJvZHVjdC5pZF0gPSBwcm9kdWN0O1xyXG4gICAgfSk7XHJcbiAgICBcclxuICAgIHJldHVybiBwcm9kdWN0cztcclxuICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgY29uc29sZS5lcnJvcihgRXJyb3IgZ2V0dGluZyAke2NhdGVnb3J5fSBwcm9kdWN0czpgLCBlcnJvcik7XHJcbiAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byBmZXRjaCAke2NhdGVnb3J5fSBwcm9kdWN0c2ApO1xyXG4gIH1cclxufTtcclxuXHJcbi8vIEdldCBmZWF0dXJlZCBwcm9kdWN0cyB3aXRoIGNhY2hpbmdcclxuZXhwb3J0IGNvbnN0IGdldEZlYXR1cmVkUHJvZHVjdHMgPSBhc3luYyAobGltaXRDb3VudDogbnVtYmVyID0gOCk6IFByb21pc2U8UHJvZHVjdFtdPiA9PiB7XHJcbiAgdHJ5IHtcclxuICAgIC8vIElmIHdlIGhhdmUgYWxsIHByb2R1Y3RzIGNhY2hlZCwgZmlsdGVyIHRoZW1cclxuICAgIGlmIChpc0NhY2hlVmFsaWQoKSAmJiBwcm9kdWN0Q2FjaGUuYWxsKSB7XHJcbiAgICAgIGNvbnN0IGZlYXR1cmVkID0gcHJvZHVjdENhY2hlLmFsbC5maWx0ZXIocCA9PiBwLmZlYXR1cmVkKS5zbGljZSgwLCBsaW1pdENvdW50KTtcclxuICAgICAgaWYgKGZlYXR1cmVkLmxlbmd0aCA+IDApIHtcclxuICAgICAgICBjb25zb2xlLmxvZygnUmV0dXJuaW5nIGZlYXR1cmVkIHByb2R1Y3RzIGZyb20gY2FjaGUnKTtcclxuICAgICAgICByZXR1cm4gZmVhdHVyZWQ7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIFxyXG4gICAgY29uc29sZS5sb2coJ0ZldGNoaW5nIGZlYXR1cmVkIHByb2R1Y3RzIGZyb20gRmlyZXN0b3JlJyk7XHJcbiAgICBjb25zdCBxID0gcXVlcnkoXHJcbiAgICAgIHByb2R1Y3RzQ29sbGVjdGlvbixcclxuICAgICAgd2hlcmUoJ2ZlYXR1cmVkJywgJz09JywgdHJ1ZSksXHJcbiAgICAgIG9yZGVyQnkoJ2NyZWF0ZWRBdCcsICdkZXNjJyksXHJcbiAgICAgIGxpbWl0KGxpbWl0Q291bnQpXHJcbiAgICApO1xyXG4gICAgXHJcbiAgICBjb25zdCBzbmFwc2hvdCA9IGF3YWl0IGdldERvY3MocSk7XHJcbiAgICBjb25zdCBwcm9kdWN0cyA9IHNuYXBzaG90LmRvY3MubWFwKGRvYyA9PiAoe1xyXG4gICAgICBpZDogZG9jLmlkLFxyXG4gICAgICAuLi5kb2MuZGF0YSgpXHJcbiAgICB9IGFzIFByb2R1Y3QpKTtcclxuICAgIFxyXG4gICAgLy8gVXBkYXRlIGJ5SWQgY2FjaGVcclxuICAgIHByb2R1Y3RzLmZvckVhY2gocHJvZHVjdCA9PiB7XHJcbiAgICAgIHByb2R1Y3RDYWNoZS5ieUlkW3Byb2R1Y3QuaWRdID0gcHJvZHVjdDtcclxuICAgICAgXHJcbiAgICAgIC8vIFVwZGF0ZSBjYXRlZ29yeSBjYWNoZSBpZiBuZWVkZWRcclxuICAgICAgaWYgKHByb2R1Y3QuY2F0ZWdvcnkpIHtcclxuICAgICAgICBpZiAoIXByb2R1Y3RDYWNoZS5ieUNhdGVnb3J5W3Byb2R1Y3QuY2F0ZWdvcnldKSB7XHJcbiAgICAgICAgICBwcm9kdWN0Q2FjaGUuYnlDYXRlZ29yeVtwcm9kdWN0LmNhdGVnb3J5XSA9IFtdO1xyXG4gICAgICAgIH1cclxuICAgICAgICBcclxuICAgICAgICAvLyBDaGVjayBpZiBwcm9kdWN0IGFscmVhZHkgZXhpc3RzIGluIGNhdGVnb3J5IGNhY2hlXHJcbiAgICAgICAgY29uc3QgZXhpc3RpbmdJbmRleCA9IHByb2R1Y3RDYWNoZS5ieUNhdGVnb3J5W3Byb2R1Y3QuY2F0ZWdvcnldLmZpbmRJbmRleChcclxuICAgICAgICAgIHAgPT4gcC5pZCA9PT0gcHJvZHVjdC5pZFxyXG4gICAgICAgICk7XHJcbiAgICAgICAgXHJcbiAgICAgICAgaWYgKGV4aXN0aW5nSW5kZXggPj0gMCkge1xyXG4gICAgICAgICAgcHJvZHVjdENhY2hlLmJ5Q2F0ZWdvcnlbcHJvZHVjdC5jYXRlZ29yeV1bZXhpc3RpbmdJbmRleF0gPSBwcm9kdWN0O1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBwcm9kdWN0Q2FjaGUuYnlDYXRlZ29yeVtwcm9kdWN0LmNhdGVnb3J5XS5wdXNoKHByb2R1Y3QpO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfSk7XHJcbiAgICBcclxuICAgIHJldHVybiBwcm9kdWN0cztcclxuICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgY29uc29sZS5lcnJvcignRXJyb3IgZ2V0dGluZyBmZWF0dXJlZCBwcm9kdWN0czonLCBlcnJvcik7XHJcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZhaWxlZCB0byBmZXRjaCBmZWF0dXJlZCBwcm9kdWN0cycpO1xyXG4gIH1cclxufTtcclxuXHJcbi8vIEdldCBuZXcgYXJyaXZhbHMgd2l0aCBjYWNoaW5nXHJcbmV4cG9ydCBjb25zdCBnZXROZXdBcnJpdmFscyA9IGFzeW5jIChsaW1pdENvdW50OiBudW1iZXIgPSA4KTogUHJvbWlzZTxQcm9kdWN0W10+ID0+IHtcclxuICB0cnkge1xyXG4gICAgLy8gSWYgd2UgaGF2ZSBhbGwgcHJvZHVjdHMgY2FjaGVkLCBmaWx0ZXIgdGhlbVxyXG4gICAgaWYgKGlzQ2FjaGVWYWxpZCgpICYmIHByb2R1Y3RDYWNoZS5hbGwpIHtcclxuICAgICAgY29uc3QgbmV3QXJyaXZhbHMgPSBwcm9kdWN0Q2FjaGUuYWxsXHJcbiAgICAgICAgLmZpbHRlcihwID0+IHAubmV3KVxyXG4gICAgICAgIC5zbGljZSgwLCBsaW1pdENvdW50KTtcclxuICAgICAgICBcclxuICAgICAgaWYgKG5ld0Fycml2YWxzLmxlbmd0aCA+IDApIHtcclxuICAgICAgICBjb25zb2xlLmxvZygnUmV0dXJuaW5nIG5ldyBhcnJpdmFscyBmcm9tIGNhY2hlJyk7XHJcbiAgICAgICAgcmV0dXJuIG5ld0Fycml2YWxzO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICBcclxuICAgIGNvbnNvbGUubG9nKCdGZXRjaGluZyBuZXcgYXJyaXZhbHMgZnJvbSBGaXJlc3RvcmUnKTtcclxuICAgIGNvbnN0IHEgPSBxdWVyeShcclxuICAgICAgcHJvZHVjdHNDb2xsZWN0aW9uLFxyXG4gICAgICB3aGVyZSgnbmV3JywgJz09JywgdHJ1ZSksXHJcbiAgICAgIG9yZGVyQnkoJ2NyZWF0ZWRBdCcsICdkZXNjJyksXHJcbiAgICAgIGxpbWl0KGxpbWl0Q291bnQpXHJcbiAgICApO1xyXG4gICAgXHJcbiAgICBjb25zdCBzbmFwc2hvdCA9IGF3YWl0IGdldERvY3MocSk7XHJcbiAgICBjb25zdCBwcm9kdWN0cyA9IHNuYXBzaG90LmRvY3MubWFwKGRvYyA9PiAoe1xyXG4gICAgICBpZDogZG9jLmlkLFxyXG4gICAgICAuLi5kb2MuZGF0YSgpXHJcbiAgICB9IGFzIFByb2R1Y3QpKTtcclxuICAgIFxyXG4gICAgLy8gVXBkYXRlIGJ5SWQgY2FjaGVcclxuICAgIHByb2R1Y3RzLmZvckVhY2gocHJvZHVjdCA9PiB7XHJcbiAgICAgIHByb2R1Y3RDYWNoZS5ieUlkW3Byb2R1Y3QuaWRdID0gcHJvZHVjdDtcclxuICAgICAgXHJcbiAgICAgIC8vIFVwZGF0ZSBjYXRlZ29yeSBjYWNoZSBpZiBuZWVkZWRcclxuICAgICAgaWYgKHByb2R1Y3QuY2F0ZWdvcnkpIHtcclxuICAgICAgICBpZiAoIXByb2R1Y3RDYWNoZS5ieUNhdGVnb3J5W3Byb2R1Y3QuY2F0ZWdvcnldKSB7XHJcbiAgICAgICAgICBwcm9kdWN0Q2FjaGUuYnlDYXRlZ29yeVtwcm9kdWN0LmNhdGVnb3J5XSA9IFtdO1xyXG4gICAgICAgIH1cclxuICAgICAgICBcclxuICAgICAgICAvLyBDaGVjayBpZiBwcm9kdWN0IGFscmVhZHkgZXhpc3RzIGluIGNhdGVnb3J5IGNhY2hlXHJcbiAgICAgICAgY29uc3QgZXhpc3RpbmdJbmRleCA9IHByb2R1Y3RDYWNoZS5ieUNhdGVnb3J5W3Byb2R1Y3QuY2F0ZWdvcnldLmZpbmRJbmRleChcclxuICAgICAgICAgIHAgPT4gcC5pZCA9PT0gcHJvZHVjdC5pZFxyXG4gICAgICAgICk7XHJcbiAgICAgICAgXHJcbiAgICAgICAgaWYgKGV4aXN0aW5nSW5kZXggPj0gMCkge1xyXG4gICAgICAgICAgcHJvZHVjdENhY2hlLmJ5Q2F0ZWdvcnlbcHJvZHVjdC5jYXRlZ29yeV1bZXhpc3RpbmdJbmRleF0gPSBwcm9kdWN0O1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBwcm9kdWN0Q2FjaGUuYnlDYXRlZ29yeVtwcm9kdWN0LmNhdGVnb3J5XS5wdXNoKHByb2R1Y3QpO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfSk7XHJcbiAgICBcclxuICAgIHJldHVybiBwcm9kdWN0cztcclxuICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgY29uc29sZS5lcnJvcignRXJyb3IgZ2V0dGluZyBuZXcgYXJyaXZhbHM6JywgZXJyb3IpO1xyXG4gICAgdGhyb3cgbmV3IEVycm9yKCdGYWlsZWQgdG8gZmV0Y2ggbmV3IGFycml2YWxzJyk7XHJcbiAgfVxyXG59O1xyXG5cclxuLy8gR2V0IHByb2R1Y3QgYnkgSUQgd2l0aCBjYWNoaW5nXHJcbmV4cG9ydCBjb25zdCBnZXRQcm9kdWN0QnlJZCA9IGFzeW5jIChpZDogc3RyaW5nKTogUHJvbWlzZTxQcm9kdWN0IHwgbnVsbD4gPT4ge1xyXG4gIHRyeSB7XHJcbiAgICAvLyBDaGVjayBpZiBwcm9kdWN0IGlzIGluIGNhY2hlXHJcbiAgICBpZiAocHJvZHVjdENhY2hlLmJ5SWRbaWRdKSB7XHJcbiAgICAgIGNvbnNvbGUubG9nKGBSZXR1cm5pbmcgcHJvZHVjdCAke2lkfSBmcm9tIGNhY2hlYCk7XHJcbiAgICAgIHJldHVybiBwcm9kdWN0Q2FjaGUuYnlJZFtpZF07XHJcbiAgICB9XHJcbiAgICBcclxuICAgIGNvbnNvbGUubG9nKGBGZXRjaGluZyBwcm9kdWN0ICR7aWR9IGZyb20gRmlyZXN0b3JlYCk7XHJcbiAgICBjb25zdCBwcm9kdWN0RG9jID0gZG9jKGRiLCAncHJvZHVjdHMnLCBpZCk7XHJcbiAgICBjb25zdCBzbmFwc2hvdCA9IGF3YWl0IGdldERvYyhwcm9kdWN0RG9jKTtcclxuICAgIFxyXG4gICAgaWYgKHNuYXBzaG90LmV4aXN0cygpKSB7XHJcbiAgICAgIGNvbnN0IHByb2R1Y3QgPSB7XHJcbiAgICAgICAgaWQ6IHNuYXBzaG90LmlkLFxyXG4gICAgICAgIC4uLnNuYXBzaG90LmRhdGEoKVxyXG4gICAgICB9IGFzIFByb2R1Y3Q7XHJcbiAgICAgIFxyXG4gICAgICAvLyBVcGRhdGUgY2FjaGVcclxuICAgICAgcHJvZHVjdENhY2hlLmJ5SWRbaWRdID0gcHJvZHVjdDtcclxuICAgICAgXHJcbiAgICAgIHJldHVybiBwcm9kdWN0O1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIG51bGw7XHJcbiAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGdldHRpbmcgcHJvZHVjdDonLCBlcnJvcik7XHJcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZhaWxlZCB0byBmZXRjaCBwcm9kdWN0IGRldGFpbHMnKTtcclxuICB9XHJcbn07XHJcblxyXG4vLyBDbGVhciBjYWNoZSBmb3IgYSBzcGVjaWZpYyBwcm9kdWN0XHJcbmNvbnN0IGludmFsaWRhdGVQcm9kdWN0Q2FjaGUgPSAocHJvZHVjdElkOiBzdHJpbmcsIGNhdGVnb3J5SWQ/OiBzdHJpbmcpID0+IHtcclxuICAvLyBSZW1vdmUgZnJvbSBieUlkIGNhY2hlXHJcbiAgaWYgKHByb2R1Y3RDYWNoZS5ieUlkW3Byb2R1Y3RJZF0pIHtcclxuICAgIGRlbGV0ZSBwcm9kdWN0Q2FjaGUuYnlJZFtwcm9kdWN0SWRdO1xyXG4gIH1cclxuICBcclxuICAvLyBSZW1vdmUgZnJvbSBjYXRlZ29yeSBjYWNoZSBpZiBjYXRlZ29yeSBpcyBwcm92aWRlZFxyXG4gIGlmIChjYXRlZ29yeUlkICYmIHByb2R1Y3RDYWNoZS5ieUNhdGVnb3J5W2NhdGVnb3J5SWRdKSB7XHJcbiAgICBwcm9kdWN0Q2FjaGUuYnlDYXRlZ29yeVtjYXRlZ29yeUlkXSA9IHByb2R1Y3RDYWNoZS5ieUNhdGVnb3J5W2NhdGVnb3J5SWRdLmZpbHRlcihcclxuICAgICAgcCA9PiBwLmlkICE9PSBwcm9kdWN0SWRcclxuICAgICk7XHJcbiAgfVxyXG4gIFxyXG4gIC8vIFNldCBhbGwgY2FjaGUgdG8gbnVsbCB0byBmb3JjZSByZWZyZXNoIG9uIG5leHQgZmV0Y2hcclxuICBwcm9kdWN0Q2FjaGUuYWxsID0gbnVsbDtcclxufTtcclxuXHJcbi8vIENsZWFyIGVudGlyZSBjYWNoZVxyXG5leHBvcnQgY29uc3QgY2xlYXJQcm9kdWN0Q2FjaGUgPSAoKSA9PiB7XHJcbiAgcHJvZHVjdENhY2hlLmFsbCA9IG51bGw7XHJcbiAgcHJvZHVjdENhY2hlLmJ5SWQgPSB7fTtcclxuICBwcm9kdWN0Q2FjaGUuYnlDYXRlZ29yeSA9IHt9O1xyXG4gIHByb2R1Y3RDYWNoZS5sYXN0RmV0Y2hlZCA9IDA7XHJcbn07XHJcblxyXG4vLyBVcGxvYWQgaW1hZ2UgdG8gRmlyZWJhc2UgU3RvcmFnZVxyXG5leHBvcnQgY29uc3QgdXBsb2FkUHJvZHVjdEltYWdlID0gYXN5bmMgKGZpbGU6IEZpbGUpOiBQcm9taXNlPHN0cmluZz4gPT4ge1xyXG4gIHRyeSB7XHJcbiAgICAvLyBDcmVhdGUgYSB1bmlxdWUgZmlsZW5hbWVcclxuICAgIGNvbnN0IHRpbWVzdGFtcCA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xyXG4gICAgY29uc3QgZmlsZU5hbWUgPSBgcHJvZHVjdF8ke3RpbWVzdGFtcH1fJHtmaWxlLm5hbWUucmVwbGFjZSgvW15hLXpBLVowLTkuXS9nLCAnXycpfWA7XHJcbiAgICBcclxuICAgIC8vIENyZWF0ZSBhIHJlZmVyZW5jZSB0byB0aGUgZmlsZSBpbiBzdG9yYWdlXHJcbiAgICBjb25zdCBzdG9yYWdlUmVmID0gcmVmKHN0b3JhZ2UsIGBwcm9kdWN0X2ltYWdlcy8ke2ZpbGVOYW1lfWApO1xyXG4gICAgXHJcbiAgICAvLyBVcGxvYWQgdGhlIGZpbGVcclxuICAgIGF3YWl0IHVwbG9hZEJ5dGVzKHN0b3JhZ2VSZWYsIGZpbGUpO1xyXG4gICAgXHJcbiAgICAvLyBHZXQgdGhlIGRvd25sb2FkIFVSTFxyXG4gICAgY29uc3QgZG93bmxvYWRVUkwgPSBhd2FpdCBnZXREb3dubG9hZFVSTChzdG9yYWdlUmVmKTtcclxuICAgIHJldHVybiBkb3dubG9hZFVSTDtcclxuICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgY29uc29sZS5lcnJvcignRXJyb3IgdXBsb2FkaW5nIGltYWdlOicsIGVycm9yKTtcclxuICAgIHRocm93IG5ldyBFcnJvcignRmFpbGVkIHRvIHVwbG9hZCBwcm9kdWN0IGltYWdlJyk7XHJcbiAgfVxyXG59O1xyXG5cclxuLy8gRGVsZXRlIHByb2R1Y3QgaW1hZ2UgZnJvbSBGaXJlYmFzZSBTdG9yYWdlXHJcbmV4cG9ydCBjb25zdCBkZWxldGVQcm9kdWN0SW1hZ2UgPSBhc3luYyAoaW1hZ2VVcmw6IHN0cmluZyk6IFByb21pc2U8dm9pZD4gPT4ge1xyXG4gIHRyeSB7XHJcbiAgICAvLyBFeHRyYWN0IHRoZSBmaWxlIHBhdGggZnJvbSB0aGUgVVJMXHJcbiAgICBjb25zdCBkZWNvZGVkVXJsID0gZGVjb2RlVVJJQ29tcG9uZW50KGltYWdlVXJsKTtcclxuICAgIGNvbnN0IHN0YXJ0SW5kZXggPSBkZWNvZGVkVXJsLmluZGV4T2YoJ3Byb2R1Y3RfaW1hZ2VzJyk7XHJcbiAgICBcclxuICAgIGlmIChzdGFydEluZGV4ID09PSAtMSkge1xyXG4gICAgICBjb25zb2xlLndhcm4oJ05vdCBhIEZpcmViYXNlIFN0b3JhZ2UgVVJMIG9yIG5vdCBpbiBwcm9kdWN0X2ltYWdlcyBmb2xkZXI6JywgaW1hZ2VVcmwpO1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICBcclxuICAgIGNvbnN0IGVuZEluZGV4ID0gZGVjb2RlZFVybC5pbmRleE9mKCc/Jywgc3RhcnRJbmRleCk7XHJcbiAgICBjb25zdCBmaWxlUGF0aCA9IGVuZEluZGV4ICE9PSAtMSBcclxuICAgICAgPyBkZWNvZGVkVXJsLnN1YnN0cmluZyhzdGFydEluZGV4LCBlbmRJbmRleCkgXHJcbiAgICAgIDogZGVjb2RlZFVybC5zdWJzdHJpbmcoc3RhcnRJbmRleCk7XHJcbiAgICBcclxuICAgIC8vIENyZWF0ZSBhIHJlZmVyZW5jZSB0byB0aGUgZmlsZVxyXG4gICAgY29uc3QgaW1hZ2VSZWYgPSByZWYoc3RvcmFnZSwgZmlsZVBhdGgpO1xyXG4gICAgXHJcbiAgICAvLyBEZWxldGUgdGhlIGZpbGVcclxuICAgIGF3YWl0IGRlbGV0ZU9iamVjdChpbWFnZVJlZik7XHJcbiAgICBjb25zb2xlLmxvZygnUHJvZHVjdCBpbWFnZSBkZWxldGVkIHN1Y2Nlc3NmdWxseTonLCBmaWxlUGF0aCk7XHJcbiAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGRlbGV0aW5nIHByb2R1Y3QgaW1hZ2U6JywgZXJyb3IpO1xyXG4gICAgLy8gRG9uJ3QgdGhyb3cgZXJyb3IgaGVyZSwgYXMgd2Ugd2FudCB0byBjb250aW51ZSB3aXRoIHByb2R1Y3QgZGVsZXRpb25cclxuICAgIC8vIGV2ZW4gaWYgaW1hZ2UgZGVsZXRpb24gZmFpbHNcclxuICB9XHJcbn07XHJcblxyXG4vLyBBZGQgYSBuZXcgcHJvZHVjdCB3aXRoIHRyYW5zYWN0aW9uIGZvciBjYXRlZ29yeSB0cmFja2luZ1xyXG5leHBvcnQgY29uc3QgYWRkUHJvZHVjdCA9IGFzeW5jIChwcm9kdWN0OiBPbWl0PFByb2R1Y3QsICdpZCc+KTogUHJvbWlzZTxQcm9kdWN0PiA9PiB7XHJcbiAgdHJ5IHtcclxuICAgIGNvbnNvbGUubG9nKCdBZGRpbmcgcHJvZHVjdCB0byBGaXJlc3RvcmU6JywgcHJvZHVjdCk7XHJcbiAgICBcclxuICAgIC8vIFZhbGlkYXRlIHByb2R1Y3QgZGF0YVxyXG4gICAgY29uc3QgdmFsaWRhdGlvbkVycm9yID0gdmFsaWRhdGVQcm9kdWN0KHByb2R1Y3QpO1xyXG4gICAgaWYgKHZhbGlkYXRpb25FcnJvcikge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IodmFsaWRhdGlvbkVycm9yKTtcclxuICAgIH1cclxuICAgIFxyXG4gICAgLy8gQ2xlYW4gdGhlIHByb2R1Y3QgZGF0YSBmb3IgRmlyZXN0b3JlXHJcbiAgICBjb25zdCBjbGVhbmVkUHJvZHVjdCA9IGNsZWFuUHJvZHVjdERhdGEocHJvZHVjdCk7XHJcbiAgICBjb25zb2xlLmxvZygnQ2xlYW5lZCBwcm9kdWN0IGRhdGEgZm9yIEZpcmVzdG9yZTonLCBjbGVhbmVkUHJvZHVjdCk7XHJcbiAgICBcclxuICAgIC8vIFVzZSB0cmFuc2FjdGlvbiB0byBhZGQgcHJvZHVjdCBhbmQgdXBkYXRlIGNhdGVnb3J5IGRhdGFcclxuICAgIGNvbnN0IG5ld1Byb2R1Y3QgPSBhd2FpdCBydW5UcmFuc2FjdGlvbihkYiwgYXN5bmMgKHRyYW5zYWN0aW9uKSA9PiB7XHJcbiAgICAgIC8vIEFkZCB0aGUgcHJvZHVjdCBkb2N1bWVudFxyXG4gICAgICBjb25zdCBkb2NSZWYgPSBhd2FpdCBhZGREb2MocHJvZHVjdHNDb2xsZWN0aW9uLCBjbGVhbmVkUHJvZHVjdCk7XHJcbiAgICAgIGNvbnN0IG5ld1Byb2R1Y3RXaXRoSWQgPSB7IGlkOiBkb2NSZWYuaWQsIC4uLmNsZWFuZWRQcm9kdWN0IH07XHJcbiAgICAgIFxyXG4gICAgICAvLyBVcGRhdGUgb3IgY3JlYXRlIGNhdGVnb3J5IGNvdW50XHJcbiAgICAgIGNvbnN0IGNhdGVnb3J5UmVmID0gZG9jKGNhdGVnb3JpZXNDb2xsZWN0aW9uLCBjbGVhbmVkUHJvZHVjdC5jYXRlZ29yeSk7XHJcbiAgICAgIGNvbnN0IGNhdGVnb3J5RG9jID0gYXdhaXQgdHJhbnNhY3Rpb24uZ2V0KGNhdGVnb3J5UmVmKTtcclxuICAgICAgXHJcbiAgICAgIGlmIChjYXRlZ29yeURvYy5leGlzdHMoKSkge1xyXG4gICAgICAgIC8vIFVwZGF0ZSBleGlzdGluZyBjYXRlZ29yeVxyXG4gICAgICAgIHRyYW5zYWN0aW9uLnVwZGF0ZShjYXRlZ29yeVJlZiwge1xyXG4gICAgICAgICAgY291bnQ6IChjYXRlZ29yeURvYy5kYXRhKCkuY291bnQgfHwgMCkgKyAxLFxyXG4gICAgICAgICAgdXBkYXRlZEF0OiBzZXJ2ZXJUaW1lc3RhbXAoKVxyXG4gICAgICAgIH0pO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIC8vIENyZWF0ZSBuZXcgY2F0ZWdvcnlcclxuICAgICAgICB0cmFuc2FjdGlvbi5zZXQoY2F0ZWdvcnlSZWYsIHtcclxuICAgICAgICAgIGlkOiBjbGVhbmVkUHJvZHVjdC5jYXRlZ29yeSxcclxuICAgICAgICAgIG5hbWU6IGNsZWFuZWRQcm9kdWN0LmNhdGVnb3J5LmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgY2xlYW5lZFByb2R1Y3QuY2F0ZWdvcnkuc2xpY2UoMSksXHJcbiAgICAgICAgICBjb3VudDogMSxcclxuICAgICAgICAgIGNyZWF0ZWRBdDogc2VydmVyVGltZXN0YW1wKCksXHJcbiAgICAgICAgICB1cGRhdGVkQXQ6IHNlcnZlclRpbWVzdGFtcCgpXHJcbiAgICAgICAgfSk7XHJcbiAgICAgIH1cclxuICAgICAgXHJcbiAgICAgIHJldHVybiBuZXdQcm9kdWN0V2l0aElkO1xyXG4gICAgfSk7XHJcbiAgICBcclxuICAgIC8vIFVwZGF0ZSBjYWNoZSB3aXRoIHRoZSBuZXcgcHJvZHVjdFxyXG4gICAgaWYgKHByb2R1Y3RDYWNoZS5hbGwpIHtcclxuICAgICAgcHJvZHVjdENhY2hlLmFsbC51bnNoaWZ0KG5ld1Byb2R1Y3QgYXMgUHJvZHVjdCk7XHJcbiAgICB9XHJcbiAgICBcclxuICAgIHByb2R1Y3RDYWNoZS5ieUlkW25ld1Byb2R1Y3QuaWRdID0gbmV3UHJvZHVjdCBhcyBQcm9kdWN0O1xyXG4gICAgXHJcbiAgICBpZiAobmV3UHJvZHVjdC5jYXRlZ29yeSkge1xyXG4gICAgICBpZiAoIXByb2R1Y3RDYWNoZS5ieUNhdGVnb3J5W25ld1Byb2R1Y3QuY2F0ZWdvcnldKSB7XHJcbiAgICAgICAgcHJvZHVjdENhY2hlLmJ5Q2F0ZWdvcnlbbmV3UHJvZHVjdC5jYXRlZ29yeV0gPSBbXTtcclxuICAgICAgfVxyXG4gICAgICBwcm9kdWN0Q2FjaGUuYnlDYXRlZ29yeVtuZXdQcm9kdWN0LmNhdGVnb3J5XS51bnNoaWZ0KG5ld1Byb2R1Y3QgYXMgUHJvZHVjdCk7XHJcbiAgICB9XHJcbiAgICBcclxuICAgIGNvbnNvbGUubG9nKCdQcm9kdWN0IGFkZGVkIHN1Y2Nlc3NmdWxseSB3aXRoIElEOicsIG5ld1Byb2R1Y3QuaWQpO1xyXG4gICAgcmV0dXJuIG5ld1Byb2R1Y3QgYXMgUHJvZHVjdDtcclxuICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgY29uc29sZS5lcnJvcignRXJyb3IgYWRkaW5nIHByb2R1Y3QgdG8gRmlyZXN0b3JlOicsIGVycm9yKTtcclxuICAgIHRocm93IGVycm9yO1xyXG4gIH1cclxufTtcclxuXHJcbi8vIFVwZGF0ZSBhIHByb2R1Y3RcclxuZXhwb3J0IGNvbnN0IHVwZGF0ZVByb2R1Y3QgPSBhc3luYyAoaWQ6IHN0cmluZywgcHJvZHVjdDogUGFydGlhbDxQcm9kdWN0Pik6IFByb21pc2U8dm9pZD4gPT4ge1xyXG4gIHRyeSB7XHJcbiAgICBjb25zdCBwcm9kdWN0RG9jID0gZG9jKGRiLCAncHJvZHVjdHMnLCBpZCk7XHJcbiAgICBcclxuICAgIC8vIEdldCBleGlzdGluZyBwcm9kdWN0IHRvIGNoZWNrIGlmIGNhdGVnb3J5IGlzIGNoYW5naW5nXHJcbiAgICBjb25zdCBleGlzdGluZ1Byb2R1Y3RTbmFwID0gYXdhaXQgZ2V0RG9jKHByb2R1Y3REb2MpO1xyXG4gICAgaWYgKCFleGlzdGluZ1Byb2R1Y3RTbmFwLmV4aXN0cygpKSB7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcignUHJvZHVjdCBub3QgZm91bmQnKTtcclxuICAgIH1cclxuICAgIFxyXG4gICAgY29uc3QgZXhpc3RpbmdQcm9kdWN0ID0gZXhpc3RpbmdQcm9kdWN0U25hcC5kYXRhKCk7XHJcbiAgICBjb25zdCBjbGVhbmVkVXBkYXRlcyA9IGNsZWFuUHJvZHVjdERhdGEocHJvZHVjdCk7XHJcbiAgICBcclxuICAgIC8vIEFsd2F5cyB1cGRhdGUgdGhlIHRpbWVzdGFtcCB3aGVuIG1vZGlmaWVkXHJcbiAgICBjbGVhbmVkVXBkYXRlcy51cGRhdGVkQXQgPSBzZXJ2ZXJUaW1lc3RhbXAoKTtcclxuICAgIFxyXG4gICAgYXdhaXQgcnVuVHJhbnNhY3Rpb24oZGIsIGFzeW5jICh0cmFuc2FjdGlvbikgPT4ge1xyXG4gICAgICAvLyBVcGRhdGUgcHJvZHVjdCBkb2N1bWVudFxyXG4gICAgICB0cmFuc2FjdGlvbi51cGRhdGUocHJvZHVjdERvYywgY2xlYW5lZFVwZGF0ZXMpO1xyXG4gICAgICBcclxuICAgICAgLy8gSWYgY2F0ZWdvcnkgY2hhbmdlZCwgdXBkYXRlIGJvdGggb2xkIGFuZCBuZXcgY2F0ZWdvcnkgY291bnRzXHJcbiAgICAgIGlmIChwcm9kdWN0LmNhdGVnb3J5ICYmIGV4aXN0aW5nUHJvZHVjdC5jYXRlZ29yeSAhPT0gcHJvZHVjdC5jYXRlZ29yeSkge1xyXG4gICAgICAgIC8vIERlY3JlYXNlIG9sZCBjYXRlZ29yeSBjb3VudFxyXG4gICAgICAgIGNvbnN0IG9sZENhdGVnb3J5UmVmID0gZG9jKGNhdGVnb3JpZXNDb2xsZWN0aW9uLCBleGlzdGluZ1Byb2R1Y3QuY2F0ZWdvcnkpO1xyXG4gICAgICAgIGNvbnN0IG9sZENhdGVnb3J5RG9jID0gYXdhaXQgdHJhbnNhY3Rpb24uZ2V0KG9sZENhdGVnb3J5UmVmKTtcclxuICAgICAgICBcclxuICAgICAgICBpZiAob2xkQ2F0ZWdvcnlEb2MuZXhpc3RzKCkpIHtcclxuICAgICAgICAgIGNvbnN0IG9sZENvdW50ID0gb2xkQ2F0ZWdvcnlEb2MuZGF0YSgpLmNvdW50IHx8IDA7XHJcbiAgICAgICAgICBpZiAob2xkQ291bnQgPiAxKSB7XHJcbiAgICAgICAgICAgIHRyYW5zYWN0aW9uLnVwZGF0ZShvbGRDYXRlZ29yeVJlZiwgeyBcclxuICAgICAgICAgICAgICBjb3VudDogb2xkQ291bnQgLSAxLFxyXG4gICAgICAgICAgICAgIHVwZGF0ZWRBdDogc2VydmVyVGltZXN0YW1wKClcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAvLyBEZWxldGUgY2F0ZWdvcnkgaWYgaXQgd2lsbCBiZSBlbXB0eVxyXG4gICAgICAgICAgICB0cmFuc2FjdGlvbi5kZWxldGUob2xkQ2F0ZWdvcnlSZWYpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBcclxuICAgICAgICAvLyBJbmNyZWFzZSBuZXcgY2F0ZWdvcnkgY291bnRcclxuICAgICAgICBjb25zdCBuZXdDYXRlZ29yeVJlZiA9IGRvYyhjYXRlZ29yaWVzQ29sbGVjdGlvbiwgcHJvZHVjdC5jYXRlZ29yeSk7XHJcbiAgICAgICAgY29uc3QgbmV3Q2F0ZWdvcnlEb2MgPSBhd2FpdCB0cmFuc2FjdGlvbi5nZXQobmV3Q2F0ZWdvcnlSZWYpO1xyXG4gICAgICAgIFxyXG4gICAgICAgIGlmIChuZXdDYXRlZ29yeURvYy5leGlzdHMoKSkge1xyXG4gICAgICAgICAgdHJhbnNhY3Rpb24udXBkYXRlKG5ld0NhdGVnb3J5UmVmLCB7IFxyXG4gICAgICAgICAgICBjb3VudDogKG5ld0NhdGVnb3J5RG9jLmRhdGEoKS5jb3VudCB8fCAwKSArIDEsXHJcbiAgICAgICAgICAgIHVwZGF0ZWRBdDogc2VydmVyVGltZXN0YW1wKClcclxuICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICB0cmFuc2FjdGlvbi5zZXQobmV3Q2F0ZWdvcnlSZWYsIHtcclxuICAgICAgICAgICAgaWQ6IHByb2R1Y3QuY2F0ZWdvcnksXHJcbiAgICAgICAgICAgIG5hbWU6IHByb2R1Y3QuY2F0ZWdvcnkuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBwcm9kdWN0LmNhdGVnb3J5LnNsaWNlKDEpLFxyXG4gICAgICAgICAgICBjb3VudDogMSxcclxuICAgICAgICAgICAgY3JlYXRlZEF0OiBzZXJ2ZXJUaW1lc3RhbXAoKSxcclxuICAgICAgICAgICAgdXBkYXRlZEF0OiBzZXJ2ZXJUaW1lc3RhbXAoKVxyXG4gICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9KTtcclxuICAgIFxyXG4gICAgLy8gVXBkYXRlIGNhY2hlXHJcbiAgICBpZiAocHJvZHVjdENhY2hlLmJ5SWRbaWRdKSB7XHJcbiAgICAgIGNvbnN0IHVwZGF0ZWRQcm9kdWN0ID0geyAuLi5wcm9kdWN0Q2FjaGUuYnlJZFtpZF0sIC4uLnByb2R1Y3QgfTtcclxuICAgICAgcHJvZHVjdENhY2hlLmJ5SWRbaWRdID0gdXBkYXRlZFByb2R1Y3Q7XHJcbiAgICAgIFxyXG4gICAgICAvLyBVcGRhdGUgaW4gYWxsIHByb2R1Y3RzIGNhY2hlIGlmIGl0IGV4aXN0c1xyXG4gICAgICBpZiAocHJvZHVjdENhY2hlLmFsbCkge1xyXG4gICAgICAgIGNvbnN0IGluZGV4ID0gcHJvZHVjdENhY2hlLmFsbC5maW5kSW5kZXgocCA9PiBwLmlkID09PSBpZCk7XHJcbiAgICAgICAgaWYgKGluZGV4ID49IDApIHtcclxuICAgICAgICAgIHByb2R1Y3RDYWNoZS5hbGxbaW5kZXhdID0gdXBkYXRlZFByb2R1Y3Q7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIFxyXG4gICAgICAvLyBIYW5kbGUgY2F0ZWdvcnkgY2hhbmdlIGluIGNhY2hlXHJcbiAgICAgIGlmIChwcm9kdWN0LmNhdGVnb3J5ICYmIGV4aXN0aW5nUHJvZHVjdC5jYXRlZ29yeSAhPT0gcHJvZHVjdC5jYXRlZ29yeSkge1xyXG4gICAgICAgIC8vIFJlbW92ZSBmcm9tIG9sZCBjYXRlZ29yeSBjYWNoZVxyXG4gICAgICAgIGlmIChwcm9kdWN0Q2FjaGUuYnlDYXRlZ29yeVtleGlzdGluZ1Byb2R1Y3QuY2F0ZWdvcnldKSB7XHJcbiAgICAgICAgICBwcm9kdWN0Q2FjaGUuYnlDYXRlZ29yeVtleGlzdGluZ1Byb2R1Y3QuY2F0ZWdvcnldID0gcHJvZHVjdENhY2hlLmJ5Q2F0ZWdvcnlbZXhpc3RpbmdQcm9kdWN0LmNhdGVnb3J5XS5maWx0ZXIoXHJcbiAgICAgICAgICAgIHAgPT4gcC5pZCAhPT0gaWRcclxuICAgICAgICAgICk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIFxyXG4gICAgICAgIC8vIEFkZCB0byBuZXcgY2F0ZWdvcnkgY2FjaGVcclxuICAgICAgICBpZiAoIXByb2R1Y3RDYWNoZS5ieUNhdGVnb3J5W3Byb2R1Y3QuY2F0ZWdvcnldKSB7XHJcbiAgICAgICAgICBwcm9kdWN0Q2FjaGUuYnlDYXRlZ29yeVtwcm9kdWN0LmNhdGVnb3J5XSA9IFtdO1xyXG4gICAgICAgIH1cclxuICAgICAgICBwcm9kdWN0Q2FjaGUuYnlDYXRlZ29yeVtwcm9kdWN0LmNhdGVnb3J5XS5wdXNoKHVwZGF0ZWRQcm9kdWN0KTtcclxuICAgICAgfSBlbHNlIGlmIChwcm9kdWN0LmNhdGVnb3J5KSB7XHJcbiAgICAgICAgLy8gVXBkYXRlIGluIHNhbWUgY2F0ZWdvcnlcclxuICAgICAgICBpZiAocHJvZHVjdENhY2hlLmJ5Q2F0ZWdvcnlbcHJvZHVjdC5jYXRlZ29yeV0pIHtcclxuICAgICAgICAgIGNvbnN0IGNhdEluZGV4ID0gcHJvZHVjdENhY2hlLmJ5Q2F0ZWdvcnlbcHJvZHVjdC5jYXRlZ29yeV0uZmluZEluZGV4KHAgPT4gcC5pZCA9PT0gaWQpO1xyXG4gICAgICAgICAgaWYgKGNhdEluZGV4ID49IDApIHtcclxuICAgICAgICAgICAgcHJvZHVjdENhY2hlLmJ5Q2F0ZWdvcnlbcHJvZHVjdC5jYXRlZ29yeV1bY2F0SW5kZXhdID0gdXBkYXRlZFByb2R1Y3Q7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAvLyBJZiBub3QgaW4gY2FjaGUsIGludmFsaWRhdGUgYWxsIGNhY2hlIHRvIGZvcmNlIHJlZnJlc2hcclxuICAgICAgY2xlYXJQcm9kdWN0Q2FjaGUoKTtcclxuICAgIH1cclxuICAgIFxyXG4gIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICBjb25zb2xlLmVycm9yKCdFcnJvciB1cGRhdGluZyBwcm9kdWN0OicsIGVycm9yKTtcclxuICAgIHRocm93IG5ldyBFcnJvcignRmFpbGVkIHRvIHVwZGF0ZSBwcm9kdWN0Jyk7XHJcbiAgfVxyXG59O1xyXG5cclxuLy8gRGVsZXRlIGEgcHJvZHVjdFxyXG5leHBvcnQgY29uc3QgZGVsZXRlUHJvZHVjdCA9IGFzeW5jIChpZDogc3RyaW5nKTogUHJvbWlzZTx2b2lkPiA9PiB7XHJcbiAgdHJ5IHtcclxuICAgIGNvbnN0IHByb2R1Y3REb2MgPSBkb2MoZGIsICdwcm9kdWN0cycsIGlkKTtcclxuICAgIFxyXG4gICAgLy8gR2V0IHByb2R1Y3QgdG8gZmluZCBpdHMgY2F0ZWdvcnkgYW5kIGltYWdlIFVSTFxyXG4gICAgY29uc3QgcHJvZHVjdFNuYXAgPSBhd2FpdCBnZXREb2MocHJvZHVjdERvYyk7XHJcbiAgICBpZiAoIXByb2R1Y3RTbmFwLmV4aXN0cygpKSB7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcignUHJvZHVjdCBub3QgZm91bmQnKTtcclxuICAgIH1cclxuICAgIFxyXG4gICAgY29uc3QgcHJvZHVjdERhdGEgPSBwcm9kdWN0U25hcC5kYXRhKCkgYXMgUHJvZHVjdDtcclxuICAgIFxyXG4gICAgLy8gVHJ5IHRvIGRlbGV0ZSB0aGUgcHJvZHVjdCBpbWFnZSBmaXJzdFxyXG4gICAgaWYgKHByb2R1Y3REYXRhLmltYWdlKSB7XHJcbiAgICAgIHRyeSB7XHJcbiAgICAgICAgYXdhaXQgZGVsZXRlUHJvZHVjdEltYWdlKHByb2R1Y3REYXRhLmltYWdlKTtcclxuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBkZWxldGluZyBwcm9kdWN0IGltYWdlOicsIGVycm9yKTtcclxuICAgICAgICAvLyBDb250aW51ZSB3aXRoIHByb2R1Y3QgZGVsZXRpb24gZXZlbiBpZiBpbWFnZSBkZWxldGlvbiBmYWlsc1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICBcclxuICAgIGF3YWl0IHJ1blRyYW5zYWN0aW9uKGRiLCBhc3luYyAodHJhbnNhY3Rpb24pID0+IHtcclxuICAgICAgLy8gRGVsZXRlIHByb2R1Y3RcclxuICAgICAgdHJhbnNhY3Rpb24uZGVsZXRlKHByb2R1Y3REb2MpO1xyXG4gICAgICBcclxuICAgICAgLy8gVXBkYXRlIGNhdGVnb3J5IGNvdW50XHJcbiAgICAgIGlmIChwcm9kdWN0RGF0YS5jYXRlZ29yeSkge1xyXG4gICAgICAgIGNvbnN0IGNhdGVnb3J5UmVmID0gZG9jKGNhdGVnb3JpZXNDb2xsZWN0aW9uLCBwcm9kdWN0RGF0YS5jYXRlZ29yeSk7XHJcbiAgICAgICAgY29uc3QgY2F0ZWdvcnlEb2MgPSBhd2FpdCB0cmFuc2FjdGlvbi5nZXQoY2F0ZWdvcnlSZWYpO1xyXG4gICAgICAgIFxyXG4gICAgICAgIGlmIChjYXRlZ29yeURvYy5leGlzdHMoKSkge1xyXG4gICAgICAgICAgY29uc3QgY291bnQgPSBjYXRlZ29yeURvYy5kYXRhKCkuY291bnQgfHwgMDtcclxuICAgICAgICAgIGlmIChjb3VudCA+IDEpIHtcclxuICAgICAgICAgICAgdHJhbnNhY3Rpb24udXBkYXRlKGNhdGVnb3J5UmVmLCB7IFxyXG4gICAgICAgICAgICAgIGNvdW50OiBjb3VudCAtIDEsXHJcbiAgICAgICAgICAgICAgdXBkYXRlZEF0OiBzZXJ2ZXJUaW1lc3RhbXAoKVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIC8vIERlbGV0ZSBjYXRlZ29yeSBpZiBpdCB3aWxsIGJlIGVtcHR5XHJcbiAgICAgICAgICAgIHRyYW5zYWN0aW9uLmRlbGV0ZShjYXRlZ29yeVJlZik7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9KTtcclxuICAgIFxyXG4gICAgLy8gVXBkYXRlIGNhY2hlXHJcbiAgICBpbnZhbGlkYXRlUHJvZHVjdENhY2hlKGlkLCBwcm9kdWN0RGF0YS5jYXRlZ29yeSk7XHJcbiAgICBcclxuICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgY29uc29sZS5lcnJvcignRXJyb3IgZGVsZXRpbmcgcHJvZHVjdDonLCBlcnJvcik7XHJcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZhaWxlZCB0byBkZWxldGUgcHJvZHVjdCcpO1xyXG4gIH1cclxufTtcclxuXHJcbi8vIEdldCBhbGwgY2F0ZWdvcmllcyB3aXRoIHByb2R1Y3QgY291bnRzXHJcbmV4cG9ydCBjb25zdCBnZXRBbGxDYXRlZ29yaWVzID0gYXN5bmMgKCkgPT4ge1xyXG4gIHRyeSB7XHJcbiAgICBjb25zdCBzbmFwc2hvdCA9IGF3YWl0IGdldERvY3MoY2F0ZWdvcmllc0NvbGxlY3Rpb24pO1xyXG4gICAgcmV0dXJuIHNuYXBzaG90LmRvY3MubWFwKGRvYyA9PiBkb2MuZGF0YSgpKTtcclxuICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgY29uc29sZS5lcnJvcignRXJyb3IgZ2V0dGluZyBjYXRlZ29yaWVzOicsIGVycm9yKTtcclxuICAgIHRocm93IG5ldyBFcnJvcignRmFpbGVkIHRvIGZldGNoIGNhdGVnb3JpZXMnKTtcclxuICB9XHJcbn07ICJdLCJuYW1lcyI6WyJhcHAiLCJnZXRGaXJlc3RvcmUiLCJjb2xsZWN0aW9uIiwiZ2V0RG9jcyIsImRvYyIsImdldERvYyIsImFkZERvYyIsInF1ZXJ5Iiwid2hlcmUiLCJydW5UcmFuc2FjdGlvbiIsInNlcnZlclRpbWVzdGFtcCIsImxpbWl0Iiwib3JkZXJCeSIsInN0YXJ0QWZ0ZXIiLCJnZXRTdG9yYWdlIiwicmVmIiwidXBsb2FkQnl0ZXMiLCJnZXREb3dubG9hZFVSTCIsImRlbGV0ZU9iamVjdCIsImRiIiwic3RvcmFnZSIsInByb2R1Y3RzQ29sbGVjdGlvbiIsImNhdGVnb3JpZXNDb2xsZWN0aW9uIiwicHJvZHVjdENhY2hlIiwiYWxsIiwiYnlJZCIsImJ5Q2F0ZWdvcnkiLCJsYXN0RmV0Y2hlZCIsIkNBQ0hFX0VYUElSQVRJT04iLCJ2YWxpZGF0ZVByb2R1Y3QiLCJwcm9kdWN0IiwibmFtZSIsInByaWNlIiwiaXNOYU4iLCJOdW1iZXIiLCJjYXRlZ29yeSIsImltYWdlIiwiY2xlYW5Qcm9kdWN0RGF0YSIsImNsZWFuZWRQcm9kdWN0IiwiT2JqZWN0IiwiZW50cmllcyIsImZvckVhY2giLCJrZXkiLCJ2YWx1ZSIsInVuZGVmaW5lZCIsInNwbGl0IiwibWFwIiwicyIsInRyaW0iLCJmaWx0ZXIiLCJCb29sZWFuIiwiY3JlYXRlZEF0IiwidXBkYXRlZEF0IiwiaXNDYWNoZVZhbGlkIiwiRGF0ZSIsIm5vdyIsImdldEFsbFByb2R1Y3RzIiwicGFnZVNpemUiLCJjb25zb2xlIiwibG9nIiwicHJvZHVjdHNRdWVyeSIsInNuYXBzaG90IiwicHJvZHVjdHMiLCJkb2NzIiwiaWQiLCJkYXRhIiwicHVzaCIsImxlbmd0aCIsImVycm9yIiwiRXJyb3IiLCJnZXROZXh0UHJvZHVjdHNQYWdlIiwibGFzdFZpc2libGUiLCJleGlzdGluZ0luZGV4IiwiZmluZEluZGV4IiwicCIsImdldFByb2R1Y3RzQnlDYXRlZ29yeSIsInEiLCJnZXRGZWF0dXJlZFByb2R1Y3RzIiwibGltaXRDb3VudCIsImZlYXR1cmVkIiwic2xpY2UiLCJnZXROZXdBcnJpdmFscyIsIm5ld0Fycml2YWxzIiwibmV3IiwiZ2V0UHJvZHVjdEJ5SWQiLCJwcm9kdWN0RG9jIiwiZXhpc3RzIiwiaW52YWxpZGF0ZVByb2R1Y3RDYWNoZSIsInByb2R1Y3RJZCIsImNhdGVnb3J5SWQiLCJjbGVhclByb2R1Y3RDYWNoZSIsInVwbG9hZFByb2R1Y3RJbWFnZSIsImZpbGUiLCJ0aW1lc3RhbXAiLCJnZXRUaW1lIiwiZmlsZU5hbWUiLCJyZXBsYWNlIiwic3RvcmFnZVJlZiIsImRvd25sb2FkVVJMIiwiZGVsZXRlUHJvZHVjdEltYWdlIiwiaW1hZ2VVcmwiLCJkZWNvZGVkVXJsIiwiZGVjb2RlVVJJQ29tcG9uZW50Iiwic3RhcnRJbmRleCIsImluZGV4T2YiLCJ3YXJuIiwiZW5kSW5kZXgiLCJmaWxlUGF0aCIsInN1YnN0cmluZyIsImltYWdlUmVmIiwiYWRkUHJvZHVjdCIsInZhbGlkYXRpb25FcnJvciIsIm5ld1Byb2R1Y3QiLCJ0cmFuc2FjdGlvbiIsImRvY1JlZiIsIm5ld1Byb2R1Y3RXaXRoSWQiLCJjYXRlZ29yeVJlZiIsImNhdGVnb3J5RG9jIiwiZ2V0IiwidXBkYXRlIiwiY291bnQiLCJzZXQiLCJjaGFyQXQiLCJ0b1VwcGVyQ2FzZSIsInVuc2hpZnQiLCJ1cGRhdGVQcm9kdWN0IiwiZXhpc3RpbmdQcm9kdWN0U25hcCIsImV4aXN0aW5nUHJvZHVjdCIsImNsZWFuZWRVcGRhdGVzIiwib2xkQ2F0ZWdvcnlSZWYiLCJvbGRDYXRlZ29yeURvYyIsIm9sZENvdW50IiwiZGVsZXRlIiwibmV3Q2F0ZWdvcnlSZWYiLCJuZXdDYXRlZ29yeURvYyIsInVwZGF0ZWRQcm9kdWN0IiwiaW5kZXgiLCJjYXRJbmRleCIsImRlbGV0ZVByb2R1Y3QiLCJwcm9kdWN0U25hcCIsInByb2R1Y3REYXRhIiwiZ2V0QWxsQ2F0ZWdvcmllcyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./utils/firestore.ts\n"));

/***/ })

});